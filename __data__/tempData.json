{
  "data": [
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "10/14/2025, 11:17:30 AM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// 神戸市のマーク\r\nfunction setup(){\r\n  createCanvas(200, 200);\r\n  background(255);\r\n\r\n  noFill();\r\n  strokeWeight(25);\r\n  strokeCap(SQUARE);\r\n  arc(100 + 25, 100, 100, 100, QUARTER_PI * 3, QUARTER_PI * 3 + PI);\r\n  // BLANK[1] 空欄を埋めて神戸市のロゴマークを完成させよう\r\n  arc(100 - 25, 100, 100, 100, QUARTER_PI * 5, QUARTER_PI * 3 + PI);\r\n}\r\n"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "10/14/2025, 11:17:59 AM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// 神戸市のマーク\r\nfunction setup(){\r\n  createCanvas(200, 200);\r\n  background(255);\r\n\r\n  noFill();\r\n  strokeWeight(25);\r\n  strokeCap(SQUARE);\r\n  arc(100 + 25, 100, 100, 100, QUARTER_PI * 3, QUARTER_PI * 3 + PI);\r\n  // BLANK[1] 空欄を埋めて神戸市のロゴマークを完成させよう\r\n  arc(100 - 25, 100, 100, 100, QUARTER_PI * 5, QUARTER_PI * 5 + PI);\r\n}\r\n"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "10/14/2025, 11:32:20 AM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// 小手調べ\r\nfunction setup(){\r\n  createCanvas(100, 100);\r\n  noFill();\r\n  for(let i = 0; i < 10; i++){\r\n    // BLANK[1] 条件分岐を使って、前半は赤、後半は青で円を描こう\r\n  }\r\n  ellipse(50, 50, 50, 50)\r\n}\r\n"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "10/14/2025, 11:39:55 AM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// 小手調べ\r\nfunction setup(){\r\n  createCanvas(100, 100);\r\n  noFill();\r\n  for(let i = 0; i < 10; i++){\r\n    // BLANK[1] 条件分岐を使って、前半は赤、後半は青で円を描こう\r\n  }\r\n  ellipse(50, 50, 10, 10)\r\n}\r\n"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "10/14/2025, 11:43:47 AM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// 小手調べ\r\nfunction setup(){\r\n  createCanvas(100, 100);\r\n  noFill();\r\n  for(let i = 0; i < 10; i++){\r\n    // BLANK[1] 条件分岐を使って、前半は赤、後半は青で円を描こう\r\n  }\r\nfor(let i = 0; i < 10; i++)　｛｝\r\n}\r\n"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "10/14/2025, 11:44:40 AM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// 小手調べ\r\nfunction setup(){\r\n  createCanvas(100, 100);\r\n  noFill();\r\n    // BLANK[1] 条件分岐を使って、前半は赤、後半は青で円を描こう\r\nfor(let i = 0; i < 10; i++)　\r\n}\r\n"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "10/14/2025, 11:44:58 AM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// 小手調べ\r\nfunction setup(){\r\n  createCanvas(100, 100);\r\n    // BLANK[1] 条件分岐を使って、前半は赤、後半は青で円を描こう\r\nfor(let i = 0; i < 10; i++)　\r\n}\r\n"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "10/14/2025, 11:46:49 AM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// 小手調べ\r\nfunction setup(){\r\n  createCanvas(100, 100);\r\n    // BLANK[1] 条件分岐を使って、前半は赤、後半は青で円を描こう\r\nfor(let i = 0; i < 10; i++){\r\n}\r\n}"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "10/14/2025, 11:48:39 AM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// 小手調べ\r\nfunction setup(){\r\n  createCanvas(100, 100);\r\n    // BLANK[1] 条件分岐を使って、前半は赤、後半は青で円を描こう\r\nfor(let i = 0; i < 10; i++){\r\n}\r\nellipse(50,50, 100, 100)\r\n}"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "10/14/2025, 11:49:55 AM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// 小手調べ\r\nfunction setup(){\r\n  createCanvas(100, 100);\r\n    // BLANK[1] 条件分岐を使って、前半は赤、後半は青で円を描こう\r\nfor(let i = 0; i < 10; i++){\r\n}\r\nlet size = (i+1)*10;\r\nellipse(50,50, size, size)\r\n}"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "10/14/2025, 11:50:26 AM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// 小手調べ\r\nfunction setup(){\r\n  createCanvas(100, 100);\r\n    // BLANK[1] 条件分岐を使って、前半は赤、後半は青で円を描こう\r\nfor(let i = 0; i < 10; i++){\r\n}\r\nlet size = (i+1)*10;\r\nellipse(50,50, 100, 100)\r\n}"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "10/14/2025, 11:51:00 AM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// 小手調べ\r\nfunction setup(){\r\n  createCanvas(100, 100);\r\n    // BLANK[1] 条件分岐を使って、前半は赤、後半は青で円を描こう\r\nfor(let i = 0; i < 10; i++){\r\n\r\nlet size = (i+1)*10;\r\nellipse(50,50, 100, 100)\r\n}\r\n}"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "10/14/2025, 11:53:56 AM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// 小手調べ\r\nfunction setup(){\r\n  createCanvas(100, 100);\r\n    // BLANK[1] 条件分岐を使って、前半は赤、後半は青で円を描こう\r\nfor(let i = 0; i < 10; i++){\r\nlet size = (i+1)*10;\r\nnotfill();\r\nellipse(50,50, 100, 100)\r\n}\r\n}"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "10/14/2025, 11:55:09 AM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// 小手調べ\r\nfunction setup(){\r\n  createCanvas(100, 100);\r\n    // BLANK[1] 条件分岐を使って、前半は赤、後半は青で円を描こう\r\nfor(let i = 0; i < 10; i++){\r\nlet size = (i+1)*10;\r\nnotFill();\r\nellipse(50,50, 100, 100)\r\n}\r\n}"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "10/14/2025, 11:55:20 AM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// 小手調べ\r\nfunction setup(){\r\n  createCanvas(100, 100);\r\n    // BLANK[1] 条件分岐を使って、前半は赤、後半は青で円を描こう\r\nfor(let i = 0; i < 10; i++){\r\nlet size = (i+1)*10;\r\nnoFill();\r\nellipse(50,50, 100, 100)\r\n}\r\n}"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "10/14/2025, 12:01:15 PM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// 小手調べ\r\nfunction setup(){\r\n  createCanvas(100, 100);\r\n    // BLANK[1] 条件分岐を使って、前半は赤、後半は青で円を描こう\r\nfor(let i = 0; i < 10; i++){\r\nlet size = (i+1)*10;\r\nnoFill();\r\nif(i<5){\r\n  stroke(0, 0, 255); //青\r\n}else{\r\n  stroke(255, 0, 0); //赤\r\n}\r\n\r\nellipse(50,50, 100, 100)\r\n}\r\n}"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "10/14/2025, 12:01:48 PM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// 小手調べ\r\nfunction setup(){\r\n  createCanvas(100, 100);\r\n    // BLANK[1] 条件分岐を使って、前半は赤、後半は青で円を描こう\r\nfor(let i = 0; i < 10; i++){\r\nlet size = (i+1)*10;\r\nnoFill();\r\nif(i<5){\r\n  stroke(0, 0, 255); //青\r\n}else{\r\n  stroke(255, 0, 0); //赤\r\n}\r\n\r\nellipse(50,50, size, size\r\n}\r\n}"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "10/14/2025, 12:02:12 PM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// 小手調べ\r\nfunction setup(){\r\n  createCanvas(100, 100);\r\n    // BLANK[1] 条件分岐を使って、前半は赤、後半は青で円を描こう\r\nfor(let i = 0; i < 10; i++){\r\nlet size = (i+1)*10;\r\nnoFill();\r\nif(i<5){\r\n  stroke(0, 0, 255); //青\r\n}else{\r\n  stroke(255, 0, 0); //赤\r\n}\r\n\r\nellipse(50,50, size, size);\r\n}\r\n}"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "10/21/2025, 11:01:32 AM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// チェッカー\r\nfunction setup() {\r\n  createCanvas(200, 200);\r\n  const size = width / 8; // マスの一辺の長さ\r\n  noStroke();\r\n  for(let i = 0; i < 8; i++){\r\n    for(let j = 0; j < 8; j++){\r\n      // BLANK[1] ヒント： rectのx座標は size * i, y座標は size * j\r\n      rect(size * 1, size * j, size, size);\r\n    }\r\n  }\r\n}"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "10/21/2025, 11:02:24 AM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// チェッカー\r\nfunction setup() {\r\n  createCanvas(200, 200);\r\n  const size = width / 8; // マスの一辺の長さ\r\n  // noStroke();\r\n  for(let i = 0; i < 8; i++){\r\n    for(let j = 0; j < 8; j++){\r\n      // BLANK[1] ヒント： rectのx座標は size * i, y座標は size * j\r\n      rect(size * 1, size * j, size, size);\r\n    }\r\n  }\r\n}"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "10/21/2025, 11:05:41 AM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// チェッカー\r\nfunction setup() {\r\n  createCanvas(200, 200);\r\n  const size = width / 8; // マスの一辺の長さ\r\n  // noStroke();\r\n  for(let i = 0; i < 8; i++){\r\n    for(let j = 0; j < 8; j++){\r\n      // BLANK[1] ヒント： rectのx座標は size * i, y座標は size * j\r\n      rect(size * 1, size * j, size, size);\r\n      fill(255, 0, 0)\r\n    }\r\n  }\r\n}"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "10/21/2025, 11:09:49 AM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// チェッカー\r\nfunction setup() {\r\n  createCanvas(200, 200);\r\n  const size = width / 8; // マスの一辺の長さ\r\n  // noStroke();\r\n  for(let i = 0; i < 8; i++){\r\n    for(let j = 0; j < 8; j++){\r\n      // BLANK[1] ヒント： rectのx座標は size * i, y座標は size * j\r\n      fill(255, 0, 0)\r\n      rect(size * 1, size * j, size, size);\r\n    }\r\n  }\r\n}"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "10/21/2025, 11:10:30 AM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// チェッカー\r\nfunction setup() {\r\n  createCanvas(200, 200);\r\n  const size = width / 8; // マスの一辺の長さ\r\n  // noStroke();\r\n  for(let i = 0; i < 8; i++){\r\n    for(let j = 0; j < 8; j++){\r\n      // BLANK[1] ヒント： rectのx座標は size * i, y座標は size * j\r\n      fill(255, 0, 0)\r\n      rect(size * i, size * j, size, size);\r\n    }\r\n  }\r\n}"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "10/21/2025, 11:30:54 AM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// チェッカー\r\nfunction setup() {\r\n  createCanvas(200, 200);\r\n  const size = width / 8; // マスの一辺の長さ\r\n  // noStroke();\r\n  for(let i = 0; i < 8; i++){\r\n    for(let j = 0; j < 8; j++){\r\n      // BLANK[1] ヒント： rectのx座標は size * i, y座標は size * j\r\n      if((i + j) % 2 == 0)\r\n        {fill(0, 0, 0)\r\n        }\r\n      else((i + j) % 2 == 1)\r\n      {fill(105, 105, 105)}\r\n      rect(size * i, size * j, size, size);\r\n    }\r\n  }\r\n}"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "10/21/2025, 11:32:25 AM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// チェッカー\r\nfunction setup() {\r\n  createCanvas(200, 200);\r\n  const size = width / 8; // マスの一辺の長さ\r\n  // noStroke();\r\n  for(let i = 0; i < 8; i++){\r\n    for(let j = 0; j < 8; j++){\r\n      // BLANK[1] ヒント： rectのx座標は size * i, y座標は size * j\r\n      if((i + j) % 2 == 0)\r\n        {fill(0, 0, 0);\r\n        }\r\n      else((i + j) % 2 == 1)\r\n      {fill(105, 105, 105);  \r\n      }\r\n      rect(size * i, size * j, size, size);\r\n    }\r\n  }\r\n}"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "10/21/2025, 11:34:12 AM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// チェッカー\r\nfunction setup() {\r\n  createCanvas(200, 200);\r\n  const size = width / 8; // マスの一辺の長さ\r\n  // noStroke();\r\n  for(let i = 0; i < 8; i++){\r\n    for(let j = 0; j < 8; j++){\r\n      // BLANK[1] ヒント： rectのx座標は size * i, y座標は size * j\r\n      if((i + j) % 2 == 0)\r\n        {fill(255, 255, 255);\r\n        }\r\n      else((i + j) % 2 == 1)\r\n      {fill(105, 105, 105);  \r\n      }\r\n      rect(size * i, size * j, size, size);\r\n    }\r\n  }\r\n}"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "10/21/2025, 11:36:22 AM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// チェッカー\r\nfunction setup() {\r\n  createCanvas(200, 200);\r\n  const size = width / 8; // マスの一辺の長さ\r\n  // noStroke();\r\n  for(let i = 0; i < 8; i++){\r\n    for(let j = 0; j < 8; j++){\r\n      // BLANK[1] ヒント： rectのx座標は size * i, y座標は size * j\r\n      if((i + j) % 2 == 0){\r\n        fill(255, 255, 255);\r\n       }\r\n      else((i + j) % 2 == 1){\r\n        fill(105, 105, 105);  \r\n      }\r\n      rect(size * i, size * j, size, size);\r\n    }\r\n  }\r\n}"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "10/21/2025, 11:36:59 AM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// チェッカー\r\nfunction setup() {\r\n  createCanvas(200, 200);\r\n  const size = width / 8; // マスの一辺の長さ\r\n  // noStroke();\r\n  for(let i = 0; i < 8; i++){\r\n    for(let j = 0; j < 8; j++){\r\n      // BLANK[1] ヒント： rectのx座標は size * i, y座標は size * j\r\n      if((i + j) % 2 == 0){\r\n        fill(255, 255, 255);\r\n       }\r\n      else((i + j) % 2 == 1)\r\n      {fill(105, 105, 105);  \r\n      }\r\n      rect(size * i, size * j, size, size);\r\n    }\r\n  }\r\n}"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "10/21/2025, 11:37:18 AM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// チェッカー\r\nfunction setup() {\r\n  createCanvas(200, 200);\r\n  const size = width / 8; // マスの一辺の長さ\r\n  // noStroke();\r\n  for(let i = 0; i < 8; i++){\r\n    for(let j = 0; j < 8; j++){\r\n      // BLANK[1] ヒント： rectのx座標は size * i, y座標は size * j\r\n      if((i + j) % 2 == 0){\r\n        fill(255, 255, 255);\r\n       }\r\n      else((i + j) % 2 == 1)\r\n      {fill(105, 105, 105);  \r\n      }\r\n      rect(size * i, size * j, size, size);\r\n    }\r\n  }\r\n}"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "10/21/2025, 11:38:13 AM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// チェッカー\r\nfunction setup() {\r\n  createCanvas(200, 200);\r\n  const size = width / 8; // マスの一辺の長さ\r\n  // noStroke();\r\n  for(let i = 0; i < 8; i++){\r\n    for(let j = 0; j < 8; j++){\r\n      // BLANK[1] ヒント： rectのx座標は size * i, y座標は size * j\r\n      if((i + j) % 2 == 0){\r\n        fill(255, 255, 255);\r\n       }\r\n      else()\r\n      {fill(105, 105, 105);  \r\n      }\r\n      rect(size * i, size * j, size, size);\r\n    }\r\n  }\r\n}"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "10/21/2025, 11:38:50 AM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// チェッカー\r\nfunction setup() {\r\n  createCanvas(200, 200);\r\n  const size = width / 8; // マスの一辺の長さ\r\n  // noStroke();\r\n  for(let i = 0; i < 8; i++){\r\n    for(let j = 0; j < 8; j++){\r\n      // BLANK[1] ヒント： rectのx座標は size * i, y座標は size * j\r\n      if((i + j) % 2 == 0){\r\n        fill(255, 255, 255);\r\n       }\r\n      else\r\n      {fill(105, 105, 105);  \r\n      }\r\n      rect(size * i, size * j, size, size);\r\n    }\r\n  }\r\n}"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "10/21/2025, 12:05:21 PM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// チェッカー\r\nfunction setup() {\r\n  createCanvas(200, 200);\r\n  const size = width / 8; // マスの一辺の長さ\r\n  // noStroke();\r\n  for(let i = 0; i < 8; i++){\r\n    for(let j = 0; j < 8; j++){\r\n      // BLANK[1] ヒント： rectのx座標は size * i, y座標は size * j\r\n      if((i + j) % 2 == 0){\r\n        fill(255, 255, 255);\r\n       }\r\n      else\r\n      {fill(105, 105, 105);  \r\n      }\r\n      rect(size * i, size * j, size, size);\r\n\r\n      if((i + j) % 2 == 1 && size * j < 75){\r\n\r\n      }fill(255, 0, 0);\r\n      ellipse(size * i + size / 2, size * j + size / 2, size - 5)\r\n\r\n      if()\r\n    }\r\n  }\r\n}"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "10/21/2025, 12:05:34 PM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// チェッカー\r\nfunction setup() {\r\n  createCanvas(200, 200);\r\n  const size = width / 8; // マスの一辺の長さ\r\n  // noStroke();\r\n  for(let i = 0; i < 8; i++){\r\n    for(let j = 0; j < 8; j++){\r\n      // BLANK[1] ヒント： rectのx座標は size * i, y座標は size * j\r\n      if((i + j) % 2 == 0){\r\n        fill(255, 255, 255);\r\n       }\r\n      else\r\n      {fill(105, 105, 105);  \r\n      }\r\n      rect(size * i, size * j, size, size);\r\n\r\n      if((i + j) % 2 == 1 && size * j < 75){\r\n\r\n      }fill(255, 0, 0);\r\n      ellipse(size * i + size / 2, size * j + size / 2, size - 5);\r\n    }\r\n  }\r\n}"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "10/21/2025, 12:06:34 PM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// チェッカー\r\nfunction setup() {\r\n  createCanvas(200, 200);\r\n  const size = width / 8; // マスの一辺の長さ\r\n  // noStroke();\r\n  for(let i = 0; i < 8; i++){\r\n    for(let j = 0; j < 8; j++){\r\n      // BLANK[1] ヒント： rectのx座標は size * i, y座標は size * j\r\n      if((i + j) % 2 == 0){\r\n        fill(255, 255, 255);\r\n       }\r\n      else\r\n      {fill(105, 105, 105);  \r\n      }\r\n      rect(size * i, size * j, size, size);\r\n\r\n      if((i + j) % 2 == 1 && size * j < 75){\r\n\r\n      fill(255, 0, 0);\r\n      ellipse(size * i + size / 2, size * j + size / 2, size - 5);\r\n    }\r\n  }\r\n}"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "10/21/2025, 12:07:01 PM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// チェッカー\r\nfunction setup() {\r\n  createCanvas(200, 200);\r\n  const size = width / 8; // マスの一辺の長さ\r\n  // noStroke();\r\n  for(let i = 0; i < 8; i++){\r\n    for(let j = 0; j < 8; j++){\r\n      // BLANK[1] ヒント： rectのx座標は size * i, y座標は size * j\r\n      if((i + j) % 2 == 0){\r\n        fill(255, 255, 255);\r\n       }\r\n      else\r\n      {fill(105, 105, 105);  \r\n      }\r\n      rect(size * i, size * j, size, size);\r\n\r\n      if((i + j) % 2 == 1 && size * j < 75){\r\n\r\n      fill(255, 0, 0);\r\n      ellipse(size * i + size / 2, size * j + size / 2, size - 5);\r\n    }\r\n  }\r\n}"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "10/21/2025, 12:07:50 PM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// チェッカー\r\nfunction setup() {\r\n  createCanvas(200, 200);\r\n  const size = width / 8; // マスの一辺の長さ\r\n  // noStroke();\r\n  for(let i = 0; i < 8; i++){\r\n    for(let j = 0; j < 8; j++){\r\n      // BLANK[1] ヒント： rectのx座標は size * i, y座標は size * j\r\n      if((i + j) % 2 == 0){\r\n        fill(255, 255, 255);\r\n       }\r\n      else\r\n      {fill(105, 105, 105);  \r\n      }\r\n      rect(size * i, size * j, size, size);\r\n\r\n      if((i + j) % 2 != 0 && size * j < 75){\r\n\r\n      fill(255, 0, 0);\r\n      ellipse(size * i + size / 2, size * j + size / 2, size - 5);\r\n    }\r\n  }\r\n}"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "10/21/2025, 12:08:57 PM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// チェッカー\r\nfunction setup() {\r\n  createCanvas(200, 200);\r\n  const size = width / 8; // マスの一辺の長さ\r\n  // noStroke();\r\n  for(let i = 0; i < 8; i++){\r\n    for(let j = 0; j < 8; j++){\r\n      // BLANK[1] ヒント： rectのx座標は size * i, y座標は size * j\r\n      if((i + j) % 2 == 0){\r\n        fill(255, 255, 255);\r\n       }\r\n      else\r\n      {fill(105, 105, 105);  \r\n      }\r\n      rect(size * i, size * j, size, size);\r\n\r\n      if((i + j) % 2 != 0 && size * j < 75){\r\n\r\n      fill(255, 0, 0);\r\n      ellipse(size * i + size / 2, size * j + size / 2, size - 5);\r\n    }\r\n  }\r\n}\r\n}"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "10/21/2025, 12:12:19 PM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// チェッカー\r\nfunction setup() {\r\n  createCanvas(200, 200);\r\n  const size = width / 8; // マスの一辺の長さ\r\n  // noStroke();\r\n  for(let i = 0; i < 8; i++){\r\n    for(let j = 0; j < 8; j++){\r\n      // BLANK[1] ヒント： rectのx座標は size * i, y座標は size * j\r\n      if((i + j) % 2 == 0){\r\n        fill(255, 255, 255);\r\n       }\r\n      else\r\n      {fill(105, 105, 105);  \r\n      }\r\n      rect(size * i, size * j, size, size);\r\n\r\n      if((i + j) % 2 != 0 && size * j < 75){\r\n\r\n      fill(255, 0, 0);\r\n      ellipse(size * i + size / 2, size * j + size / 2, size - 5);\r\n\r\n      if((i + j) % 2 != 0 && size * j > 125){\r\n        fill(0, 0, 0);\r\n      ellipse(size * i + size / 2, size * j + size / 2, size - 5);\r\n          }\r\n  }\r\n}\r\n  }}"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "10/21/2025, 12:12:19 PM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// チェッカー\r\nfunction setup() {\r\n  createCanvas(200, 200);\r\n  const size = width / 8; // マスの一辺の長さ\r\n  // noStroke();\r\n  for(let i = 0; i < 8; i++){\r\n    for(let j = 0; j < 8; j++){\r\n      // BLANK[1] ヒント： rectのx座標は size * i, y座標は size * j\r\n      if((i + j) % 2 == 0){\r\n        fill(255, 255, 255);\r\n       }\r\n      else\r\n      {fill(105, 105, 105);  \r\n      }\r\n      rect(size * i, size * j, size, size);\r\n\r\n      if((i + j) % 2 != 0 && size * j < 75){\r\n\r\n      fill(255, 0, 0);\r\n      ellipse(size * i + size / 2, size * j + size / 2, size - 5);\r\n\r\n      if((i + j) % 2 != 0 && size * j > 125){\r\n        fill(0, 0, 0);\r\n      ellipse(size * i + size / 2, size * j + size / 2, size - 5);\r\n          }\r\n  }\r\n}\r\n  }}"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "10/21/2025, 12:12:19 PM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// チェッカー\r\nfunction setup() {\r\n  createCanvas(200, 200);\r\n  const size = width / 8; // マスの一辺の長さ\r\n  // noStroke();\r\n  for(let i = 0; i < 8; i++){\r\n    for(let j = 0; j < 8; j++){\r\n      // BLANK[1] ヒント： rectのx座標は size * i, y座標は size * j\r\n      if((i + j) % 2 == 0){\r\n        fill(255, 255, 255);\r\n       }\r\n      else\r\n      {fill(105, 105, 105);  \r\n      }\r\n      rect(size * i, size * j, size, size);\r\n\r\n      if((i + j) % 2 != 0 && size * j < 75){\r\n\r\n      fill(255, 0, 0);\r\n      ellipse(size * i + size / 2, size * j + size / 2, size - 5);\r\n\r\n      if((i + j) % 2 != 0 && size * j > 125){\r\n        fill(0, 0, 0);\r\n      ellipse(size * i + size / 2, size * j + size / 2, size - 5);\r\n          }\r\n  }\r\n}\r\n  }}"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "10/21/2025, 12:12:19 PM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// チェッカー\r\nfunction setup() {\r\n  createCanvas(200, 200);\r\n  const size = width / 8; // マスの一辺の長さ\r\n  // noStroke();\r\n  for(let i = 0; i < 8; i++){\r\n    for(let j = 0; j < 8; j++){\r\n      // BLANK[1] ヒント： rectのx座標は size * i, y座標は size * j\r\n      if((i + j) % 2 == 0){\r\n        fill(255, 255, 255);\r\n       }\r\n      else\r\n      {fill(105, 105, 105);  \r\n      }\r\n      rect(size * i, size * j, size, size);\r\n\r\n      if((i + j) % 2 != 0 && size * j < 75){\r\n\r\n      fill(255, 0, 0);\r\n      ellipse(size * i + size / 2, size * j + size / 2, size - 5);\r\n\r\n      if((i + j) % 2 != 0 && size * j > 125){\r\n        fill(0, 0, 0);\r\n      ellipse(size * i + size / 2, size * j + size / 2, size - 5);\r\n          }\r\n  }\r\n}\r\n  }}"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "10/21/2025, 12:12:21 PM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// チェッカー\r\nfunction setup() {\r\n  createCanvas(200, 200);\r\n  const size = width / 8; // マスの一辺の長さ\r\n  // noStroke();\r\n  for(let i = 0; i < 8; i++){\r\n    for(let j = 0; j < 8; j++){\r\n      // BLANK[1] ヒント： rectのx座標は size * i, y座標は size * j\r\n      if((i + j) % 2 == 0){\r\n        fill(255, 255, 255);\r\n       }\r\n      else\r\n      {fill(105, 105, 105);  \r\n      }\r\n      rect(size * i, size * j, size, size);\r\n\r\n      if((i + j) % 2 != 0 && size * j < 75){\r\n\r\n      fill(255, 0, 0);\r\n      ellipse(size * i + size / 2, size * j + size / 2, size - 5);\r\n\r\n      if((i + j) % 2 != 0 && size * j > 125){\r\n        fill(0, 0, 0);\r\n      ellipse(size * i + size / 2, size * j + size / 2, size - 5);\r\n          }\r\n  }\r\n}\r\n  }}"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "10/21/2025, 12:12:21 PM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// チェッカー\r\nfunction setup() {\r\n  createCanvas(200, 200);\r\n  const size = width / 8; // マスの一辺の長さ\r\n  // noStroke();\r\n  for(let i = 0; i < 8; i++){\r\n    for(let j = 0; j < 8; j++){\r\n      // BLANK[1] ヒント： rectのx座標は size * i, y座標は size * j\r\n      if((i + j) % 2 == 0){\r\n        fill(255, 255, 255);\r\n       }\r\n      else\r\n      {fill(105, 105, 105);  \r\n      }\r\n      rect(size * i, size * j, size, size);\r\n\r\n      if((i + j) % 2 != 0 && size * j < 75){\r\n\r\n      fill(255, 0, 0);\r\n      ellipse(size * i + size / 2, size * j + size / 2, size - 5);\r\n\r\n      if((i + j) % 2 != 0 && size * j > 125){\r\n        fill(0, 0, 0);\r\n      ellipse(size * i + size / 2, size * j + size / 2, size - 5);\r\n          }\r\n  }\r\n}\r\n  }}"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "10/21/2025, 12:12:22 PM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// チェッカー\r\nfunction setup() {\r\n  createCanvas(200, 200);\r\n  const size = width / 8; // マスの一辺の長さ\r\n  // noStroke();\r\n  for(let i = 0; i < 8; i++){\r\n    for(let j = 0; j < 8; j++){\r\n      // BLANK[1] ヒント： rectのx座標は size * i, y座標は size * j\r\n      if((i + j) % 2 == 0){\r\n        fill(255, 255, 255);\r\n       }\r\n      else\r\n      {fill(105, 105, 105);  \r\n      }\r\n      rect(size * i, size * j, size, size);\r\n\r\n      if((i + j) % 2 != 0 && size * j < 75){\r\n\r\n      fill(255, 0, 0);\r\n      ellipse(size * i + size / 2, size * j + size / 2, size - 5);\r\n\r\n      if((i + j) % 2 != 0 && size * j > 125){\r\n        fill(0, 0, 0);\r\n      ellipse(size * i + size / 2, size * j + size / 2, size - 5);\r\n          }\r\n  }\r\n}\r\n  }}"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "10/21/2025, 12:15:10 PM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// チェッカー\r\nfunction setup() {\r\n  createCanvas(200, 200);\r\n  const size = width / 8; // マスの一辺の長さ\r\n  // noStroke();\r\n  for(let i = 0; i < 8; i++){\r\n    for(let j = 0; j < 8; j++){\r\n      // BLANK[1] ヒント： rectのx座標は size * i, y座標は size * j\r\n      if((i + j) % 2 == 0){\r\n        fill(255, 255, 255);\r\n       }\r\n      else\r\n      {fill(105, 105, 105);  \r\n      }\r\n      rect(size * i, size * j, size, size);\r\n\r\n      if((i + j) % 2 != 0 && size * j < 75){\r\n\r\n      fill(255, 0, 0);\r\n      ellipse(size * i + size / 2, size * j + size / 2, size - 5);\r\n      }\r\n      if((i + j) % 2 != 0 && size * j > 125){\r\n        fill(0, 0, 0);\r\n      ellipse(size * i + size / 2, size * j + size / 2, size - 5);\r\n          }\r\n        \r\n}\r\n  }\r\n}"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "10/21/2025, 12:15:25 PM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// チェッカー\r\nfunction setup() {\r\n  createCanvas(200, 200);\r\n  const size = width / 8; // マスの一辺の長さ\r\n  // noStroke();\r\n  for(let i = 0; i < 8; i++){\r\n    for(let j = 0; j < 8; j++){\r\n      // BLANK[1] ヒント： rectのx座標は size * i, y座標は size * j\r\n      if((i + j) % 2 == 0){\r\n        fill(255, 255, 255);\r\n       }\r\n      else\r\n      {fill(105, 105, 105);  \r\n      }\r\n      rect(size * i, size * j, size, size);\r\n\r\n      if((i + j) % 2 != 0 && size * j < 75){\r\n\r\n      fill(255, 0, 0);\r\n      ellipse(size * i + size / 2, size * j + size / 2, size - 5);\r\n      }\r\n      if((i + j) % 2 != 0 && size * j > 100){\r\n        fill(0, 0, 0);\r\n      ellipse(size * i + size / 2, size * j + size / 2, size - 5);\r\n          }\r\n        \r\n}\r\n  }\r\n}"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "10/21/2025, 12:17:37 PM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// チェッカー\r\nfunction setup() {\r\n  createCanvas(200, 200);\r\n  const size = width / 8; // マスの一辺の長さ\r\n  // noStroke();\r\n  for(let i = 0; i < 8; i++){\r\n    for(let j = 0; j < 8; j++){\r\n      // BLANK[1] ヒント： rectのx座標は size * i, y座標は size * j\r\n      if((i + j) % 2 == 0){\r\n        fill(255, 255, 255);\r\n       }\r\n      else\r\n      {fill(105, 105, 105);  \r\n      }\r\n      rect(size * i, size * j, size, size);\r\n\r\n      if((i + j) % 2 != 0 && size * j < 100){\r\n\r\n      fill(255, 0, 0);\r\n      ellipse(size * i + size / 2, size * j + size / 2, size - 5);\r\n      }\r\n      if((i + j) % 2 != 0 && size * j > 100){\r\n        fill(0, 0, 0);\r\n      ellipse(size * i + size / 2, size * j + size / 2, size - 5);\r\n          }\r\n        \r\n}\r\n  }\r\n}"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "10/21/2025, 12:17:46 PM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// チェッカー\r\nfunction setup() {\r\n  createCanvas(200, 200);\r\n  const size = width / 8; // マスの一辺の長さ\r\n  // noStroke();\r\n  for(let i = 0; i < 8; i++){\r\n    for(let j = 0; j < 8; j++){\r\n      // BLANK[1] ヒント： rectのx座標は size * i, y座標は size * j\r\n      if((i + j) % 2 == 0){\r\n        fill(255, 255, 255);\r\n       }\r\n      else\r\n      {fill(105, 105, 105);  \r\n      }\r\n      rect(size * i, size * j, size, size);\r\n\r\n      if((i + j) % 2 != 0 && size * j < 75){\r\n\r\n      fill(255, 0, 0);\r\n      ellipse(size * i + size / 2, size * j + size / 2, size - 5);\r\n      }\r\n      if((i + j) % 2 != 0 && size * j > 100){\r\n        fill(0, 0, 0);\r\n      ellipse(size * i + size / 2, size * j + size / 2, size - 5);\r\n          }\r\n        \r\n}\r\n  }\r\n}"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "10/21/2025, 12:23:52 PM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// チェッカー\r\nfunction setup() {\r\n  createCanvas(200, 200);\r\n  const size = width / 8; // マスの一辺の長さ\r\n  // noStroke();\r\n  for(let i = 0; i < 8; i++){\r\n    for(let j = 0; j < 8; j++){\r\n      // BLANK[1] ヒント： rectのx座標は size * i, y座標は size * j\r\n      if((i + j) % 2 == 0){\r\n        fill(255, 255, 255);\r\n       }\r\n      else\r\n      {fill(105, 105, 105);  \r\n      }\r\n      rect(size * i, size * j, size, size);\r\n\r\n      if((i + j) % 2 != 0 && size * j < 100){\r\n\r\n      fill(255, 0, 0);\r\n      ellipse(size * i + size / 2, size * j + size / 2, size - 5);\r\n      }\r\n      if((i + j) % 2 != 0 && size * j > 100){\r\n        fill(0, 0, 0);\r\n      ellipse(size * i + size / 2, size * j + size / 2, size - 5);\r\n          }\r\n        \r\n}\r\n  }\r\n}"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "10/21/2025, 12:25:25 PM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// チェッカー\r\nfunction setup() {\r\n  createCanvas(200, 200);\r\n  const size = width / 8; // マスの一辺の長さ\r\n  // noStroke();\r\n  for(let i = 0; i < 8; i++){\r\n    for(let j = 0; j < 8; j++){\r\n      // BLANK[1] ヒント： rectのx座標は size * i, y座標は size * j\r\n      if((i + j) % 2 == 0){\r\n        fill(255, 255, 255);\r\n       }\r\n      else\r\n      {fill(105, 105, 105);  \r\n      }\r\n      rect(size * i, size * j, size, size);\r\n\r\n      if((i + j) % 2 != 0 && size * j < 75){\r\n\r\n      fill(255, 0, 0);\r\n      ellipse(size * i + size / 2, size * j + size / 2, size - 5);\r\n      }\r\n      if((i + j) % 2 != 0 && size * j > 100){\r\n        fill(0, 0, 0);\r\n      ellipse(size * i + size / 2, size * j + size / 2, size - 5);\r\n          }\r\n        \r\n}\r\n  }\r\n}"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "10/21/2025, 12:26:32 PM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// チェッカー\r\nfunction setup() {\r\n  createCanvas(200, 200);\r\n  const size = width / 8; // マスの一辺の長さ\r\n  // noStroke();\r\n  for(let i = 0; i < 8; i++){\r\n    for(let j = 0; j < 8; j++){\r\n      // BLANK[1] ヒント： rectのx座標は size * i, y座標は size * j\r\n      if((i + j) % 2 == 0){\r\n        fill(255, 255, 255);\r\n       }\r\n      else\r\n      {fill(105, 105, 105);  \r\n      }\r\n      rect(size * i, size * j, size, size);\r\n\r\n      if((i + j) % 2 != 0 && size * j < 100){\r\n\r\n      fill(255, 0, 0);\r\n      ellipse(size * i + size / 2, size * j + size / 2, size - 5);\r\n      }\r\n      if((i + j) % 2 != 0 && size * j > 100){\r\n        fill(0, 0, 0);\r\n      ellipse(size * i + size / 2, size * j + size / 2, size - 5);\r\n          }\r\n        \r\n}\r\n  }\r\n}"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "10/21/2025, 12:30:08 PM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// チェッカー\r\nfunction setup() {\r\n  createCanvas(200, 200);\r\n  const size = width / 8; // マスの一辺の長さ\r\n  // noStroke();\r\n  for(let i = 0; i < 8; i++){\r\n    for(let j = 0; j < 8; j++){\r\n      // BLANK[1] ヒント： rectのx座標は size * i, y座標は size * j\r\n      if((i + j) % 2 == 0){\r\n        fill(255, 255, 255);\r\n       }\r\n      else\r\n      {fill(105, 105, 105);  \r\n      }\r\n      rect(size * i, size * j, size, size);\r\n\r\n      if((i + j) % 2 != 0 && size * j < 75){\r\n\r\n      fill(255, 0, 0);\r\n      ellipse(size * i + size / 2, size * j + size / 2, size - 5);\r\n      }\r\n      if((i + j) % 2 != 0 && size * j > 100){\r\n        fill(0, 0, 0);\r\n      ellipse(size * i + size / 2, size * j + size / 2, size - 5);\r\n          }\r\n        \r\n}\r\n  }\r\n}"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "10/21/2025, 12:34:28 PM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// チェッカー\r\nfunction setup() {\r\n  createCanvas(200, 200);\r\n  const size = width / 8; // マスの一辺の長さ\r\n  noStroke();\r\n  for(let i = 0; i < 8; i++){\r\n    for(let j = 0; j < 8; j++){\r\n      // BLANK[1] ヒント： rectのx座標は size * i, y座標は size * j\r\n      if((i + j) % 2 == 0){\r\n        fill(255, 255, 255);\r\n       }\r\n      else\r\n      {fill(105, 105, 105);  \r\n      }\r\n      rect(size * i, size * j, size, size);\r\n\r\n      if((i + j) % 2 != 0 && size * j < 75){\r\n\r\n      fill(255, 0, 0);\r\n      ellipse(size * i + size / 2, size * j + size / 2, size - 5);\r\n      }\r\n      if((i + j) % 2 != 0 && size * j > 100){\r\n        fill(0, 0, 0);\r\n      ellipse(size * i + size / 2, size * j + size / 2, size - 5);\r\n          }\r\n        \r\n}\r\n  }\r\n}"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "10/21/2025, 12:34:34 PM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// チェッカー\r\nfunction setup() {\r\n  createCanvas(200, 200);\r\n  const size = width / 8; // マスの一辺の長さ\r\n   noStroke();\r\n  for(let i = 0; i < 8; i++){\r\n    for(let j = 0; j < 8; j++){\r\n      // BLANK[1] ヒント： rectのx座標は size * i, y座標は size * j\r\n      if((i + j) % 2 == 0){\r\n        fill(255, 255, 255);\r\n       }\r\n      else\r\n      {fill(105, 105, 105);  \r\n      }\r\n      rect(size * i, size * j, size, size);\r\n\r\n      if((i + j) % 2 != 0 && size * j < 75){\r\n\r\n      fill(255, 0, 0);\r\n      ellipse(size * i + size / 2, size * j + size / 2, size - 5);\r\n      }\r\n      if((i + j) % 2 != 0 && size * j > 100){\r\n        fill(0, 0, 0);\r\n      ellipse(size * i + size / 2, size * j + size / 2, size - 5);\r\n          }\r\n        \r\n}\r\n  }\r\n}"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "10/21/2025, 12:34:59 PM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// チェッカー\r\nfunction setup() {\r\n  createCanvas(200, 200);\r\n  const size = width / 8; // マスの一辺の長さ\r\n  noStroke();\r\n  for(let i = 0; i < 8; i++){\r\n    for(let j = 0; j < 8; j++){\r\n      // BLANK[1] ヒント： rectのx座標は size * i, y座標は size * j\r\n      if((i + j) % 2 == 0){\r\n        fill(255, 255, 255);\r\n       }\r\n      else\r\n      {fill(105, 105, 105);  \r\n      }\r\n      rect(size * i, size * j, size, size);\r\n\r\n      if((i + j) % 2 != 0 && size * j < 75){\r\n\r\n      fill(255, 0, 0);\r\n      ellipse(size * i + size / 2, size * j + size / 2, size - 5);\r\n      }\r\n      if((i + j) % 2 != 0 && size * j > 100){\r\n        fill(0, 0, 0);\r\n      ellipse(size * i + size / 2, size * j + size / 2, size - 5);\r\n          }\r\n        \r\n}\r\n  }\r\n}"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "10/21/2025, 12:35:02 PM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// チェッカー\r\nfunction setup() {\r\n  createCanvas(200, 200);\r\n  const size = width / 8; // マスの一辺の長さ\r\nnoStroke();\r\n  for(let i = 0; i < 8; i++){\r\n    for(let j = 0; j < 8; j++){\r\n      // BLANK[1] ヒント： rectのx座標は size * i, y座標は size * j\r\n      if((i + j) % 2 == 0){\r\n        fill(255, 255, 255);\r\n       }\r\n      else\r\n      {fill(105, 105, 105);  \r\n      }\r\n      rect(size * i, size * j, size, size);\r\n\r\n      if((i + j) % 2 != 0 && size * j < 75){\r\n\r\n      fill(255, 0, 0);\r\n      ellipse(size * i + size / 2, size * j + size / 2, size - 5);\r\n      }\r\n      if((i + j) % 2 != 0 && size * j > 100){\r\n        fill(0, 0, 0);\r\n      ellipse(size * i + size / 2, size * j + size / 2, size - 5);\r\n          }\r\n        \r\n}\r\n  }\r\n}"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "10/21/2025, 12:35:42 PM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// チェッカー\r\nfunction setup() {\r\n  createCanvas(200, 200);\r\n  const size = width / 8; // マスの一辺の長さ\r\n  noStroke();\r\n  for(let i = 0; i < 8; i++){\r\n    for(let j = 0; j < 8; j++){\r\n      // BLANK[1] ヒント： rectのx座標は size * i, y座標は size * j\r\n      if((i + j) % 2 == 0){\r\n        fill(255, 255, 255);\r\n       }\r\n      else\r\n      {fill(105, 105, 105);  \r\n      }\r\n      rect(size * i, size * j, size, size);\r\n\r\n      if((i + j) % 2 != 0 && size * j < 75){\r\n\r\n      fill(255, 0, 0);\r\n      ellipse(size * i + size / 2, size * j + size / 2, size - 5);\r\n      }\r\n      if((i + j) % 2 != 0 && size * j > 100){\r\n        fill(0, 0, 0);\r\n      ellipse(size * i + size / 2, size * j + size / 2, size - 5);\r\n          }\r\n        \r\n}\r\n  }\r\n}"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "10/21/2025, 12:36:21 PM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// チェッカー\r\nfunction setup() {\r\n  createCanvas(200, 200);\r\n  const size = width / 8; // マスの一辺の長さ\r\n  noStroke();\r\n  for(let i = 0; i < 8; i++){\r\n    for(let j = 0; j < 8; j++){\r\n      // BLANK[1] ヒント： rectのx座標は size * i, y座標は size * j\r\n      if((i + j) % 2 == 0){\r\n        fill(255, 255, 255);\r\n       }\r\n      else\r\n      {fill(105, 105, 105);  \r\n      }\r\n      rect(size * i, size * j, size, size);\r\n\r\n      if((i + j) % 2 != 0 && size * j < 75){\r\n\r\n      fill(255, 0, 0);\r\n      ellipse(size * i + size / 2, size * j + size / 2, size - 5);\r\n      }\r\n      if((i + j) % 2 != 0 && size * j > 100){\r\n        fill(0, 0, 0);\r\n      ellipse(size * i + size / 2, size * j + size / 2, size - 5);\r\n          }\r\n        \r\n}\r\n  }\r\n}"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "10/28/2025, 2:37:27 AM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// ギリシャ国旗（ほかの国旗に挑戦してもOK）\r\nfunction setup() {\r\n  createCanvas(270, 180);\r\n  noStroke();\r\n  background(255);\r\n\r\n  const d = height / 9; // 縞1本の太さ\r\n  const blue = color(0, 51, 160);\r\n\r\n  // 縞を描く\r\n  for(let i = 0; i < 9; i++){\r\n    // BLANK[1] ヒント：縞の色を交互に変えるには2で割った余りを使おう\r\n    rect(0, i * d, width, (i + 1) * d);\r\n  }\r\n\r\n  // 十字を描く\r\n  const size = d * 5;\r\n  fill(blue);\r\n  rect(0, 0, size, size);\r\n  fill(255);\r\n  rect(d * 2, 0, d, size);\r\n  // BLANK[2] 十字を完成させよう\r\n}"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "10/28/2025, 2:42:50 AM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// ギリシャ国旗（ほかの国旗に挑戦してもOK）\r\nfunction setup() {\r\n  createCanvas(270, 180);\r\n  noStroke();\r\n  background(255);\r\n\r\n  const d = height / 9; // 縞1本の太さ\r\n  const blue = color(0, 51, 160);\r\n\r\n  // 縞を描く\r\n  for(let i = 0; i < 9; i++){\r\n    // BLANK[1] ヒント：縞の色を交互に変えるには2で割った余りを使おう\r\n    rect(0, i * d, width, (i + 1) * d);\r\n  }\r\n\r\n  // 十字を描く\r\n  const size = d * 5;\r\n  fill(blue);\r\n  rect(0, 0, size, size);\r\n  \r\n  rect(d * 2, 0, d, size);\r\n  // BLANK[2] 十字を完成させよう\r\n\r\n}"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "10/28/2025, 2:42:54 AM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// ギリシャ国旗（ほかの国旗に挑戦してもOK）\r\nfunction setup() {\r\n  createCanvas(270, 180);\r\n  noStroke();\r\n  background(255);\r\n\r\n  const d = height / 9; // 縞1本の太さ\r\n  const blue = color(0, 51, 160);\r\n\r\n  // 縞を描く\r\n  for(let i = 0; i < 9; i++){\r\n    // BLANK[1] ヒント：縞の色を交互に変えるには2で割った余りを使おう\r\n    rect(0, i * d, width, (i + 1) * d);\r\n  }\r\n\r\n  // 十字を描く\r\n  const size = d * 5;\r\n  fill(blue);\r\n  rect(0, 0, size, size);\r\n  fill(255);\r\n  rect(d * 2, 0, d, size);\r\n  // BLANK[2] 十字を完成させよう\r\n\r\n}"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "10/28/2025, 2:43:13 AM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// ギリシャ国旗（ほかの国旗に挑戦してもOK）\r\nfunction setup() {\r\n  createCanvas(270, 180);\r\n  noStroke();\r\n  background(255);\r\n\r\n  const d = height / 9; // 縞1本の太さ\r\n  const blue = color(0, 51, 160);\r\n\r\n  // 縞を描く\r\n  for(let i = 0; i < 9; i++){\r\n    // BLANK[1] ヒント：縞の色を交互に変えるには2で割った余りを使おう\r\n    rect(0, i * d, width, (i + 1) * d);\r\n  }\r\n\r\n  // 十字を描く\r\n  const size = d * 5;\r\n  fill(blue);\r\n  rect(0, 0, size, size);\r\n  fill(255);\r\n  rect(d * 2, 0, d, size);\r\n  fill(255)\r\n  // BLANK[2] 十字を完成させよう\r\n\r\n}"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "10/28/2025, 2:43:20 AM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// ギリシャ国旗（ほかの国旗に挑戦してもOK）\r\nfunction setup() {\r\n  createCanvas(270, 180);\r\n  noStroke();\r\n  background(255);\r\n\r\n  const d = height / 9; // 縞1本の太さ\r\n  const blue = color(0, 51, 160);\r\n\r\n  // 縞を描く\r\n  for(let i = 0; i < 9; i++){\r\n    // BLANK[1] ヒント：縞の色を交互に変えるには2で割った余りを使おう\r\n    rect(0, i * d, width, (i + 1) * d);\r\n  }\r\n\r\n  // 十字を描く\r\n  const size = d * 5;\r\n  fill(blue);\r\n  rect(0, 0, size, size);\r\n  fill(255);\r\n  rect(d * 2, 0, d, size);\r\n  fill(255);\r\n  // BLANK[2] 十字を完成させよう\r\n\r\n}"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "10/28/2025, 10:45:39 AM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// ギリシャ国旗（ほかの国旗に挑戦してもOK）\r\nfunction setup() {\r\n  createCanvas(270, 180);\r\n  noStroke();\r\n  background(255);\r\n\r\n  const d = height / 9; // 縞1本の太さ\r\n  const blue = color(0, 51, 160);\r\n\r\n  // 縞を描く\r\n  for(let i = 0; i < 9; i++){\r\n    // BLANK[1] ヒント：縞の色を交互に変えるには2で割った余りを使おう\r\n    rect(0, i * d, width, (i + 1) * d);\r\n  }\r\n\r\n  // 十字を描く\r\n  const size = d * 5;\r\n  fill(blue);\r\n  rect(0, 0, size, size); //十字の青背景\r\n  fill(255);\r\n  rect(d * 2, 0, d, size); //十字の縦線\r\n  rect(0, d * 2, size, d);\r\n  // BLANK[2] 十字を完成させよう\r\n\r\n}"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "10/28/2025, 10:45:44 AM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// ギリシャ国旗（ほかの国旗に挑戦してもOK）\r\nfunction setup() {\r\n  createCanvas(270, 180);\r\n  noStroke();\r\n  background(255);\r\n\r\n  const d = height / 9; // 縞1本の太さ\r\n  const blue = color(0, 51, 160);\r\n\r\n  // 縞を描く\r\n  for(let i = 0; i < 9; i++){\r\n    // BLANK[1] ヒント：縞の色を交互に変えるには2で割った余りを使おう\r\n    rect(0, i * d, width, (i + 1) * d);\r\n  }\r\n\r\n  // 十字を描く\r\n  const size = d * 5;\r\n  fill(blue);\r\n  rect(0, 0, size, size); //十字の青背景\r\n  fill(255);\r\n  rect(d * 2, 0, d, size); //十字の縦線\r\n  rect(0, d * 2, size, d);\r\n  // BLANK[2] 十字を完成させよう\r\n\r\n}"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "10/28/2025, 10:45:58 AM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// ギリシャ国旗（ほかの国旗に挑戦してもOK）\r\nfunction setup() {\r\n  createCanvas(270, 180);\r\n  noStroke();\r\n  background(255);\r\n\r\n  const d = height / 9; // 縞1本の太さ\r\n  const blue = color(0, 51, 160);\r\n\r\n  // 縞を描く\r\n  for(let i = 0; i < 9; i++){\r\n    // BLANK[1] ヒント：縞の色を交互に変えるには2で割った余りを使おう\r\n    rect(0, i * d, width, (i + 1) * d);\r\n  }\r\n\r\n  // 十字を描く\r\n  const size = d * 5;\r\n  fill(blue);\r\n  rect(0, 0, size, size); //十字の青背景\r\n  fill(255);\r\n  rect(d * 2, 0, d, size); //十字の縦線\r\n  fill(255)\r\n  rect(0, d * 2, size, d);\r\n  // BLANK[2] 十字を完成させよう\r\n\r\n}"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "10/28/2025, 10:46:01 AM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// ギリシャ国旗（ほかの国旗に挑戦してもOK）\r\nfunction setup() {\r\n  createCanvas(270, 180);\r\n  noStroke();\r\n  background(255);\r\n\r\n  const d = height / 9; // 縞1本の太さ\r\n  const blue = color(0, 51, 160);\r\n\r\n  // 縞を描く\r\n  for(let i = 0; i < 9; i++){\r\n    // BLANK[1] ヒント：縞の色を交互に変えるには2で割った余りを使おう\r\n    rect(0, i * d, width, (i + 1) * d);\r\n  }\r\n\r\n  // 十字を描く\r\n  const size = d * 5;\r\n  fill(blue);\r\n  rect(0, 0, size, size); //十字の青背景\r\n  fill(255);\r\n  rect(d * 2, 0, d, size); //十字の縦線\r\n  fill(255);\r\n  rect(0, d * 2, size, d);\r\n  // BLANK[2] 十字を完成させよう\r\n\r\n}"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "10/28/2025, 10:54:36 AM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// ギリシャ国旗（ほかの国旗に挑戦してもOK）\r\nfunction setup() {\r\n  createCanvas(270, 180);\r\n  noStroke();\r\n  background(255);\r\n\r\n  const d = height / 9; // 縞1本の太さ\r\n  const blue = color(0, 51, 160);\r\n\r\n  // 縞を描く\r\n  for(let i = 0; i < 9; i++){\r\n    // BLANK[1] ヒント：縞の色を交互に変えるには2で割った余りを使おう\r\n    rect(0, i * d, width, (i + 1) * d);\r\n  }\r\n\r\n  // 十字を描く\r\n\r\n  // BLANK[2] 十字を完成させよう\r\n\r\n}"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "10/28/2025, 10:54:43 AM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// ギリシャ国旗（ほかの国旗に挑戦してもOK）\r\nfunction setup() {\r\n  createCanvas(270, 180);\r\n  noStroke();\r\n  background(255);\r\n\r\n  const d = height / 9; // 縞1本の太さ\r\n  const blue = color(0, 51, 160);\r\n\r\n  // 縞を描く\r\n  for(let i = 0; i < 9; i++){\r\n    // BLANK[1] ヒント：縞の色を交互に変えるには2で割った余りを使おう\r\n    rect(0, i * d, width, (i + 1) * d);\r\n  }\r\n\r\n  // 十字を描く\r\n  const size = d * 5;\r\n  fill(blue);\r\n  rect(0, 0, size, size); //十字の青背景\r\n  fill(255);\r\n  rect(d * 2, 0, d, size);\r\n  // BLANK[2] 十字を完成させよう\r\n\r\n}"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "10/28/2025, 10:55:47 AM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// ギリシャ国旗（ほかの国旗に挑戦してもOK）\r\nfunction setup() {\r\n  createCanvas(270, 180);\r\n  noStroke();\r\n  background(255);\r\n\r\n  const d = height / 9; // 縞1本の太さ\r\n  const blue = color(0, 51, 160);\r\n\r\n  // 縞を描く\r\n  for(let i = 0; i < 9; i++){\r\n    // BLANK[1] ヒント：縞の色を交互に変えるには2で割った余りを使おう\r\n    rect(0, i * d, width, (i + 1) * d);\r\n  }\r\n\r\n  // 十字を描く\r\n  const size = d * 5;\r\n  fill(blue);\r\n  rect(0, 0, size, size);\r\n\r\n  // BLANK[2] 十字を完成させよう\r\n\r\n}"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "10/28/2025, 10:56:08 AM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// ギリシャ国旗（ほかの国旗に挑戦してもOK）\r\nfunction setup() {\r\n  createCanvas(270, 180);\r\n  noStroke();\r\n  background(255);\r\n\r\n  const d = height / 9; // 縞1本の太さ\r\n  const blue = color(0, 51, 160);\r\n\r\n  // 縞を描く\r\n  for(let i = 0; i < 9; i++){\r\n    // BLANK[1] ヒント：縞の色を交互に変えるには2で割った余りを使おう\r\n    rect(0, i * d, width, (i + 1) * d);\r\n  }\r\n\r\n  // 十字を描く\r\n  const size = d * 5;\r\n  fill(blue);\r\n  rect(0, 0, size, size);\r\n  fill(255);\r\n  rect(d * 2, 0, d, size);\r\n  // BLANK[2] 十字を完成させよう\r\n\r\n}"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "10/28/2025, 10:56:43 AM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// ギリシャ国旗（ほかの国旗に挑戦してもOK）\r\nfunction setup() {\r\n  createCanvas(270, 180);\r\n  noStroke();\r\n  background(255);\r\n\r\n  const d = height / 9; // 縞1本の太さ\r\n  const blue = color(0, 51, 160);\r\n\r\n  // 縞を描く\r\n  for(let i = 0; i < 9; i++){\r\n    // BLANK[1] ヒント：縞の色を交互に変えるには2で割った余りを使おう\r\n    rect(0, i * d, width, (i + 1) * d);\r\n  }\r\n\r\n  // 十字を描く\r\n\r\n  // BLANK[2] 十字を完成させよう\r\n\r\n}"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "10/28/2025, 10:56:46 AM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// ギリシャ国旗（ほかの国旗に挑戦してもOK）\r\nfunction setup() {\r\n  createCanvas(270, 180);\r\n  noStroke();\r\n  background(255);\r\n\r\n  const d = height / 9; // 縞1本の太さ\r\n  const blue = color(0, 51, 160);\r\n\r\n  // 縞を描く\r\n  for(let i = 0; i < 9; i++){\r\n    // BLANK[1] ヒント：縞の色を交互に変えるには2で割った余りを使おう\r\n    rect(0, i * d, width, (i + 1) * d);\r\n  }\r\n\r\n  // 十字を描く\r\n  const size = d * 5;\r\n  fill(blue);\r\n  rect(0, 0, size, size);\r\n  fill(255);\r\n  rect(d * 2, 0, d, size);\r\n  // BLANK[2] 十字を完成させよう\r\n\r\n}"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "10/28/2025, 10:59:32 AM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// ギリシャ国旗（ほかの国旗に挑戦してもOK）\r\nfunction setup() {\r\n  createCanvas(270, 180);\r\n  noStroke();\r\n  background(255);\r\n\r\n  const d = height / 9; // 縞1本の太さ\r\n  const blue = color(0, 51, 160);\r\n\r\n  // 縞を描く\r\n  for(let i = 0; i < 9; i++){\r\n    // BLANK[1] ヒント：縞の色を交互に変えるには2で割った余りを使おう\r\n    rect(0, i * d, width, (i + 1) * d);\r\n  }\r\n\r\n  // 十字を描く\r\n  const size = d * 5;\r\n  fill(blue);\r\n  rect(0, 0, size, size * 4 / 5);\r\n  fill(255);\r\n  rect(d * 2, 0, d, size);\r\n  rect()\r\n  // BLANK[2] 十字を完成させよう\r\n\r\n}"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "10/28/2025, 11:01:27 AM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// ギリシャ国旗（ほかの国旗に挑戦してもOK）\r\nfunction setup() {\r\n  createCanvas(270, 180);\r\n  noStroke();\r\n  background(255);\r\n\r\n  const d = height / 9; // 縞1本の太さ\r\n  const blue = color(0, 51, 160);\r\n\r\n  // 縞を描く\r\n  for(let i = 0; i < 9; i++){\r\n    // BLANK[1] ヒント：縞の色を交互に変えるには2で割った余りを使おう\r\n    rect(0, i * d, width, (i + 1) * d);\r\n  }\r\n\r\n  // 十字を描く\r\n  const size = d * 5;\r\n  fill(blue);\r\n  rect(0, 0, size, size * 4 / 5);\r\n  fill(255);\r\n  rect(d * 2, 0, d, size);\r\n  rect(0, d * 1.5, size, d)\r\n  // BLANK[2] 十字を完成させよう\r\n\r\n}"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "10/28/2025, 11:12:01 AM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// ギリシャ国旗（ほかの国旗に挑戦してもOK）\r\nfunction setup() {\r\n  createCanvas(270, 180);\r\n  noStroke();\r\n  background(255);\r\n\r\n  const d = height / 9; // 縞1本の太さ\r\n  const blue = color(0, 51, 160);\r\n\r\n  // 縞を描く\r\n  for(let i = 0; i < 9; i++){\r\n    // BLANK[1] ヒント：縞の色を交互に変えるには2で割った余りを使おう\r\n    if ((i + 1) % 2 == 0);\r\n  \r\n    rect(0, i * d, width, (i + 1) * d);\r\n  }\r\n\r\n  // 十字を描く\r\n  const size = d * 5;\r\n  fill(blue);\r\n  rect(0, 0, size, size * 4 / 5);\r\n  fill(255);\r\n  rect(d * 2, 0, d, size);\r\n  rect(0, d * 1.5, size, d)\r\n  // BLANK[2] 十字を完成させよう\r\n\r\n}"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "10/28/2025, 11:14:06 AM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// ギリシャ国旗（ほかの国旗に挑戦してもOK）\r\nfunction setup() {\r\n  createCanvas(270, 180);\r\n  noStroke();\r\n  background(255);\r\n\r\n  const d = height / 9; // 縞1本の太さ\r\n  const blue = color(0, 51, 160);\r\n\r\n  // 縞を描く\r\n  for(let i = 0; i < 9; i++){\r\n    // BLANK[1] ヒント：縞の色を交互に変えるには2で割った余りを使おう\r\n    if ((i + 1) % 2 == 0);{\r\n        fill(255, 255, 255);\r\n      }\r\n    else {\r\n      fill(blue)\r\n  \r\n    rect(0, i * d, width, (i + 1) * d);\r\n  }\r\n\r\n  // 十字を描く\r\n  const size = d * 5;\r\n  fill(blue);\r\n  rect(0, 0, size, size * 4 / 5);\r\n  fill(255);\r\n  rect(d * 2, 0, d, size);\r\n  rect(0, d * 1.5, size, d)\r\n  // BLANK[2] 十字を完成させよう\r\n\r\n}"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "10/28/2025, 11:24:09 AM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// ギリシャ国旗（ほかの国旗に挑戦してもOK）\r\nfunction setup() {\r\n  createCanvas(270, 180);\r\n  noStroke();\r\n  background(255);\r\n\r\n  const d = height / 9; // 縞1本の太さ\r\n  const blue = color(0, 51, 160);\r\n\r\n  // 縞を描く\r\n  for(let i = 0; i < 9; i++){\r\n    // BLANK[1] ヒント：縞の色を交互に変えるには2で割った余りを使おう\r\n    if (i % 2 == 0);{\r\n        fill(blue)\r\n  \r\n    rect(0, i * d, width, (i + 1) * d);\r\n  }\r\n\r\n  // 十字を描く\r\n  const size = d * 5;\r\n  fill(blue);\r\n  rect(0, 0, size, size * 4 / 5);\r\n  fill(255);\r\n  rect(d * 2, 0, d, size);\r\n  rect(0, d * 1.5, size, d)\r\n  // BLANK[2] 十字を完成させよう\r\n\r\n}"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "10/28/2025, 11:25:03 AM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// ギリシャ国旗（ほかの国旗に挑戦してもOK）\r\nfunction setup() {\r\n  createCanvas(270, 180);\r\n  noStroke();\r\n  background(255);\r\n\r\n  const d = height / 9; // 縞1本の太さ\r\n  const blue = color(0, 51, 160);\r\n\r\n  // 縞を描く\r\n  for(let i = 0; i < 9; i++){\r\n    // BLANK[1] ヒント：縞の色を交互に変えるには2で割った余りを使おう\r\n    if (i % 2 == 0);{\r\n        fill(blue)\r\n    }\r\n    rect(0, i * d, width, (i + 1) * d);\r\n  }\r\n\r\n  // 十字を描く\r\n  const size = d * 5;\r\n  fill(blue);\r\n  rect(0, 0, size, size * 4 / 5);\r\n  fill(255);\r\n  rect(d * 2, 0, d, size);\r\n  rect(0, d * 1.5, size, d)\r\n  // BLANK[2] 十字を完成させよう\r\n\r\n}"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "10/28/2025, 11:26:25 AM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// ギリシャ国旗（ほかの国旗に挑戦してもOK）\r\nfunction setup() {\r\n  createCanvas(270, 180);\r\n  noStroke();\r\n  background(255);\r\n\r\n  const d = height / 9; // 縞1本の太さ\r\n  const blue = color(0, 51, 160);\r\n\r\n  // 縞を描く\r\n  for(let i = 0; i < 9; i++){\r\n    // BLANK[1] ヒント：縞の色を交互に変えるには2で割った余りを使おう\r\n    if (i % 2 == 0);{\r\n        fill(blue)\r\n    }\r\n    rect(0, i * d, width, (i + 1) * d);\r\n  \r\n\r\n  // 十字を描く\r\n  const size = d * 5;\r\n  fill(blue);\r\n  rect(0, 0, size, size * 4 / 5);\r\n  fill(255);\r\n  rect(d * 2, 0, d, size);\r\n  rect(0, d * 1.5, size, d)\r\n  // BLANK[2] 十字を完成させよう\r\n  }\r\n}"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "10/28/2025, 11:26:55 AM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// ギリシャ国旗（ほかの国旗に挑戦してもOK）\r\nfunction setup() {\r\n  createCanvas(270, 180);\r\n  noStroke();\r\n  background(255);\r\n\r\n  const d = height / 9; // 縞1本の太さ\r\n  const blue = color(0, 51, 160);\r\n\r\n  // 縞を描く\r\n  for(let i = 0; i < 9; i++){\r\n    // BLANK[1] ヒント：縞の色を交互に変えるには2で割った余りを使おう\r\n    if (i % 2 == 0){\r\n        fill(blue)\r\n    }\r\n    rect(0, i * d, width, (i + 1) * d);\r\n  \r\n\r\n  // 十字を描く\r\n  const size = d * 5;\r\n  fill(blue);\r\n  rect(0, 0, size, size * 4 / 5);\r\n  fill(255);\r\n  rect(d * 2, 0, d, size);\r\n  rect(0, d * 1.5, size, d)\r\n  // BLANK[2] 十字を完成させよう\r\n  }\r\n}"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "10/28/2025, 11:28:33 AM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// ギリシャ国旗（ほかの国旗に挑戦してもOK）\r\nfunction setup() {\r\n  createCanvas(270, 180);\r\n  noStroke();\r\n  background(255);\r\n\r\n  const d = height / 9; // 縞1本の太さ\r\n  const blue = color(0, 51, 160);\r\n\r\n  // 縞を描く\r\n  for(let i = 0; i < 9; i++){\r\n    // BLANK[1] ヒント：縞の色を交互に変えるには2で割った余りを使おう\r\n    if (i % 2 == 0){\r\n        fill(blue)\r\n    }\r\n    rect(0, i * d, width, (i + 1) * d);\r\n  \r\n\r\n  // 十字を描く\r\n  const size = d * 5;\r\n  fill(blue);\r\n  rect(0, 0, size, size);\r\n  fill(255);\r\n  rect(d * 2, 0, d, size);\r\n  rect(0, d, size, d)\r\n  // BLANK[2] 十字を完成させよう\r\n  }\r\n}"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "10/28/2025, 11:28:47 AM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// ギリシャ国旗（ほかの国旗に挑戦してもOK）\r\nfunction setup() {\r\n  createCanvas(270, 180);\r\n  noStroke();\r\n  background(255);\r\n\r\n  const d = height / 9; // 縞1本の太さ\r\n  const blue = color(0, 51, 160);\r\n\r\n  // 縞を描く\r\n  for(let i = 0; i < 9; i++){\r\n    // BLANK[1] ヒント：縞の色を交互に変えるには2で割った余りを使おう\r\n    if (i % 2 == 0){\r\n        fill(blue)\r\n    }\r\n    rect(0, i * d, width, (i + 1) * d);\r\n  \r\n\r\n  // 十字を描く\r\n  const size = d * 5;\r\n  fill(blue);\r\n  rect(0, 0, size, size);\r\n  fill(255);\r\n  rect(d * 2, 0, d, size);\r\n  rect(0, d * 2, size, d)\r\n  // BLANK[2] 十字を完成させよう\r\n  }\r\n}"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "10/28/2025, 11:48:01 AM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// 心臓の鼓動のようなアニメーション\r\nconst cycle = 100; // 1周期のフレーム数\r\nlet count; // 何フレーム目か\r\n\r\nfunction setup(){\r\n  createCanvas(200, 200);\r\n  count = 0;\r\n}\r\n\r\nfunction draw(){\r\n  background(160, 192, 255);\r\n  \r\n  let speed = 1; // アニメーションの速さ\r\n  // BLANK[2]\r\n  count = (count + speed) % cycle;\r\n\r\n  let size = 50;\r\n  // BLANK[1] 1周期の前半は size が大きくなり、後半は小さくなる\r\n  ellipse(width / 2, height / 2, size);\r\n}\r\n"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "11/11/2025, 12:05:54 AM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// 心臓の鼓動のようなアニメーション\r\nconst cycle = 100; // 1周期のフレーム数\r\nlet count; // 何フレーム目か\r\n\r\nfunction setup(){\r\n  createCanvas(200, 200);\r\n  count = 0;\r\n}\r\n\r\nfunction draw(){\r\n  background(160, 192, 255);\r\n  \r\n  let speed = 1; // アニメーションの速さ\r\n  // BLANK[2]\r\n  count = (count + speed) % cycle;\r\n\r\n  let size = 50;\r\n  // BLANK[1] 1周期の前半は size が大きくなり、後半は小さくなる\r\n  ellipse(width / 2, height / 2, size);\r\n}\r\n"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "11/11/2025, 12:22:48 AM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "function setup(){\r\n  createCanvas(windowWidth, windowHeight); // キャンバスの大きさをウィンドウの大きさと同じにする\r\n}\r\n\r\nfunction windowResized(){ // ウィンドウがリサイズされるたびに呼び出される関数\r\n  resizeCanvas(windowWidth, windowHeight); // キャンバスをリサイズする（createCanvasではないので注意）\r\n}\r\n\r\nfunction draw(){\r\n  background(160, 192, 255);\r\n}\r\n\r\n// 心臓の鼓動のようなアニメーション\r\nconst cycle = 100; // 1周期のフレーム数\r\nlet count; // 何フレーム目か\r\n\r\nfunction setup(){\r\n  createCanvas(200, 200);\r\n  count = 0;\r\n}\r\n\r\nfunction draw(){\r\n  background(160, 192, 255);\r\n  \r\n  let speed = 1; // アニメーションの速さ\r\n  // BLANK[2]\r\n  count = (count + speed) % cycle;\r\n\r\n  let size = 50;\r\n  // BLANK[1] 1周期の前半は size が大きくなり、後半は小さくなる\r\n  ellipse(width / 2, height / 2, size);\r\n}\r\n"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "11/11/2025, 12:25:09 AM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "function setup(){\r\n  createCanvas(windowWidth, windowHeight); // キャンバスの大きさをウィンドウの大きさと同じにする\r\n}\r\n\r\n\r\n\r\n// 心臓の鼓動のようなアニメーション\r\nconst cycle = 100; // 1周期のフレーム数\r\nlet count; // 何フレーム目か\r\n\r\nfunction setup(){\r\n  createCanvas(200, 200);\r\n  count = 0;\r\n}\r\n\r\nfunction draw(){\r\n  background(160, 192, 255);\r\n  \r\n  let speed = 1; // アニメーションの速さ\r\n  // BLANK[2]\r\n  count = (count + speed) % cycle;\r\n\r\n  let size = 50;\r\n  // BLANK[1] 1周期の前半は size が大きくなり、後半は小さくなる\r\n  ellipse(width / 2, height / 2, size);\r\n}\r\n"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "11/11/2025, 12:25:26 AM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "function setup(){\r\n  createCanvas(windowWidth, windowHeight); // キャンバスの大きさをウィンドウの大きさと同じにする\r\n}\r\n\r\nfunction windowResized(){ // ウィンドウがリサイズされるたびに呼び出される関数\r\n  resizeCanvas(windowWidth, windowHeight); // キャンバスをリサイズする（createCanvasではないので注意）\r\n}\r\n\r\nfunction draw(){\r\n  background(160, 192, 255);\r\n}\r\n\r\n// 心臓の鼓動のようなアニメーション\r\nconst cycle = 100; // 1周期のフレーム数\r\nlet count; // 何フレーム目か\r\n\r\nfunction setup(){\r\n  createCanvas(200, 200);\r\n  count = 0;\r\n}\r\n\r\nfunction draw(){\r\n  background(160, 192, 255);\r\n  \r\n  let speed = 1; // アニメーションの速さ\r\n  // BLANK[2]\r\n  count = (count + speed) % cycle;\r\n\r\n  let size = 50;\r\n  // BLANK[1] 1周期の前半は size が大きくなり、後半は小さくなる\r\n  ellipse(width / 2, height / 2, size);\r\n}\r\n"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "11/11/2025, 2:25:32 AM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "function setup(){\r\n  createCanvas(windowWidth, windowHeight); // キャンバスの大きさをウィンドウの大きさと同じにする\r\n}\r\n\r\nfunction windowResized(){ // ウィンドウがリサイズされるたびに呼び出される関数\r\n  resizeCanvas(windowWidth, windowHeight); // キャンバスをリサイズする（createCanvasではないので注意）\r\n}\r\n\r\nfunction draw(){\r\n  background(160, 192, 255); //前回の描画を消し、アニメーションに見せるためにこの位置に書き、上塗りする。\r\n  ellipse(width / 2, height / 2, size, size); // BLANK[1] 1周期の前半は size が大きくなり、後半は小さくなる\r\n}\r\n\r\n\r\n// 心臓の鼓動のようなアニメーション\r\nconst cycle = 100; // 1周期のフレーム数\r\nlet count; // 何フレーム目か\r\n\r\nfunction setup(){\r\n  createCanvas(200, 200);\r\n  count = 0;\r\n}\r\n\r\nfunction draw(){\r\n  background(160, 192, 255);\r\n  \r\n  let speed = 1; // アニメーションの速さ\r\n  // BLANK[2]\r\n  count = (count + speed) % cycle;\r\n\r\n  let size = 50;\r\n}"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "11/11/2025, 2:31:30 AM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// 心臓の鼓動のようなアニメーション\r\nconst cycle = 100; // 1周期のフレーム数（定数）\r\nlet count = 0; // 現在のフレーム数（変数）\r\nlet size = 50;\r\n\r\nfunction setup(){\r\n  createCanvas(windowWidth, windowHeight); // キャンバスの大きさをウィンドウの大きさと同じにする\r\n}\r\n\r\nfunction windowResized(){ // ウィンドウがリサイズされるたびに呼び出される関数\r\n  resizeCanvas(windowWidth, windowHeight); // キャンバスをリサイズする（createCanvasではないので注意）\r\n}\r\n\r\nfunction draw(){\r\n  background(160, 192, 255); //前回の描画を消し、アニメーションに見せるためにこの位置に書き、上塗りする。\r\n  count = (count + 1) % cycle; // BLANK[2] let speed = 1; // アニメーションの速さ count = (count + speed) % cycle;とすることも可\r\n  if (count < cycle / 2) {\r\n    size += 1;\r\n  } else {\r\n    size -= 1;\r\n  }\r\n  ellipse(width / 2, height / 2, size, size); // BLANK[1] 1周期の前半は size が大きくなり、後半は小さくなる\r\n}\r\n\r\n\r\nfunction setup(){\r\n  createCanvas(200, 200);\r\n  count = 0;\r\n}\r\n\r\nfunction draw(){\r\n  background(160, 192, 255);\r\n  \r\n}"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "11/11/2025, 2:31:50 AM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// 心臓の鼓動のようなアニメーション\r\nconst cycle = 100; // 1周期のフレーム数（定数）\r\nlet count = 0; // 現在のフレーム数（変数）\r\nlet size = 50;\r\n\r\nfunction setup(){\r\n  createCanvas(windowWidth, windowHeight); // キャンバスの大きさをウィンドウの大きさと同じにする\r\n}\r\n\r\nfunction windowResized(){ // ウィンドウがリサイズされるたびに呼び出される関数\r\n  resizeCanvas(windowWidth, windowHeight); // キャンバスをリサイズする（createCanvasではないので注意）\r\n}\r\n\r\nfunction draw(){\r\n  background(160, 192, 255); //前回の描画を消し、アニメーションに見せるためにこの位置に書き、上塗りする。\r\n  count = (count + 1) % cycle; // BLANK[2] let speed = 1; // アニメーションの速さ count = (count + speed) % cycle;とすることも可\r\n  if (count < cycle / 2) {\r\n    size += 1;\r\n  } else {\r\n    size -= 1;\r\n  }\r\n  ellipse(width / 2, height / 2, size, size); // BLANK[1] 1周期の前半は size が大きくなり、後半は小さくなる\r\n}"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "11/11/2025, 2:34:08 AM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// 心臓の鼓動のようなアニメーション\r\nconst cycle = 100; // 1周期のフレーム数（定数）\r\nlet count = 0; // 現在のフレーム数（変数）\r\nlet size = 50;\r\n\r\n\r\n\r\nfunction draw(){\r\n  background(160, 192, 255); //前回の描画を消し、アニメーションに見せるためにこの位置に書き、上塗りする。\r\n  count = (count + 1) % cycle; // BLANK[2] let speed = 1; // アニメーションの速さ count = (count + speed) % cycle;とすることも可\r\n  if (count < cycle / 2) {\r\n    size += 1;\r\n  } else {\r\n    size -= 1;\r\n  }\r\n  ellipse(width / 2, height / 2, size, size); // BLANK[1] 1周期の前半は size が大きくなり、後半は小さくなる\r\n}"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "11/11/2025, 2:34:19 AM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// 心臓の鼓動のようなアニメーション\r\nconst cycle = 100; // 1周期のフレーム数（定数）\r\nlet count = 0; // 現在のフレーム数（変数）\r\nlet size = 50;\r\n\r\nfunction setup(){\r\n  createCanvas(windowWidth, windowHeight); // キャンバスの大きさをウィンドウの大きさと同じにする\r\n}\r\n\r\nfunction windowResized(){ // ウィンドウがリサイズされるたびに呼び出される関数\r\n  resizeCanvas(windowWidth, windowHeight); // キャンバスをリサイズする（createCanvasではないので注意）\r\n}\r\n\r\nfunction draw(){\r\n  background(160, 192, 255); //前回の描画を消し、アニメーションに見せるためにこの位置に書き、上塗りする。\r\n  count = (count + 1) % cycle; // BLANK[2] let speed = 1; // アニメーションの速さ count = (count + speed) % cycle;とすることも可\r\n  if (count < cycle / 2) {\r\n    size += 1;\r\n  } else {\r\n    size -= 1;\r\n  }\r\n  ellipse(width / 2, height / 2, size, size); // BLANK[1] 1周期の前半は size が大きくなり、後半は小さくなる\r\n}"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "11/11/2025, 2:35:25 AM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// 心臓の鼓動のようなアニメーション\r\nconst cycle = 100; // 1周期のフレーム数（定数）\r\nlet count = 0; // 現在のフレーム数（変数）\r\nlet size = 50;\r\n\r\nfunction setup(){\r\n  createCanvas(windowWidth, windowHeight); // キャンバスの大きさをウィンドウの大きさと同じにする\r\n}\r\n\r\nfunction windowResized(){ // ウィンドウがリサイズされるたびに呼び出される関数\r\n  resizeCanvas(windowWidth, windowHeight); // キャンバスをリサイズする（createCanvasではないので注意）\r\n}\r\n\r\nfunction draw(){\r\n  background(160, 192, 255); //前回の描画を消し、アニメーションに見せるためにこの位置に書き、上塗りする。\r\n  count = (count + 1) % cycle; // BLANK[2] let speed = 1; // アニメーションの速さ count = (count + speed) % cycle;とすることも可\r\n  if (keyIsPressed) {\r\n    count = (count + 2) % cycle; //2はスピード\r\n  }\r\n  if (count < cycle / 2) {\r\n    size += 1;\r\n  } else {\r\n    size -= 1;\r\n  }\r\n  ellipse(width / 2, height / 2, size, size); // BLANK[1] 1周期の前半は size が大きくなり、後半は小さくなる\r\n}"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "11/11/2025, 2:44:53 AM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// 2D アニメーションゲームのようなインタラクション\r\nlet x, y;\r\nlet vx, vy;\r\nconst g = 1;\r\n\r\nfunction setup(){\r\n  createCanvas(windowWidth, windowHeight);\r\n  x = width / 2;\r\n  y = height / 2;\r\n  vx = 0;\r\n  vy = 0;\r\n}\r\n\r\nfunction windowResized(){\r\n  resizeCanvas(windowWidth, windowHeight);\r\n}\r\n\r\nfunction draw(){\r\n  background(160, 192, 255);\r\n  const size = height * 0.1; // キャラクターのサイズ\r\n\r\n  // 地面を描く\r\n  const groundY = height * 0.8;\r\n  fill(64, 192, 64);\r\n  rect(0, groundY, width, height - groundY);\r\n\r\n  // BLANK[1] キャラクターの左右移動\r\n  ellipse(x, y, 50);\r\n  // キーの処理（else ifにすると同時押しできなくなってしまうので要注意）\r\n  if(keyIsDown(LEFT_ARROW)){ x -= 5; }\r\n  if(keyIsDown(RIGHT_ARROW)){ x += 5; }\r\n  if(keyIsDown(UP_ARROW)){ y -= 5; }\r\n  if(keyIsDown(DOWN_ARROW)){ y += 5; }\r\n  if(keyIsDown(\"A\".charCodeAt(0))){ x+= 10; } // 文字キーの場合\r\n  if(keyIsDown(\" \".charCodeAt(0))){ x-= 10; } // スペースキーも文字キーと同様\r\n\r\n  // BLANK[2] 重力とジャンプ\r\n\r\n  // 速くなりすぎないように制限\r\n  vx = constrain(vx, -20, 20);\r\n  vy = constrain(vy, -20, 20);\r\n\r\n  // 位置を更新\r\n  x += vx;\r\n  y += vy;\r\n\r\n  // キャラクターを描く\r\n  fill(0);\r\n  ellipse(x, y, size, size);\r\n}"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "11/11/2025, 2:45:37 AM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// 2D アニメーションゲームのようなインタラクション\r\nlet x, y;\r\nlet vx, vy;\r\nconst g = 1;\r\n\r\nfunction setup(){\r\n  createCanvas(windowWidth, windowHeight);\r\n  x = width / 2;\r\n  y = height / 2;\r\n  vx = 0;\r\n  vy = 0;\r\n}\r\n\r\nfunction windowResized(){\r\n  resizeCanvas(windowWidth, windowHeight);\r\n}\r\n\r\nfunction draw(){\r\n  background(160, 192, 255);\r\n  const size = height * 0.1; // キャラクターのサイズ\r\n\r\n  // 地面を描く\r\n  const groundY = height * 0.8;\r\n  fill(64, 192, 64);\r\n  rect(0, groundY, width, height - groundY);\r\n\r\n  // BLANK[1] キャラクターの左右移動\r\n  ellipse(x, y, 50);\r\n  // キーの処理（else ifにすると同時押しできなくなってしまうので要注意）\r\n  if(keyIsDown(LEFT_ARROW)){ x -= 5; }\r\n  if(keyIsDown(RIGHT_ARROW)){ x += 5; }\r\n  if(keyIsDown(UP_ARROW)){ y -= 5; }\r\n  if(keyIsDown(DOWN_ARROW)){ y += 5; }\r\n\r\n  // BLANK[2] 重力とジャンプ\r\n\r\n  // 速くなりすぎないように制限\r\n  vx = constrain(vx, -20, 20);\r\n  vy = constrain(vy, -20, 20);\r\n\r\n  // 位置を更新\r\n  x += vx;\r\n  y += vy;\r\n\r\n  // キャラクターを描く\r\n  fill(0);\r\n  ellipse(x, y, size, size);\r\n}"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "11/11/2025, 2:45:36 AM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// 2D アニメーションゲームのようなインタラクション\r\nlet x, y;\r\nlet vx, vy;\r\nconst g = 1;\r\n\r\nfunction setup(){\r\n  createCanvas(windowWidth, windowHeight);\r\n  x = width / 2;\r\n  y = height / 2;\r\n  vx = 0;\r\n  vy = 0;\r\n}\r\n\r\nfunction windowResized(){\r\n  resizeCanvas(windowWidth, windowHeight);\r\n}\r\n\r\nfunction draw(){\r\n  background(160, 192, 255);\r\n  const size = height * 0.1; // キャラクターのサイズ\r\n\r\n  // 地面を描く\r\n  const groundY = height * 0.8;\r\n  fill(64, 192, 64);\r\n  rect(0, groundY, width, height - groundY);\r\n\r\n  // BLANK[1] キャラクターの左右移動\r\n  ellipse(x, y, 50);\r\n  // キーの処理（else ifにすると同時押しできなくなってしまうので要注意）\r\n  if(keyIsDown(LEFT_ARROW)){ x -= 5; }\r\n  if(keyIsDown(RIGHT_ARROW)){ x += 5; }\r\n  if(keyIsDown(UP_ARROW)){ y -= 5; }\r\n  if(keyIsDown(DOWN_ARROW)){ y += 5; }\r\n\r\n  // BLANK[2] 重力とジャンプ\r\n\r\n  // 速くなりすぎないように制限\r\n  vx = constrain(vx, -20, 20);\r\n  vy = constrain(vy, -20, 20);\r\n\r\n  // 位置を更新\r\n  x += vx;\r\n  y += vy;\r\n\r\n  // キャラクターを描く\r\n  fill(0);\r\n  ellipse(x, y, size, size);\r\n}"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "11/11/2025, 2:48:04 AM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// 2D アニメーションゲームのようなインタラクション\r\nlet x, y;\r\nlet vx, vy;\r\nconst g = 1;\r\n\r\nfunction setup(){\r\n  createCanvas(windowWidth, windowHeight);\r\n  x = width / 2;\r\n  y = height / 2;\r\n  vx = 0;\r\n  vy = 0;\r\n}\r\n\r\nfunction windowResized(){\r\n  resizeCanvas(windowWidth, windowHeight);\r\n}\r\n\r\nfunction draw(){\r\n  background(160, 192, 255);\r\n  const size = height * 0.1; // キャラクターのサイズ\r\n\r\n  // 地面を描く\r\n  const groundY = height * 0.8;\r\n  fill(64, 192, 64);\r\n  rect(0, groundY, width, height - groundY);\r\n\r\n  // BLANK[1] キャラクターの左右移動\r\n  ellipse(x, y, 50);\r\n  // キーの処理（else ifにすると同時押しできなくなってしまうので要注意）\r\n  if(keyIsDown(LEFT_ARROW)){ x -= 5; }\r\n  if(keyIsDown(RIGHT_ARROW)){ x += 5; }\r\n  if(keyIsDown(UP_ARROW)){ y -= 5; }\r\n  if(keyIsDown(DOWN_ARROW)){ y += 5; }\r\n  if(keyIsDown(LEFT_ARROW)||(\"D\".charCodeAt(0))){ x -= 10; }\r\n  if(keyIsDown(RIGHT_ARROW)||(\"D\".charCodeAt(0))){ x += 10; }\r\n\r\n  // BLANK[2] 重力とジャンプ\r\n\r\n  // 速くなりすぎないように制限\r\n  vx = constrain(vx, -20, 20);\r\n  vy = constrain(vy, -20, 20);\r\n\r\n  // 位置を更新\r\n  x += vx;\r\n  y += vy;\r\n\r\n  // キャラクターを描く\r\n  fill(0);\r\n  ellipse(x, y, size, size);\r\n}"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "11/11/2025, 2:54:25 AM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// 2D アニメーションゲームのようなインタラクション\r\nlet x, y;\r\nlet vx, vy;\r\nconst g = 1;\r\n\r\nfunction setup(){\r\n  createCanvas(windowWidth, windowHeight);\r\n  x = width / 2;\r\n  y = height / 2;\r\n  vx = 0;\r\n  vy = 0;\r\n}\r\n\r\nfunction windowResized(){\r\n  resizeCanvas(windowWidth, windowHeight);\r\n}\r\n\r\nfunction draw(){\r\n  background(160, 192, 255);\r\n  const size = height * 0.1; // キャラクターのサイズ\r\n\r\n  // 地面を描く\r\n  const groundY = height * 0.8;\r\n  fill(64, 192, 64);\r\n  rect(0, groundY, width, height - groundY);\r\n\r\n  // BLANK[1] キャラクターの左右移動\r\n  ellipse(x, y, 50);\r\n  // キーの処理（else ifにすると同時押しできなくなってしまうので要注意）\r\n  if(keyIsDown(LEFT_ARROW)){ x -= 5; }\r\n  if(keyIsDown(RIGHT_ARROW)){ x += 5; }\r\n  if(keyIsDown(UP_ARROW)){ y -= 5; }\r\n  if(keyIsDown(DOWN_ARROW)){ y += 5; }\r\n  if(keyIsDown(LEFT_ARROW)&&(\"D\".charCodeAt(0))){ x -= 10; }\r\n  if(keyIsDown(RIGHT_ARROW)&&(\"D\".charCodeAt(0))){ x += 10; }\r\n\r\n  // BLANK[2] 重力とジャンプ\r\n\r\n  // 速くなりすぎないように制限\r\n  vx = constrain(vx, -20, 20);\r\n  vy = constrain(vy, -20, 20);\r\n\r\n  // 位置を更新\r\n  x += vx;\r\n  y += vy;\r\n\r\n  // キャラクターを描く\r\n  fill(0);\r\n  ellipse(x, y, size, size);\r\n}"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "11/11/2025, 2:57:16 AM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// 2D アニメーションゲームのようなインタラクション\r\nlet x, y;\r\nlet vx, vy;\r\nconst g = 1;\r\n\r\nfunction setup(){\r\n  createCanvas(windowWidth, windowHeight);\r\n  x = width / 2;\r\n  y = height / 2;\r\n  vx = 0;\r\n  vy = 0;\r\n}\r\n\r\nfunction windowResized(){\r\n  resizeCanvas(windowWidth, windowHeight);\r\n}\r\n\r\nfunction draw(){\r\n  background(160, 192, 255);\r\n  const size = height * 0.1; // キャラクターのサイズ\r\n\r\n  // 地面を描く\r\n  const groundY = height * 0.8;\r\n  fill(64, 192, 64);\r\n  rect(0, groundY, width, height - groundY);\r\n\r\n  // BLANK[1] キャラクターの左右移動\r\n  ellipse(x, y, 50);\r\n  // キーの処理（else ifにすると同時押しできなくなってしまうので要注意）\r\n  if(keyIsDown(LEFT_ARROW)){ x -= 5; }\r\n  if(keyIsDown(RIGHT_ARROW)){ x += 5; }\r\n  if(keyIsDown(UP_ARROW)){ y -= 5; }\r\n  if(keyIsDown(DOWN_ARROW)){ y += 5; }\r\n  // Dキーが押されているかどうかの判定に charCodeAt(0) を使う\r\n  const D_CODE = \"D\".charCodeAt(0); \r\n  if(keyIsDown(LEFT_ARROW)&&(\"D\".charCodeAt(0))){ x -= 10; }\r\n  if(keyIsDown(RIGHT_ARROW)&&(\"D\".charCodeAt(0))){ x += 10; }\r\n\r\n  // BLANK[2] 重力とジャンプ\r\n\r\n  // 速くなりすぎないように制限\r\n  vx = constrain(vx, -20, 20);\r\n  vy = constrain(vy, -20, 20);\r\n\r\n  // 位置を更新\r\n  x += vx;\r\n  y += vy;\r\n\r\n  // キャラクターを描く\r\n  fill(0);\r\n  ellipse(x, y, size, size);\r\n}"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "11/11/2025, 2:58:35 AM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// 2D アニメーションゲームのようなインタラクション\r\nlet x, y;\r\nlet vx, vy;\r\nconst g = 1;\r\n\r\nfunction setup(){\r\n  createCanvas(windowWidth, windowHeight);\r\n  x = width / 2;\r\n  y = height / 2;\r\n  vx = 0;\r\n  vy = 0;\r\n}\r\n\r\nfunction windowResized(){\r\n  resizeCanvas(windowWidth, windowHeight);\r\n}\r\n\r\nfunction draw(){\r\n  background(160, 192, 255);\r\n  const size = height * 0.1; // キャラクターのサイズ\r\n\r\n  // 地面を描く\r\n  const groundY = height * 0.8;\r\n  fill(64, 192, 64);\r\n  rect(0, groundY, width, height - groundY);\r\n\r\n  // BLANK[1] キャラクターの左右移動\r\n  ellipse(x, y, 50);\r\n  // キーの処理（else ifにすると同時押しできなくなってしまうので要注意）\r\n  if(keyIsDown(LEFT_ARROW)){ x -= 5; }\r\n  if(keyIsDown(RIGHT_ARROW)){ x += 5; }\r\n  if(keyIsDown(UP_ARROW)){ y -= 5; }\r\n  if(keyIsDown(DOWN_ARROW)){ y += 5; }\r\n  if(keyIsDown(LEFT_ARROW)&&(keyIsDown(\"D\".charCodeAt(0))){ x -= 10; }\r\n  if(keyIsDown(RIGHT_ARROW)&&(keyIsDown(\"D\".charCodeAt(0))){ x += 10; }\r\n\r\n  // BLANK[2] 重力とジャンプ\r\n\r\n  // 速くなりすぎないように制限\r\n  vx = constrain(vx, -20, 20);\r\n  vy = constrain(vy, -20, 20);\r\n\r\n  // 位置を更新\r\n  x += vx;\r\n  y += vy;\r\n\r\n  // キャラクターを描く\r\n  fill(0);\r\n  ellipse(x, y, size, size);\r\n}"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "11/11/2025, 2:59:25 AM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// 2D アニメーションゲームのようなインタラクション\r\nlet x, y;\r\nlet vx, vy;\r\nconst g = 1;\r\n\r\nfunction setup(){\r\n  createCanvas(windowWidth, windowHeight);\r\n  x = width / 2;\r\n  y = height / 2;\r\n  vx = 0;\r\n  vy = 0;\r\n}\r\n\r\nfunction windowResized(){\r\n  resizeCanvas(windowWidth, windowHeight);\r\n}\r\n\r\nfunction draw(){\r\n  background(160, 192, 255);\r\n  const size = height * 0.1; // キャラクターのサイズ\r\n\r\n  // 地面を描く\r\n  const groundY = height * 0.8;\r\n  fill(64, 192, 64);\r\n  rect(0, groundY, width, height - groundY);\r\n\r\n  // BLANK[1] キャラクターの左右移動\r\n  ellipse(x, y, 50);\r\n  // キーの処理（else ifにすると同時押しできなくなってしまうので要注意）\r\n  if(keyIsDown(LEFT_ARROW)){ x -= 5; }\r\n  if(keyIsDown(RIGHT_ARROW)){ x += 5; }\r\n  if(keyIsDown(UP_ARROW)){ y -= 5; }\r\n  if(keyIsDown(DOWN_ARROW)){ y += 5; }\r\n  if(keyIsDown(LEFT_ARROW)&&(keyIsDown(\"D\".charCodeAt(0)))){ x -= 10; }\r\n  if(keyIsDown(RIGHT_ARROW)&&(keyIsDown(\"D\".charCodeAt(0)))){ x += 10; }\r\n\r\n  // BLANK[2] 重力とジャンプ\r\n\r\n  // 速くなりすぎないように制限\r\n  vx = constrain(vx, -20, 20);\r\n  vy = constrain(vy, -20, 20);\r\n\r\n  // 位置を更新\r\n  x += vx;\r\n  y += vy;\r\n\r\n  // キャラクターを描く\r\n  fill(0);\r\n  ellipse(x, y, size, size);\r\n}"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "11/11/2025, 3:00:05 AM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// 2D アニメーションゲームのようなインタラクション\r\nlet x, y;\r\nlet vx, vy;\r\nconst g = 1;\r\n\r\nfunction setup(){\r\n  createCanvas(windowWidth, windowHeight);\r\n  x = width / 2;\r\n  y = height / 2;\r\n  vx = 0;\r\n  vy = 0;\r\n}\r\n\r\nfunction windowResized(){\r\n  resizeCanvas(windowWidth, windowHeight);\r\n}\r\n\r\nfunction draw(){\r\n  background(160, 192, 255);\r\n  const size = height * 0.1; // キャラクターのサイズ\r\n\r\n  // 地面を描く\r\n  const groundY = height * 0.8;\r\n  fill(64, 192, 64);\r\n  rect(0, groundY, width, height - groundY);\r\n\r\n  // BLANK[1] キャラクターの左右移動\r\n  ellipse(x, y, 50);\r\n  // キーの処理（else ifにすると同時押しできなくなってしまうので要注意）\r\n  if(keyIsDown(LEFT_ARROW)){ x -= 5; }\r\n  if(keyIsDown(RIGHT_ARROW)){ x += 5; }\r\n  if(keyIsDown(LEFT_ARROW)&&(keyIsDown(\"D\".charCodeAt(0)))){ x -= 10; }\r\n  if(keyIsDown(RIGHT_ARROW)&&(keyIsDown(\"D\".charCodeAt(0)))){ x += 10; }\r\n\r\n  // BLANK[2] 重力とジャンプ\r\n\r\n  // 速くなりすぎないように制限\r\n  vx = constrain(vx, -20, 20);\r\n  vy = constrain(vy, -20, 20);\r\n\r\n  // 位置を更新\r\n  x += vx;\r\n  y += vy;\r\n\r\n  // キャラクターを描く\r\n  fill(0);\r\n  ellipse(x, y, size, size);\r\n}"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "11/11/2025, 3:04:47 AM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// 2D アニメーションゲームのようなインタラクション\r\nlet x, y;\r\nlet vx, vy;\r\nconst g = 1; //重力\r\nconst vyMax = 20;\r\n\r\nfunction setup(){\r\n  createCanvas(windowWidth, windowHeight);\r\n  x = width / 2;\r\n  y = height / 2;\r\n  vx = 0;\r\n  vy = 0;\r\n}\r\n\r\nfunction windowResized(){\r\n  resizeCanvas(windowWidth, windowHeight);\r\n}\r\n\r\nfunction draw(){\r\n  background(160, 192, 255);\r\n  const size = height * 0.1; // キャラクターのサイズ\r\n\r\n  // 地面を描く\r\n  const groundY = height * 0.8;\r\n  fill(64, 192, 64);\r\n  rect(0, groundY, width, height - groundY);\r\n\r\n  // BLANK[1] キャラクターの左右移動\r\n  ellipse(x, y, 50);\r\n  // キーの処理（else ifにすると同時押しできなくなってしまうので要注意）\r\n  if(keyIsDown(LEFT_ARROW)){ x -= 5; }\r\n  if(keyIsDown(RIGHT_ARROW)){ x += 5; }\r\n  if(keyIsDown(LEFT_ARROW)&&(keyIsDown(\"D\".charCodeAt(0)))){ x -= 10; }\r\n  if(keyIsDown(RIGHT_ARROW)&&(keyIsDown(\"D\".charCodeAt(0)))){ x += 10; }\r\n\r\n  // BLANK[2] 重力とジャンプ\r\n  x += vx;\r\n  y += vy;\r\n  vy += g; // 重力は「速度の変化量」\r\n\r\n  // 速くなりすぎないように制限\r\n  vx = constrain(vx, -20, 20);\r\n  vy = constrain(vy, -20, 20);\r\n\r\n  // 位置を更新\r\n  x += vx;\r\n  y += vy;\r\n\r\n  // キャラクターを描く\r\n  fill(0);\r\n  ellipse(x, y, size, size);\r\n}"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "11/11/2025, 3:05:29 AM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// 2D アニメーションゲームのようなインタラクション\r\nlet x, y;\r\nlet vx, vy;\r\nconst g = 1; //重力\r\nconst vyMax = 20;\r\n\r\nfunction setup(){\r\n  createCanvas(windowWidth, windowHeight);\r\n  x = width / 2;\r\n  y = height / 2;\r\n  vx = 0;\r\n  vy = 0;\r\n}\r\n\r\nfunction windowResized(){\r\n  resizeCanvas(windowWidth, windowHeight);\r\n}\r\n\r\nfunction draw(){\r\n  background(160, 192, 255);\r\n  const size = height * 0.1; // キャラクターのサイズ\r\n\r\n  // 地面を描く\r\n  const groundY = height * 0.8;\r\n  fill(64, 192, 64);\r\n  rect(0, groundY, width, height - groundY);\r\n\r\n  // BLANK[1] キャラクターの左右移動\r\n  ellipse(x, y, 50);\r\n  // キーの処理（else ifにすると同時押しできなくなってしまうので要注意）\r\n  if(keyIsDown(LEFT_ARROW)){ x -= 5; }\r\n  if(keyIsDown(RIGHT_ARROW)){ x += 5; }\r\n  if(keyIsDown(LEFT_ARROW)&&(keyIsDown(\"D\".charCodeAt(0)))){ x -= 10; }\r\n  if(keyIsDown(RIGHT_ARROW)&&(keyIsDown(\"D\".charCodeAt(0)))){ x += 10; }\r\n\r\n  // BLANK[2] 重力とジャンプ\r\n  \r\n\r\n  // 速くなりすぎないように制限\r\n  vx = constrain(vx, -20, 20);\r\n  vy = constrain(vy, -20, 20);\r\n\r\n  // 位置を更新\r\n  x += vx;\r\n  y += vy;\r\n\r\n  // キャラクターを描く\r\n  fill(0);\r\n  ellipse(x, y, size, size);\r\n}"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "11/11/2025, 3:09:27 AM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// 2D アニメーションゲームのようなインタラクション\r\nlet x, y;\r\nlet vx, vy;\r\nconst g = 1; //重力\r\nconst vyMax = 20;\r\n\r\nfunction setup(){\r\n  createCanvas(windowWidth, windowHeight);\r\n  x = width / 2;\r\n  y = height / 2;\r\n  vx = 0;\r\n  vy = 0;\r\n}\r\n\r\nfunction windowResized(){\r\n  resizeCanvas(windowWidth, windowHeight);\r\n}\r\n\r\nfunction draw(){\r\n  background(160, 192, 255);\r\n  const size = height * 0.1; // キャラクターのサイズ\r\n\r\n  // 地面を描く\r\n  const groundY = height * 0.8;\r\n  fill(64, 192, 64);\r\n  rect(0, groundY, width, height - groundY);\r\n\r\n  // BLANK[1] キャラクターの左右移動\r\n  ellipse(x, y, 50);\r\n  // キーの処理（else ifにすると同時押しできなくなってしまうので要注意）\r\n  if(keyIsDown(LEFT_ARROW)){ x -= 5; }\r\n  if(keyIsDown(RIGHT_ARROW)){ x += 5; }\r\n  if(keyIsDown(LEFT_ARROW)&&(keyIsDown(\"D\".charCodeAt(0)))){ x -= 10; }\r\n  if(keyIsDown(RIGHT_ARROW)&&(keyIsDown(\"D\".charCodeAt(0)))){ x += 10; }\r\n\r\n\r\n  // BLANK[2] 重力とジャンプ\r\n  \r\n\r\n  // 速くなりすぎないように制限\r\n  vx = constrain(vx, -20, 20);\r\n  vy = constrain(vy, -20, 20);\r\n\r\n  // 位置を更新\r\n  x += vx;\r\n  y += vy;\r\n\r\n  // キャラクターを描く\r\n  fill(0);\r\n  ellipse(x, groundY, size, size);\r\n}"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "11/11/2025, 3:10:28 AM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// 2D アニメーションゲームのようなインタラクション\r\nlet x, y;\r\nlet vx, vy;\r\nconst g = 1; //重力\r\nconst vyMax = 20;\r\n\r\nfunction setup(){\r\n  createCanvas(windowWidth, windowHeight);\r\n  x = width / 2;\r\n  y = height / 2;\r\n  vx = 0;\r\n  vy = 0;\r\n}\r\n\r\nfunction windowResized(){\r\n  resizeCanvas(windowWidth, windowHeight);\r\n}\r\n\r\nfunction draw(){\r\n  background(160, 192, 255);\r\n  const size = height * 0.1; // キャラクターのサイズ\r\n\r\n  // 地面を描く\r\n  const groundY = height * 0.8;\r\n  fill(64, 192, 64);\r\n  rect(0, groundY, width, height - groundY);\r\n\r\n  // BLANK[1] キャラクターの左右移動\r\n  ellipse(x, groundY, 50);\r\n  // キーの処理（else ifにすると同時押しできなくなってしまうので要注意）\r\n  if(keyIsDown(LEFT_ARROW)){ x -= 5; }\r\n  if(keyIsDown(RIGHT_ARROW)){ x += 5; }\r\n  if(keyIsDown(LEFT_ARROW)&&(keyIsDown(\"D\".charCodeAt(0)))){ x -= 10; }\r\n  if(keyIsDown(RIGHT_ARROW)&&(keyIsDown(\"D\".charCodeAt(0)))){ x += 10; }\r\n\r\n\r\n  // BLANK[2] 重力とジャンプ\r\n  \r\n\r\n  // 速くなりすぎないように制限\r\n  vx = constrain(vx, -20, 20);\r\n  vy = constrain(vy, -20, 20);\r\n\r\n  // 位置を更新\r\n  x += vx;\r\n  y += vy;\r\n\r\n  // キャラクターを描く\r\n  fill(0);\r\n  ellipse(x, groundY, size, size);\r\n}"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "11/11/2025, 3:21:04 AM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// 2D アニメーションゲームのようなインタラクション\r\nlet x, y;\r\nlet vx, vy;\r\nconst g = 1; //重力\r\nconst vyMax = 20;\r\n\r\nfunction setup(){\r\n  createCanvas(windowWidth, windowHeight);\r\n  x = width / 2;\r\n  y = height / 2;\r\n  vx = 0;\r\n  vy = 0;\r\n}\r\n\r\nfunction windowResized(){\r\n  resizeCanvas(windowWidth, windowHeight);\r\n}\r\n\r\nfunction draw(){\r\n  background(160, 192, 255);\r\n  const size = height * 0.1; // キャラクターのサイズ\r\n\r\n  // 地面を描く\r\n  const groundY = height * 0.8;\r\n  fill(64, 192, 64);\r\n  rect(0, groundY, width, height - groundY);\r\n\r\n  // BLANK[1] キャラクターの左右移動\r\n  ellipse(x, groundY, 50);\r\n  // キーの処理（else ifにすると同時押しできなくなってしまうので要注意）\r\n  if(keyIsDown(LEFT_ARROW)){ x -= 5; }\r\n  if(keyIsDown(RIGHT_ARROW)){ x += 5; }\r\n  if(keyIsDown(LEFT_ARROW)&&(keyIsDown(\"D\".charCodeAt(0)))){ x -= 10; }\r\n  if(keyIsDown(RIGHT_ARROW)&&(keyIsDown(\"D\".charCodeAt(0)))){ x += 10; }\r\n\r\n\r\n  // BLANK[2] 重力とジャンプ\r\n  if(keyIsDown(\" \".charCodeAt(0)))&&(y >= groundY)){\r\n    // ジャンプ処理（例: y方向の速度(vy)を上向き（負の値）に設定する）\r\n    vy = -15; // 例として-15を設定\r\n  } // スペースキーでジャンプ\r\n}\r\n\r\n  // 速くなりすぎないように制限\r\n  vx = constrain(vx, -20, 20);\r\n  vy = constrain(vy, -20, 20);\r\n\r\n  // 位置を更新\r\n  x += vx;\r\n  y += vy;\r\n\r\n  // キャラクターを描く\r\n  fill(0);\r\n  ellipse(x, groundY, size, size);\r\n}"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "11/11/2025, 3:21:03 AM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// 2D アニメーションゲームのようなインタラクション\r\nlet x, y;\r\nlet vx, vy;\r\nconst g = 1; //重力\r\nconst vyMax = 20;\r\n\r\nfunction setup(){\r\n  createCanvas(windowWidth, windowHeight);\r\n  x = width / 2;\r\n  y = height / 2;\r\n  vx = 0;\r\n  vy = 0;\r\n}\r\n\r\nfunction windowResized(){\r\n  resizeCanvas(windowWidth, windowHeight);\r\n}\r\n\r\nfunction draw(){\r\n  background(160, 192, 255);\r\n  const size = height * 0.1; // キャラクターのサイズ\r\n\r\n  // 地面を描く\r\n  const groundY = height * 0.8;\r\n  fill(64, 192, 64);\r\n  rect(0, groundY, width, height - groundY);\r\n\r\n  // BLANK[1] キャラクターの左右移動\r\n  ellipse(x, groundY, 50);\r\n  // キーの処理（else ifにすると同時押しできなくなってしまうので要注意）\r\n  if(keyIsDown(LEFT_ARROW)){ x -= 5; }\r\n  if(keyIsDown(RIGHT_ARROW)){ x += 5; }\r\n  if(keyIsDown(LEFT_ARROW)&&(keyIsDown(\"D\".charCodeAt(0)))){ x -= 10; }\r\n  if(keyIsDown(RIGHT_ARROW)&&(keyIsDown(\"D\".charCodeAt(0)))){ x += 10; }\r\n\r\n\r\n  // BLANK[2] 重力とジャンプ\r\n  if(keyIsDown(\" \".charCodeAt(0)))&&(y >= groundY)){\r\n    // ジャンプ処理（例: y方向の速度(vy)を上向き（負の値）に設定する）\r\n    vy = -15; // 例として-15を設定\r\n  } // スペースキーでジャンプ\r\n}\r\n\r\n  // 速くなりすぎないように制限\r\n  vx = constrain(vx, -20, 20);\r\n  vy = constrain(vy, -20, 20);\r\n\r\n  // 位置を更新\r\n  x += vx;\r\n  y += vy;\r\n\r\n  // キャラクターを描く\r\n  fill(0);\r\n  ellipse(x, groundY, size, size);\r\n}"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "11/11/2025, 3:21:31 AM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// 2D アニメーションゲームのようなインタラクション\r\nlet x, y;\r\nlet vx, vy;\r\nconst g = 1; //重力\r\nconst vyMax = 20;\r\n\r\nfunction setup(){\r\n  createCanvas(windowWidth, windowHeight);\r\n  x = width / 2;\r\n  y = height / 2;\r\n  vx = 0;\r\n  vy = 0;\r\n}\r\n\r\nfunction windowResized(){\r\n  resizeCanvas(windowWidth, windowHeight);\r\n}\r\n\r\nfunction draw(){\r\n  background(160, 192, 255);\r\n  const size = height * 0.1; // キャラクターのサイズ\r\n\r\n  // 地面を描く\r\n  const groundY = height * 0.8;\r\n  fill(64, 192, 64);\r\n  rect(0, groundY, width, height - groundY);\r\n\r\n  // BLANK[1] キャラクターの左右移動\r\n  ellipse(x, groundY, 50);\r\n  // キーの処理（else ifにすると同時押しできなくなってしまうので要注意）\r\n  if(keyIsDown(LEFT_ARROW)){ x -= 5; }\r\n  if(keyIsDown(RIGHT_ARROW)){ x += 5; }\r\n  if(keyIsDown(LEFT_ARROW)&&(keyIsDown(\"D\".charCodeAt(0)))){ x -= 10; }\r\n  if(keyIsDown(RIGHT_ARROW)&&(keyIsDown(\"D\".charCodeAt(0)))){ x += 10; }\r\n\r\n\r\n  // BLANK[2] 重力とジャンプ\r\n  if(keyIsDown(\" \".charCodeAt(0))&&(y >= groundY)){\r\n    // ジャンプ処理（例: y方向の速度(vy)を上向き（負の値）に設定する）\r\n    vy = -15; // 例として-15を設定\r\n  } // スペースキーでジャンプ\r\n}\r\n\r\n  // 速くなりすぎないように制限\r\n  vx = constrain(vx, -20, 20);\r\n  vy = constrain(vy, -20, 20);\r\n\r\n  // 位置を更新\r\n  x += vx;\r\n  y += vy;\r\n\r\n  // キャラクターを描く\r\n  fill(0);\r\n  ellipse(x, groundY, size, size);\r\n}"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "11/11/2025, 3:22:13 AM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// 2D アニメーションゲームのようなインタラクション\r\nlet x, y;\r\nlet vx, vy;\r\nconst g = 1; //重力\r\nconst vyMax = 20;\r\n\r\nfunction setup(){\r\n  createCanvas(windowWidth, windowHeight);\r\n  x = width / 2;\r\n  y = height / 2;\r\n  vx = 0;\r\n  vy = 0;\r\n}\r\n\r\nfunction windowResized(){\r\n  resizeCanvas(windowWidth, windowHeight);\r\n}\r\n\r\nfunction draw(){\r\n  background(160, 192, 255);\r\n  const size = height * 0.1; // キャラクターのサイズ\r\n\r\n  // 地面を描く\r\n  const groundY = height * 0.8;\r\n  fill(64, 192, 64);\r\n  rect(0, groundY, width, height - groundY);\r\n\r\n  // BLANK[1] キャラクターの左右移動\r\n  ellipse(x, groundY, 50);\r\n  // キーの処理（else ifにすると同時押しできなくなってしまうので要注意）\r\n  if(keyIsDown(LEFT_ARROW)){ x -= 5; }\r\n  if(keyIsDown(RIGHT_ARROW)){ x += 5; }\r\n  if(keyIsDown(LEFT_ARROW)&&(keyIsDown(\"D\".charCodeAt(0)))){ x -= 10; }\r\n  if(keyIsDown(RIGHT_ARROW)&&(keyIsDown(\"D\".charCodeAt(0)))){ x += 10; }\r\n\r\n\r\n  // BLANK[2] 重力とジャンプ\r\n  if(keyIsDown(\" \".charCodeAt(0))&&(y == groundY)){\r\n    // ジャンプ処理（例: y方向の速度(vy)を上向き（負の値）に設定する）\r\n    vy = -15; // 例として-15を設定\r\n  } // スペースキーでジャンプ\r\n}\r\n\r\n  // 速くなりすぎないように制限\r\n  vx = constrain(vx, -20, 20);\r\n  vy = constrain(vy, -20, 20);\r\n\r\n  // 位置を更新\r\n  x += vx;\r\n  y += vy;\r\n\r\n  // キャラクターを描く\r\n  fill(0);\r\n  ellipse(x, groundY, size, size);\r\n}"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "11/11/2025, 3:24:00 AM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// 2D アニメーションゲームのようなインタラクション\r\nlet x, y;\r\nlet vx, vy;\r\nconst g = 1; //重力\r\nconst vyMax = 20;\r\n\r\nfunction setup(){\r\n  createCanvas(windowWidth, windowHeight);\r\n  x = width / 2;\r\n  y = height / 2;\r\n  vx = 0;\r\n  vy = 0;\r\n}\r\n\r\nfunction windowResized(){\r\n  resizeCanvas(windowWidth, windowHeight);\r\n}\r\n\r\nfunction draw(){\r\n  background(160, 192, 255);\r\n  const size = height * 0.1; // キャラクターのサイズ\r\n\r\n  // 地面を描く\r\n  const groundY = height * 0.8;\r\n  fill(64, 192, 64);\r\n  rect(0, groundY, width, height - groundY);\r\n\r\n  // BLANK[1] キャラクターの左右移動\r\n  ellipse(x, groundY, 50);\r\n  // キーの処理（else ifにすると同時押しできなくなってしまうので要注意）\r\n  if(keyIsDown(LEFT_ARROW)){ x -= 5; }\r\n  if(keyIsDown(RIGHT_ARROW)){ x += 5; }\r\n  if(keyIsDown(LEFT_ARROW)&&(keyIsDown(\"D\".charCodeAt(0)))){ x -= 10; }\r\n  if(keyIsDown(RIGHT_ARROW)&&(keyIsDown(\"D\".charCodeAt(0)))){ x += 10; }\r\n\r\n\r\n  // BLANK[2] 重力とジャンプ\r\n  if(keyIsDown(\" \".charCodeAt(0))&&(y == groundY)){\r\n    // ジャンプ処理（例: y方向の速度(vy)を上向き（負の値）に設定する）\r\n    vy = -15; // 例として-15を設定\r\n  } // スペースキーでジャンプ\r\n\r\n\r\n  // 速くなりすぎないように制限\r\n  vx = constrain(vx, -20, 20);\r\n  vy = constrain(vy, -20, 20);\r\n\r\n  // 位置を更新\r\n  x += vx;\r\n  y += vy;\r\n\r\n  // キャラクターを描く\r\n  fill(0);\r\n  ellipse(x, groundY, size, size);\r\n}"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "11/11/2025, 3:24:40 AM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// 2D アニメーションゲームのようなインタラクション\r\nlet x, y;\r\nlet vx, vy;\r\nconst g = 1; //重力\r\nconst vyMax = 20;\r\n\r\nfunction setup(){\r\n  createCanvas(windowWidth, windowHeight);\r\n  x = width / 2;\r\n  y = height / 2;\r\n  vx = 0;\r\n  vy = 0;\r\n}\r\n\r\nfunction windowResized(){\r\n  resizeCanvas(windowWidth, windowHeight);\r\n}\r\n\r\nfunction draw(){\r\n  background(160, 192, 255);\r\n  const size = height * 0.1; // キャラクターのサイズ\r\n\r\n  // 地面を描く\r\n  const groundY = height * 0.8;\r\n  fill(64, 192, 64);\r\n  rect(0, groundY, width, height - groundY);\r\n\r\n  // BLANK[1] キャラクターの左右移動\r\n  ellipse(x, groundY, 50);\r\n  // キーの処理（else ifにすると同時押しできなくなってしまうので要注意）\r\n  if(keyIsDown(LEFT_ARROW)){ x -= 5; }\r\n  if(keyIsDown(RIGHT_ARROW)){ x += 5; }\r\n  if(keyIsDown(LEFT_ARROW)&&(keyIsDown(\"D\".charCodeAt(0)))){ x -= 10; }\r\n  if(keyIsDown(RIGHT_ARROW)&&(keyIsDown(\"D\".charCodeAt(0)))){ x += 10; }\r\n\r\n\r\n  // BLANK[2] 重力とジャンプ\r\n  if(keyIsDown(\" \".charCodeAt(0))&&(y == groundY)){\r\n    // ジャンプ処理（例: y方向の速度(vy)を上向き（負の値）に設定する）\r\n    vy = -15; // 例として-15を設定\r\n  } // スペースキーでジャンプ\r\n\r\n\r\n  // 速くなりすぎないように制限\r\n  vx = constrain(vx, -20, 20);\r\n  vy = constrain(vy, -20, 20);\r\n\r\n  // 位置を更新\r\n  x += vx;\r\n  y += vy;\r\n\r\n  // キャラクターを描く\r\n  fill(0);\r\n  ellipse(x, y, size, size);\r\n}"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "11/11/2025, 3:24:55 AM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// 2D アニメーションゲームのようなインタラクション\r\nlet x, y;\r\nlet vx, vy;\r\nconst g = 1; //重力\r\nconst vyMax = 20;\r\n\r\nfunction setup(){\r\n  createCanvas(windowWidth, windowHeight);\r\n  x = width / 2;\r\n  y = height / 2;\r\n  vx = 0;\r\n  vy = 0;\r\n}\r\n\r\nfunction windowResized(){\r\n  resizeCanvas(windowWidth, windowHeight);\r\n}\r\n\r\nfunction draw(){\r\n  background(160, 192, 255);\r\n  const size = height * 0.1; // キャラクターのサイズ\r\n\r\n  // 地面を描く\r\n  const groundY = height * 0.8;\r\n  fill(64, 192, 64);\r\n  rect(0, groundY, width, height - groundY);\r\n\r\n  // BLANK[1] キャラクターの左右移動\r\n  ellipse(x, y, 50);\r\n  // キーの処理（else ifにすると同時押しできなくなってしまうので要注意）\r\n  if(keyIsDown(LEFT_ARROW)){ x -= 5; }\r\n  if(keyIsDown(RIGHT_ARROW)){ x += 5; }\r\n  if(keyIsDown(LEFT_ARROW)&&(keyIsDown(\"D\".charCodeAt(0)))){ x -= 10; }\r\n  if(keyIsDown(RIGHT_ARROW)&&(keyIsDown(\"D\".charCodeAt(0)))){ x += 10; }\r\n\r\n\r\n  // BLANK[2] 重力とジャンプ\r\n  if(keyIsDown(\" \".charCodeAt(0))&&(y == groundY)){\r\n    // ジャンプ処理（例: y方向の速度(vy)を上向き（負の値）に設定する）\r\n    vy = -15; // 例として-15を設定\r\n  } // スペースキーでジャンプ\r\n\r\n\r\n  // 速くなりすぎないように制限\r\n  vx = constrain(vx, -20, 20);\r\n  vy = constrain(vy, -20, 20);\r\n\r\n  // 位置を更新\r\n  x += vx;\r\n  y += vy;\r\n\r\n  // キャラクターを描く\r\n  fill(0);\r\n  ellipse(x, y, size, size);\r\n}"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "11/11/2025, 3:26:32 AM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// 2D アニメーションゲームのようなインタラクション\r\nlet x, y;\r\nlet vx, vy;\r\nconst g = 1; //重力\r\nconst vyMax = 20;\r\n\r\nfunction setup(){\r\n  createCanvas(windowWidth, windowHeight);\r\n  x = width / 2;\r\n  y = height / 0.8;\r\n  vx = 0;\r\n  vy = 0;\r\n}\r\n\r\nfunction windowResized(){\r\n  resizeCanvas(windowWidth, windowHeight);\r\n}\r\n\r\nfunction draw(){\r\n  background(160, 192, 255);\r\n  const size = height * 0.1; // キャラクターのサイズ\r\n\r\n  // 地面を描く\r\n  const groundY = height * 0.8;\r\n  fill(64, 192, 64);\r\n  rect(0, groundY, width, height - groundY);\r\n\r\n  // BLANK[1] キャラクターの左右移動\r\n  ellipse(x, y, 50);\r\n  // キーの処理（else ifにすると同時押しできなくなってしまうので要注意）\r\n  if(keyIsDown(LEFT_ARROW)){ x -= 5; }\r\n  if(keyIsDown(RIGHT_ARROW)){ x += 5; }\r\n  if(keyIsDown(LEFT_ARROW)&&(keyIsDown(\"D\".charCodeAt(0)))){ x -= 10; }\r\n  if(keyIsDown(RIGHT_ARROW)&&(keyIsDown(\"D\".charCodeAt(0)))){ x += 10; }\r\n\r\n\r\n  // BLANK[2] 重力とジャンプ\r\n  if(keyIsDown(\" \".charCodeAt(0))&&(y == groundY)){\r\n    // ジャンプ処理（例: y方向の速度(vy)を上向き（負の値）に設定する）\r\n    vy = -15; // 例として-15を設定\r\n  } // スペースキーでジャンプ\r\n\r\n\r\n  // 速くなりすぎないように制限\r\n  vx = constrain(vx, -20, 20);\r\n  vy = constrain(vy, -20, 20);\r\n\r\n  // 位置を更新\r\n  x += vx;\r\n  y += vy;\r\n\r\n  // キャラクターを描く\r\n  fill(0);\r\n  ellipse(x, y, size, size);\r\n}"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "11/11/2025, 3:29:27 AM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// 2D アニメーションゲームのようなインタラクション\r\nlet x, y;\r\nlet vx, vy;\r\nconst g = 1; //重力\r\nconst vyMax = 20;\r\n\r\nfunction setup(){\r\n  createCanvas(windowWidth, windowHeight);\r\n  x = width / 2;\r\n  y = groundY - (size / 2);\r\n  vx = 0;\r\n  vy = 0;\r\n}\r\n\r\nfunction windowResized(){\r\n  resizeCanvas(windowWidth, windowHeight);\r\n}\r\n\r\nfunction draw(){\r\n  background(160, 192, 255);\r\n  const size = height * 0.1; // キャラクターのサイズ\r\n\r\n  // 地面を描く\r\n  const groundY = height * 0.8;\r\n  fill(64, 192, 64);\r\n  rect(0, groundY, width, height - groundY);\r\n\r\n  // BLANK[1] キャラクターの左右移動\r\n  ellipse(x, y, 50);\r\n  // キーの処理（else ifにすると同時押しできなくなってしまうので要注意）\r\n  if(keyIsDown(LEFT_ARROW)){ x -= 5; }\r\n  if(keyIsDown(RIGHT_ARROW)){ x += 5; }\r\n  if(keyIsDown(LEFT_ARROW)&&(keyIsDown(\"D\".charCodeAt(0)))){ x -= 10; }\r\n  if(keyIsDown(RIGHT_ARROW)&&(keyIsDown(\"D\".charCodeAt(0)))){ x += 10; }\r\n\r\n\r\n  // BLANK[2] 重力とジャンプ\r\n  if(keyIsDown(\" \".charCodeAt(0))&&(y == groundY)){\r\n    // ジャンプ処理（例: y方向の速度(vy)を上向き（負の値）に設定する）\r\n    vy = -15; // 例として-15を設定\r\n  } // スペースキーでジャンプ\r\n\r\n\r\n  // 速くなりすぎないように制限\r\n  vx = constrain(vx, -20, 20);\r\n  vy = constrain(vy, -20, 20);\r\n\r\n  // 位置を更新\r\n  x += vx;\r\n  y += vy;\r\n\r\n  // キャラクターを描く\r\n  fill(0);\r\n  ellipse(x, y, size, size);\r\n}"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "11/11/2025, 3:31:05 AM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// 2D アニメーションゲームのようなインタラクション\r\nlet x, y;\r\nlet vx, vy;\r\nconst g = 1; //重力\r\nconst vyMax = 20;\r\n\r\nfunction setup(){\r\n  createCanvas(windowWidth, windowHeight);\r\n  x = width / 2;\r\n  y = groundY - (charSize / 2);\r\n  vx = 0;\r\n  vy = 0;\r\n}\r\n\r\nfunction windowResized(){\r\n  resizeCanvas(windowWidth, windowHeight);\r\n}\r\n\r\nfunction draw(){\r\n  background(160, 192, 255);\r\n  const size = height * 0.1; // キャラクターのサイズ\r\n  const charSIze  = height * 0.1;\r\n\r\n  // 地面を描く\r\n  const groundY = height * 0.8;\r\n  fill(64, 192, 64);\r\n  rect(0, groundY, width, height - groundY);\r\n\r\n  // BLANK[1] キャラクターの左右移動\r\n  ellipse(x, y, 50);\r\n  // キーの処理（else ifにすると同時押しできなくなってしまうので要注意）\r\n  if(keyIsDown(LEFT_ARROW)){ x -= 5; }\r\n  if(keyIsDown(RIGHT_ARROW)){ x += 5; }\r\n  if(keyIsDown(LEFT_ARROW)&&(keyIsDown(\"D\".charCodeAt(0)))){ x -= 10; }\r\n  if(keyIsDown(RIGHT_ARROW)&&(keyIsDown(\"D\".charCodeAt(0)))){ x += 10; }\r\n\r\n\r\n  // BLANK[2] 重力とジャンプ\r\n  if(keyIsDown(\" \".charCodeAt(0))&&(y == groundY)){\r\n    // ジャンプ処理（例: y方向の速度(vy)を上向き（負の値）に設定する）\r\n    vy = -15; // 例として-15を設定\r\n  } // スペースキーでジャンプ\r\n\r\n\r\n  // 速くなりすぎないように制限\r\n  vx = constrain(vx, -20, 20);\r\n  vy = constrain(vy, -20, 20);\r\n\r\n  // 位置を更新\r\n  x += vx;\r\n  y += vy;\r\n\r\n  // キャラクターを描く\r\n  fill(0);\r\n  ellipse(x, y, size, size);\r\n}"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "11/11/2025, 3:31:45 AM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// 2D アニメーションゲームのようなインタラクション\r\nlet x, y;\r\nlet vx, vy;\r\nconst g = 1; //重力\r\nconst vyMax = 20;\r\n\r\nfunction setup(){\r\n  createCanvas(windowWidth, windowHeight);\r\n  x = width / 2;\r\n  const charSize  = height * 0.1;\r\n  y = groundY - (charSize / 2);\r\n  vx = 0;\r\n  vy = 0;\r\n}\r\n\r\nfunction windowResized(){\r\n  resizeCanvas(windowWidth, windowHeight);\r\n}\r\n\r\nfunction draw(){\r\n  background(160, 192, 255);\r\n  const size = height * 0.1; // キャラクターのサイズ\r\n\r\n  // 地面を描く\r\n  const groundY = height * 0.8;\r\n  fill(64, 192, 64);\r\n  rect(0, groundY, width, height - groundY);\r\n\r\n  // BLANK[1] キャラクターの左右移動\r\n  ellipse(x, y, 50);\r\n  // キーの処理（else ifにすると同時押しできなくなってしまうので要注意）\r\n  if(keyIsDown(LEFT_ARROW)){ x -= 5; }\r\n  if(keyIsDown(RIGHT_ARROW)){ x += 5; }\r\n  if(keyIsDown(LEFT_ARROW)&&(keyIsDown(\"D\".charCodeAt(0)))){ x -= 10; }\r\n  if(keyIsDown(RIGHT_ARROW)&&(keyIsDown(\"D\".charCodeAt(0)))){ x += 10; }\r\n\r\n\r\n  // BLANK[2] 重力とジャンプ\r\n  if(keyIsDown(\" \".charCodeAt(0))&&(y == groundY)){\r\n    // ジャンプ処理（例: y方向の速度(vy)を上向き（負の値）に設定する）\r\n    vy = -15; // 例として-15を設定\r\n  } // スペースキーでジャンプ\r\n\r\n\r\n  // 速くなりすぎないように制限\r\n  vx = constrain(vx, -20, 20);\r\n  vy = constrain(vy, -20, 20);\r\n\r\n  // 位置を更新\r\n  x += vx;\r\n  y += vy;\r\n\r\n  // キャラクターを描く\r\n  fill(0);\r\n  ellipse(x, y, size, size);\r\n}"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "11/11/2025, 3:36:21 AM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// 2D アニメーションゲームのようなインタラクション\r\nlet x, y;\r\nlet vx, vy;\r\nconst g = 1; //重力\r\nconst vyMax = 20;\r\n\r\nfunction setup(){\r\n  createCanvas(windowWidth, windowHeight);\r\n\r\n  // 地面を描く\r\n  const groundY = height * 0.8;\r\n  fill(64, 192, 64);\r\n  rect(0, groundY, width, height - groundY);\r\n  \r\n  const charSize  = height * 0.1;\r\n  \r\n  x = width / 2;\r\n  //地面の位置（groundY）から半径分（charSize / 2）上に設定\r\n  y = groundY - (charSize / 2); // これで地面スタート\r\n  vx = 0;\r\n  vy = 0;\r\n}\r\n\r\nfunction windowResized(){\r\n  resizeCanvas(windowWidth, windowHeight);\r\n}\r\n\r\nfunction draw(){\r\n  background(160, 192, 255);\r\n  const size = height * 0.1; // キャラクターのサイズ\r\n\r\n  // BLANK[1] キャラクターの左右移動\r\n  ellipse(x, y, 50);\r\n  // キーの処理（else ifにすると同時押しできなくなってしまうので要注意）\r\n  if(keyIsDown(LEFT_ARROW)){ x -= 5; }\r\n  if(keyIsDown(RIGHT_ARROW)){ x += 5; }\r\n  if(keyIsDown(LEFT_ARROW)&&(keyIsDown(\"D\".charCodeAt(0)))){ x -= 10; }\r\n  if(keyIsDown(RIGHT_ARROW)&&(keyIsDown(\"D\".charCodeAt(0)))){ x += 10; }\r\n\r\n\r\n  // BLANK[2] 重力とジャンプ\r\n  if(keyIsDown(\" \".charCodeAt(0))&&(y == groundY)){\r\n    // ジャンプ処理（例: y方向の速度(vy)を上向き（負の値）に設定する）\r\n    vy = -15; // 例として-15を設定\r\n  } // スペースキーでジャンプ\r\n\r\n\r\n  // 速くなりすぎないように制限\r\n  vx = constrain(vx, -20, 20);\r\n  vy = constrain(vy, -20, 20);\r\n\r\n  // 位置を更新\r\n  x += vx;\r\n  y += vy;\r\n\r\n  // キャラクターを描く\r\n  fill(0);\r\n  ellipse(x, y, size, size);\r\n}"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "11/11/2025, 3:37:11 AM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// 2D アニメーションゲームのようなインタラクション\r\nlet x, y;\r\nlet vx, vy;\r\nconst g = 1; //重力\r\nconst vyMax = 20;\r\n\r\nfunction setup(){\r\n  createCanvas(windowWidth, windowHeight);\r\n\r\n\r\n  const groundY = height * 0.8;\r\n \r\n  const charSize  = height * 0.1;\r\n  \r\n  x = width / 2;\r\n  //地面の位置（groundY）から半径分（charSize / 2）上に設定\r\n  y = groundY - (charSize / 2); // これで地面スタート\r\n  vx = 0;\r\n  vy = 0;\r\n}\r\n\r\nfunction windowResized(){\r\n  resizeCanvas(windowWidth, windowHeight);\r\n}\r\n\r\nfunction draw(){\r\n  background(160, 192, 255);\r\n  const size = height * 0.1; // キャラクターのサイズ\r\n\r\n\r\n  // 地面を描く\r\n  fill(64, 192, 64);\r\n  rect(0, groundY, width, height - groundY);\r\n\r\n  // BLANK[1] キャラクターの左右移動\r\n  ellipse(x, y, 50);\r\n  // キーの処理（else ifにすると同時押しできなくなってしまうので要注意）\r\n  if(keyIsDown(LEFT_ARROW)){ x -= 5; }\r\n  if(keyIsDown(RIGHT_ARROW)){ x += 5; }\r\n  if(keyIsDown(LEFT_ARROW)&&(keyIsDown(\"D\".charCodeAt(0)))){ x -= 10; }\r\n  if(keyIsDown(RIGHT_ARROW)&&(keyIsDown(\"D\".charCodeAt(0)))){ x += 10; }\r\n\r\n\r\n  // BLANK[2] 重力とジャンプ\r\n  if(keyIsDown(\" \".charCodeAt(0))&&(y == groundY)){\r\n    // ジャンプ処理（例: y方向の速度(vy)を上向き（負の値）に設定する）\r\n    vy = -15; // 例として-15を設定\r\n  } // スペースキーでジャンプ\r\n\r\n\r\n  // 速くなりすぎないように制限\r\n  vx = constrain(vx, -20, 20);\r\n  vy = constrain(vy, -20, 20);\r\n\r\n  // 位置を更新\r\n  x += vx;\r\n  y += vy;\r\n\r\n  // キャラクターを描く\r\n  fill(0);\r\n  ellipse(x, y, size, size);\r\n}"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "11/11/2025, 3:46:41 AM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// 2D アニメーションゲームのようなインタラクション\r\nlet x, y;\r\nlet vx, vy;\r\nconst g = 1; //重力\r\nconst vyMax = 20;\r\n\r\nfunction setup(){\r\n  createCanvas(windowWidth, windowHeight);\r\n\r\n  // setup()内で地面の位置とキャラクターのサイズを計算し、初期位置を設定\r\n  const groundY = height * 0.8;\r\n  const charSize  = height * 0.1;\r\n  \r\n  x = width / 2;\r\n  //地面の位置（groundY）から半径分（charSize / 2）上に設定\r\n  y = groundY - (charSize / 2); // これで地面スタート\r\n  vx = 0;\r\n  vy = 0;\r\n}\r\n\r\nfunction windowResized(){\r\n  resizeCanvas(windowWidth, windowHeight);\r\n}\r\n\r\nfunction draw(){\r\n  background(160, 192, 255);\r\n  const size = height * 0.1; // キャラクターのサイズ\r\n  const groundY = height * 0.8; // 地面を描く前に定義\r\n\r\n  // 地面を描く\r\n  fill(64, 192, 64);\r\n  rect(0, groundY, width, height - groundY);\r\n\r\n  // BLANK[1] キャラクターの左右移動\r\n  ellipse(x, y, 50);\r\n  // キーの処理（else ifにすると同時押しできなくなってしまうので要注意）\r\n  if(keyIsDown(LEFT_ARROW)){ x -= 5; }\r\n  if(keyIsDown(RIGHT_ARROW)){ x += 5; }\r\n  //加速処理\r\n  if(keyIsDown(LEFT_ARROW)&&(keyIsDown(\"D\".charCodeAt(0)))){ x -= 10; }\r\n  if(keyIsDown(RIGHT_ARROW)&&(keyIsDown(\"D\".charCodeAt(0)))){ x += 10; }\r\n\r\n\r\n\r\n  // BLANK[2] 重力とジャンプ\r\n  // 重力適用\r\n  vy += g;\r\n  \r\n  // BLANK ジャンプ処理 (空中ジャンプ不可)\r\n  // 接地している円の中心Y座標を計算\r\n  const minJumpY = groundY - (size / 2); \r\n\r\n  // スペースキーが押され、かつY座標が地面の位置(minJumpY)以上である場合にジャンプ\r\n  if(keyIsDown(\" \".charCodeAt(0))&&(y >= minJumpY)){\r\n    // ジャンプ処理（例: y方向の速度(vy)を上向き（負の値）に設定する）\r\n    vy = -15; // 例として-15を設定\r\n  }\r\n\r\n  // 速くなりすぎないように制限\r\n  vx = constrain(vx, -vyMax, vyMax);\r\n  vy = constrain(vy, -vyMax, vyMax);\r\n\r\n  // 位置を更新\r\n  x += vx;\r\n  y += vy;\r\n\r\n  // キャラクターを描く\r\n  fill(0);\r\n  // 注: 元のコードにあったellipse(x, y, 50)は削除し、サイズが可変のellipse(x, y, size, size)に統一\r\n  ellipse(x, y, size, size);\r\n}"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "11/11/2025, 3:50:54 AM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// 2D アニメーションゲームのようなインタラクション\r\nlet x, y;\r\nlet vx, vy;\r\nconst g = 1; //重力\r\nconst vyMax = 20;\r\n\r\nfunction setup(){\r\n  createCanvas(windowWidth, windowHeight);\r\n\r\n  // setup()内で地面の位置とキャラクターのサイズを計算し、初期位置を設定\r\n  const groundY = height * 0.8;\r\n  const charSize  = height * 0.1;\r\n  \r\n  x = width / 2;\r\n  //地面の位置（groundY）から半径分（charSize / 2）上に設定\r\n  y = groundY - (charSize / 2); // これで地面スタート\r\n  vx = 0;\r\n  vy = 0;\r\n}\r\n\r\nfunction windowResized(){\r\n  resizeCanvas(windowWidth, windowHeight);\r\n}\r\n\r\nfunction draw(){\r\n  background(160, 192, 255);\r\n  const size = height * 0.1; // キャラクターのサイズ\r\n  const groundY = height * 0.8; // 地面を描く前に定義\r\n\r\n  // 地面を描く\r\n  fill(64, 192, 64);\r\n  rect(0, groundY, width, height - groundY);\r\n\r\n  // BLANK[1] キャラクターの左右移動\r\n  ellipse(x, y, 50);\r\n  // キーの処理（else ifにすると同時押しできなくなってしまうので要注意）\r\n  if(keyIsDown(LEFT_ARROW)){ x -= 5; }\r\n  if(keyIsDown(RIGHT_ARROW)){ x += 5; }\r\n  //加速処理\r\n  if(keyIsDown(LEFT_ARROW)&&(keyIsDown(\"D\".charCodeAt(0)))){ x -= 10; }\r\n  if(keyIsDown(RIGHT_ARROW)&&(keyIsDown(\"D\".charCodeAt(0)))){ x += 10; }\r\n\r\n\r\n\r\n  // BLANK[2] 重力とジャンプ\r\n  // 重力適用\r\n  vy += g;\r\n  \r\n  // BLANK ジャンプ処理 (空中ジャンプ不可)\r\n  // 接地している円の中心Y座標を計算\r\n  const minJumpY = groundY - (size / 2); \r\n\r\n  // スペースキーが押され、かつY座標が地面の位置(minJumpY)以上である場合にジャンプ\r\n  if(keyIsDown(\" \".charCodeAt(0))&&(y >= minJumpY)){\r\n    // ジャンプ処理（例: y方向の速度(vy)を上向き（負の値）に設定する）\r\n    vy = -15; // 例として-15を設定\r\n  }\r\n\r\n  // 速くなりすぎないように制限\r\n  vx = constrain(vx, -vyMax, vyMax);\r\n  vy = constrain(vy, -vyMax, vyMax);\r\n\r\n  // 位置を更新\r\n  x += vx;\r\n  y += vy;\r\n\r\n\r\n\r\n  // 地面との衝突判定と位置の強制補正 (めり込み防止) [1]\r\n  if (y > minJumpY) {\r\n      y = minJumpY; // 位置を地面の境界に強制的に戻す [1]\r\n      vy = 0; // 地面に接触したら速度をリセット\r\n  }\r\n\r\n  // 左右の画面端の制約 (キャラクターが画面端を突き抜けないように)\r\n  // 円の中心が画面端から半径分内側になるように制限\r\n  x = constrain(x, size / 2, width - size / 2); \r\n  \r\n\r\n\r\n  // キャラクターを描く\r\n  fill(0);\r\n  // 注: 元のコードにあったellipse(x, y, 50)は削除し、サイズが可変のellipse(x, y, size, size)に統一\r\n  ellipse(x, y, size, size);\r\n}"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "11/11/2025, 4:08:13 AM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// 2D アニメーションゲームのようなインタラクション\r\nlet x, y;\r\nlet vx, vy; // x,y座標方向に進む速度\r\nconst g = 1; //重力\r\nconst vyMax = 20; //速度の最大値\r\n\r\nfunction setup(){\r\n  createCanvas(windowWidth, windowHeight);\r\n\r\n  // setup()内で地面の位置とキャラクターのサイズを計算し、初期位置を設定\r\n  const groundY = height * 0.8;\r\n  const charSize  = height * 0.1;\r\n  \r\n  x = width / 2;\r\n  //地面の位置（groundY）から半径分（charSize / 2）上に設定\r\n  y = groundY - (charSize / 2); // これで地面スタート\r\n  vx = 0;\r\n  vy = 0;\r\n}\r\n\r\nfunction windowResized(){\r\n  resizeCanvas(windowWidth, windowHeight);\r\n}\r\n\r\nfunction draw(){\r\n  background(160, 192, 255);\r\n  const size = height * 0.1; // キャラクターのサイズ\r\n  const groundY = height * 0.8; // 地面を描く前に定義\r\n\r\n  // 地面を描く\r\n  fill(64, 192, 64);\r\n  rect(0, groundY, width, height - groundY);\r\n\r\n  // BLANK[1] キャラクターの左右移動\r\n  ellipse(x, y, 50);\r\n  // キーの処理（else ifにすると同時押しできなくなってしまうので要注意）\r\n  if(keyIsDown(LEFT_ARROW)){ x -= 5; }\r\n  if(keyIsDown(RIGHT_ARROW)){ x += 5; }\r\n  //加速処理\r\n  if(keyIsDown(LEFT_ARROW)&&(keyIsDown(\"D\".charCodeAt(0)))){ x -= 10; }\r\n  if(keyIsDown(RIGHT_ARROW)&&(keyIsDown(\"D\".charCodeAt(0)))){ x += 10; }\r\n\r\n\r\n\r\n  // BLANK[2] 重力とジャンプ\r\n  // 重力適用\r\n  vy += g; //毎フレームごとにyの速度にgが加わる\r\n  \r\n  // BLANK ジャンプ処理 (空中ジャンプ不可)\r\n  // 接地している円の中心Y座標を計算\r\n  const minJumpY = groundY - (size / 2); \r\n\r\n  // スペースキーが押され、かつY座標が地面の位置(minJumpY)以上である場合にジャンプ\r\n  if(keyIsDown(\" \".charCodeAt(0))&&(y >= minJumpY)){\r\n    // ジャンプ処理（y方向の速度(vy)を上向き（負の値）に設定する）\r\n    vy = -15; // 例として-15を設定\r\n  }\r\n\r\n  // 速くなりすぎないように制限\r\n  vx = constrain(vx, -vyMax, vyMax);\r\n  vy = constrain(vy, -vyMax, vyMax);\r\n\r\n  // 位置を更新\r\n  x += vx;\r\n  y += vy;\r\n\r\n\r\n\r\n  // 地面との衝突判定と位置の強制補正 (めり込み防止)\r\n  if (y > minJumpY) {\r\n      y = minJumpY; // 位置を地面の境界に強制的に戻す\r\n      vy = 0; // 地面に接触したら速度をリセット\r\n  }\r\n\r\n  // 左右の画面端の制約 (キャラクターが画面端を突き抜けないように)\r\n  // 円の中心が画面端から半径分内側になるように制限\r\n  x = constrain(x, size / 2, width - size / 2); //xがsize / 2, widthより左に、width - size / 2より右になるように\r\n\r\n\r\n\r\n  // キャラクターを描く\r\n  fill(0);\r\n  // 注: 元のコードにあったellipse(x, y, 50)は削除し、サイズが可変のellipse(x, y, size, size)に統一\r\n  ellipse(x, y, size, size);\r\n}"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "11/11/2025, 11:15:00 AM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// 2D アニメーションゲームのようなインタラクション\r\nlet x, y;\r\nlet vx, vy; // x,y座標方向に進む速度\r\nconst g = 1; //重力\r\nconst vyMax = 20; //速度の最大値\r\n\r\nfunction setup(){\r\n  createCanvas(windowWidth, windowHeight);\r\n\r\n  // setup()内で地面の位置とキャラクターのサイズを計算し、初期位置を設定\r\n  const groundY = height * 0.8;\r\n  const charSize  = height * 0.1;\r\n  \r\n  x = width / 2;\r\n  //地面の位置（groundY）から半径分（charSize / 2）上に設定\r\n  y = groundY - (charSize / 2); // これで地面スタート\r\n  vx = 0;\r\n  vy = 0;\r\n}\r\n\r\nfunction windowResized(){\r\n  resizeCanvas(windowWidth, windowHeight);\r\n}\r\n\r\nfunction draw(){\r\n  background(160, 192, 255);\r\n  const size = height * 0.1; // キャラクターのサイズ\r\n  const groundY = height * 0.8; // 地面を描く前に定義\r\n\r\n  // 地面を描く\r\n  fill(64, 192, 64);\r\n  rect(0, groundY, width, height - groundY);\r\n\r\n  // BLANK[1] キャラクターの左右移動\r\n  ellipse(x, y, 50);\r\n  // キーの処理（else ifにすると同時押しできなくなってしまうので要注意）\r\n  if(keyIsDown(LEFT_ARROW)){ x -= 5; }\r\n  if(keyIsDown(RIGHT_ARROW)){ x += 5; }\r\n  //加速処理\r\n  if(keyIsDown(LEFT_ARROW)&&(keyIsDown(\"D\".charCodeAt(0)))){ x -= 10; }\r\n  if(keyIsDown(RIGHT_ARROW)&&(keyIsDown(\"D\".charCodeAt(0)))){ x += 10; }\r\n\r\n\r\n\r\n  // BLANK[2] 重力とジャンプ\r\n  // 重力適用\r\n  vy += g; //毎フレームごとにyの速度にgが加わる\r\n  \r\n  // BLANK ジャンプ処理 (空中ジャンプ不可)\r\n  \r\n\r\n  // スペースキーが押され、かつY座標が地面の位置(groundY - (size / 2))以上である場合にジャンプ\r\n  if(keyIsDown(\" \".charCodeAt(0))&&(y >= groundY - (size / 2))){\r\n    // ジャンプ処理（y方向の速度(vy)を上向き（負の値）に設定する）\r\n    vy = -15; // 例として-15を設定\r\n  }\r\n\r\n  // 速くなりすぎないように制限\r\n  vx = constrain(vx, -vyMax, vyMax);\r\n  vy = constrain(vy, -vyMax, vyMax);\r\n\r\n  // 位置を更新\r\n  x += vx;\r\n  y += vy;\r\n\r\n\r\n\r\n  // 地面との衝突判定と位置の強制補正 (めり込み防止)\r\n  if (y > groundY - (size / 2)) {\r\n      y = groundY - (size / 2); // 位置を地面の境界に強制的に戻す\r\n      vy = 0; // 地面に接触したら速度をリセット\r\n  } \r\n\r\n  // 左右の画面端の制約 (キャラクターが画面端を突き抜けないように)\r\n  // 円の中心が画面端から半径分内側になるように制限\r\n  x = constrain(x, size / 2, width - size / 2); //xがsize / 2, widthより左に、width - size / 2より右になるように\r\n\r\n\r\n\r\n  // キャラクターを描く\r\n  fill(0);\r\n  // 注: 元のコードにあったellipse(x, y, 50)は削除し、サイズが可変のellipse(x, y, size, size)に統一\r\n  ellipse(x, y, size, size);\r\n}"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "11/11/2025, 11:16:24 AM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// 2D アニメーションゲームのようなインタラクション\r\nlet x, y;\r\nlet vx, vy; // x,y座標方向に進む速度\r\nconst g = 1; //重力\r\nconst vyMax = 60; //速度の最大値\r\n\r\nfunction setup(){\r\n  createCanvas(windowWidth, windowHeight);\r\n\r\n  // setup()内で地面の位置とキャラクターのサイズを計算し、初期位置を設定\r\n  const groundY = height * 0.8;\r\n  const charSize  = height * 0.1;\r\n  \r\n  x = width / 2;\r\n  //地面の位置（groundY）から半径分（charSize / 2）上に設定\r\n  y = groundY - (charSize / 2); // これで地面スタート\r\n  vx = 0;\r\n  vy = 0;\r\n}\r\n\r\nfunction windowResized(){\r\n  resizeCanvas(windowWidth, windowHeight);\r\n}\r\n\r\nfunction draw(){\r\n  background(160, 192, 255);\r\n  const size = height * 0.1; // キャラクターのサイズ\r\n  const groundY = height * 0.8; // 地面を描く前に定義\r\n\r\n  // 地面を描く\r\n  fill(64, 192, 64);\r\n  rect(0, groundY, width, height - groundY);\r\n\r\n  // BLANK[1] キャラクターの左右移動\r\n  ellipse(x, y, 50);\r\n  // キーの処理（else ifにすると同時押しできなくなってしまうので要注意）\r\n  if(keyIsDown(LEFT_ARROW)){ x -= 5; }\r\n  if(keyIsDown(RIGHT_ARROW)){ x += 5; }\r\n  //加速処理\r\n  if(keyIsDown(LEFT_ARROW)&&(keyIsDown(\"D\".charCodeAt(0)))){ x -= 10; }\r\n  if(keyIsDown(RIGHT_ARROW)&&(keyIsDown(\"D\".charCodeAt(0)))){ x += 10; }\r\n\r\n\r\n\r\n  // BLANK[2] 重力とジャンプ\r\n  // 重力適用\r\n  vy += g; //毎フレームごとにyの速度にgが加わる\r\n  \r\n  // BLANK ジャンプ処理 (空中ジャンプ不可)\r\n  \r\n\r\n  // スペースキーが押され、かつY座標が地面の位置(groundY - (size / 2))以上である場合にジャンプ\r\n  if(keyIsDown(\" \".charCodeAt(0))&&(y >= groundY - (size / 2))){\r\n    // ジャンプ処理（y方向の速度(vy)を上向き（負の値）に設定する）\r\n    vy = -15; // 例として-15を設定\r\n  }\r\n\r\n  // 速くなりすぎないように制限\r\n  vx = constrain(vx, -vyMax, vyMax);\r\n  vy = constrain(vy, -vyMax, vyMax);\r\n\r\n  // 位置を更新\r\n  x += vx;\r\n  y += vy;\r\n\r\n\r\n\r\n  // 地面との衝突判定と位置の強制補正 (めり込み防止)\r\n  if (y > groundY - (size / 2)) {\r\n      y = groundY - (size / 2); // 位置を地面の境界に強制的に戻す\r\n      vy = 0; // 地面に接触したら速度をリセット\r\n  } \r\n\r\n  // 左右の画面端の制約 (キャラクターが画面端を突き抜けないように)\r\n  // 円の中心が画面端から半径分内側になるように制限\r\n  x = constrain(x, size / 2, width - size / 2); //xがsize / 2, widthより左に、width - size / 2より右になるように\r\n\r\n\r\n\r\n  // キャラクターを描く\r\n  fill(0);\r\n  // 注: 元のコードにあったellipse(x, y, 50)は削除し、サイズが可変のellipse(x, y, size, size)に統一\r\n  ellipse(x, y, size, size);\r\n}"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "11/11/2025, 11:17:05 AM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// 2D アニメーションゲームのようなインタラクション\r\nlet x, y;\r\nlet vx, vy; // x,y座標方向に進む速度\r\nconst g = 1; //重力\r\nconst vyMax = 20; //速度の最大値\r\n\r\nfunction setup(){\r\n  createCanvas(windowWidth, windowHeight);\r\n\r\n  // setup()内で地面の位置とキャラクターのサイズを計算し、初期位置を設定\r\n  const groundY = height * 0.8;\r\n  const charSize  = height * 0.1;\r\n  \r\n  x = width / 2;\r\n  //地面の位置（groundY）から半径分（charSize / 2）上に設定\r\n  y = groundY - (charSize / 2); // これで地面スタート\r\n  vx = 0;\r\n  vy = 0;\r\n}\r\n\r\nfunction windowResized(){\r\n  resizeCanvas(windowWidth, windowHeight);\r\n}\r\n\r\nfunction draw(){\r\n  background(160, 192, 255);\r\n  const size = height * 0.1; // キャラクターのサイズ\r\n  const groundY = height * 0.8; // 地面を描く前に定義\r\n\r\n  // 地面を描く\r\n  fill(64, 192, 64);\r\n  rect(0, groundY, width, height - groundY);\r\n\r\n  // BLANK[1] キャラクターの左右移動\r\n  ellipse(x, y, 50);\r\n  // キーの処理（else ifにすると同時押しできなくなってしまうので要注意）\r\n  if(keyIsDown(LEFT_ARROW)){ x -= 5; }\r\n  if(keyIsDown(RIGHT_ARROW)){ x += 5; }\r\n  //加速処理\r\n  if(keyIsDown(LEFT_ARROW)&&(keyIsDown(\"D\".charCodeAt(0)))){ x -= 10; }\r\n  if(keyIsDown(RIGHT_ARROW)&&(keyIsDown(\"D\".charCodeAt(0)))){ x += 10; }\r\n\r\n\r\n\r\n  // BLANK[2] 重力とジャンプ\r\n  // 重力適用\r\n  vy += g; //毎フレームごとにyの速度にgが加わる\r\n  \r\n  // BLANK ジャンプ処理 (空中ジャンプ不可)\r\n  \r\n\r\n  // スペースキーが押され、かつY座標が地面の位置(groundY - (size / 2))以上である場合にジャンプ\r\n  if(keyIsDown(\" \".charCodeAt(0))&&(y >= groundY - (size / 2))){\r\n    // ジャンプ処理（y方向の速度(vy)を上向き（負の値）に設定する）\r\n    vy = -15; // 例として-15を設定\r\n  }\r\n\r\n  // 速くなりすぎないように制限\r\n  vx = constrain(vx, -vyMax, vyMax);\r\n  vy = constrain(vy, -vyMax, vyMax);\r\n\r\n  // 位置を更新\r\n  x += vx;\r\n  y += vy;\r\n\r\n\r\n\r\n  // 地面との衝突判定と位置の強制補正 (めり込み防止)\r\n  if (y > groundY - (size / 2)) {\r\n      y = groundY - (size / 2); // 位置を地面の境界に強制的に戻す\r\n      vy = 0; // 地面に接触したら速度をリセット\r\n  } \r\n\r\n  // 左右の画面端の制約 (キャラクターが画面端を突き抜けないように)\r\n  // 円の中心が画面端から半径分内側になるように制限\r\n  x = constrain(x, size / 2, width - size / 2); //xがsize / 2, widthより左に、width - size / 2より右になるように\r\n\r\n\r\n\r\n  // キャラクターを描く\r\n  fill(0);\r\n  // 注: 元のコードにあったellipse(x, y, 50)は削除し、サイズが可変のellipse(x, y, size, size)に統一\r\n  ellipse(x, y, size, size);\r\n}"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "11/11/2025, 11:18:19 AM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// 2D アニメーションゲームのようなインタラクション\r\nlet x, y;\r\nlet vx, vy; // x,y座標方向に進む速度\r\nconst g = 1; //重力\r\nconst vyMax = 20; //速度の最大値\r\n\r\nfunction setup(){\r\n  createCanvas(windowWidth, windowHeight);\r\n\r\n  // setup()内で地面の位置とキャラクターのサイズを計算し、初期位置を設定\r\n  const groundY = height * 0.8;\r\n  const charSize  = height * 0.1;\r\n  \r\n  x = width / 2;\r\n  //地面の位置（groundY）から半径分（charSize / 2）上に設定\r\n  y = groundY - (charSize / 2); // これで地面スタート\r\n  vx = 0;\r\n  vy = 0;\r\n}\r\n\r\nfunction windowResized(){\r\n  resizeCanvas(windowWidth, windowHeight);\r\n}\r\n\r\nfunction draw(){\r\n  background(160, 192, 255);\r\n  const size = height * 0.1; // キャラクターのサイズ\r\n  const groundY = height * 0.8; // 地面を描く前に定義\r\n\r\n  // 地面を描く\r\n  fill(64, 192, 64);\r\n  rect(0, groundY, width, height - groundY);\r\n\r\n  // BLANK[1] キャラクターの左右移動\r\n  ellipse(x, y, 50);\r\n  // キーの処理（else ifにすると同時押しできなくなってしまうので要注意）\r\n  if(keyIsDown(LEFT_ARROW)){ x -= 5; }\r\n  if(keyIsDown(RIGHT_ARROW)){ x += 5; }\r\n  //加速処理\r\n  if(keyIsDown(LEFT_ARROW)&&(keyIsDown(\"D\".charCodeAt(0)))){ x -= 10; }\r\n  if(keyIsDown(RIGHT_ARROW)&&(keyIsDown(\"D\".charCodeAt(0)))){ x += 10; }\r\n\r\n\r\n\r\n  // BLANK[2] 重力とジャンプ\r\n  // 重力適用\r\n  vy += g; //毎フレームごとにyの速度にgが加わる\r\n  \r\n  // BLANK ジャンプ処理 (空中ジャンプ不可)\r\n  \r\n\r\n  // スペースキーが押され、かつY座標が地面の位置(groundY - (size / 2))以上である場合にジャンプ\r\n  if(keyIsDown(\" \".charCodeAt(0))&&(y >= groundY - (size / 2))){\r\n    // ジャンプ処理（y方向の速度(vy)を上向き（負の値）に設定する）\r\n    vy = -5; // 例として-15を設定\r\n  }\r\n\r\n  // 速くなりすぎないように制限\r\n  vx = constrain(vx, -vyMax, vyMax);\r\n  vy = constrain(vy, -vyMax, vyMax);\r\n\r\n  // 位置を更新\r\n  x += vx;\r\n  y += vy;\r\n\r\n\r\n\r\n  // 地面との衝突判定と位置の強制補正 (めり込み防止)\r\n  if (y > groundY - (size / 2)) {\r\n      y = groundY - (size / 2); // 位置を地面の境界に強制的に戻す\r\n      vy = 0; // 地面に接触したら速度をリセット\r\n  } \r\n\r\n  // 左右の画面端の制約 (キャラクターが画面端を突き抜けないように)\r\n  // 円の中心が画面端から半径分内側になるように制限\r\n  x = constrain(x, size / 2, width - size / 2); //xがsize / 2, widthより左に、width - size / 2より右になるように\r\n\r\n\r\n\r\n  // キャラクターを描く\r\n  fill(0);\r\n  // 注: 元のコードにあったellipse(x, y, 50)は削除し、サイズが可変のellipse(x, y, size, size)に統一\r\n  ellipse(x, y, size, size);\r\n}"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "11/11/2025, 11:18:28 AM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// 2D アニメーションゲームのようなインタラクション\r\nlet x, y;\r\nlet vx, vy; // x,y座標方向に進む速度\r\nconst g = 1; //重力\r\nconst vyMax = 20; //速度の最大値\r\n\r\nfunction setup(){\r\n  createCanvas(windowWidth, windowHeight);\r\n\r\n  // setup()内で地面の位置とキャラクターのサイズを計算し、初期位置を設定\r\n  const groundY = height * 0.8;\r\n  const charSize  = height * 0.1;\r\n  \r\n  x = width / 2;\r\n  //地面の位置（groundY）から半径分（charSize / 2）上に設定\r\n  y = groundY - (charSize / 2); // これで地面スタート\r\n  vx = 0;\r\n  vy = 0;\r\n}\r\n\r\nfunction windowResized(){\r\n  resizeCanvas(windowWidth, windowHeight);\r\n}\r\n\r\nfunction draw(){\r\n  background(160, 192, 255);\r\n  const size = height * 0.1; // キャラクターのサイズ\r\n  const groundY = height * 0.8; // 地面を描く前に定義\r\n\r\n  // 地面を描く\r\n  fill(64, 192, 64);\r\n  rect(0, groundY, width, height - groundY);\r\n\r\n  // BLANK[1] キャラクターの左右移動\r\n  ellipse(x, y, 50);\r\n  // キーの処理（else ifにすると同時押しできなくなってしまうので要注意）\r\n  if(keyIsDown(LEFT_ARROW)){ x -= 5; }\r\n  if(keyIsDown(RIGHT_ARROW)){ x += 5; }\r\n  //加速処理\r\n  if(keyIsDown(LEFT_ARROW)&&(keyIsDown(\"D\".charCodeAt(0)))){ x -= 10; }\r\n  if(keyIsDown(RIGHT_ARROW)&&(keyIsDown(\"D\".charCodeAt(0)))){ x += 10; }\r\n\r\n\r\n\r\n  // BLANK[2] 重力とジャンプ\r\n  // 重力適用\r\n  vy += g; //毎フレームごとにyの速度にgが加わる\r\n  \r\n  // BLANK ジャンプ処理 (空中ジャンプ不可)\r\n  \r\n\r\n  // スペースキーが押され、かつY座標が地面の位置(groundY - (size / 2))以上である場合にジャンプ\r\n  if(keyIsDown(\" \".charCodeAt(0))&&(y >= groundY - (size / 2))){\r\n    // ジャンプ処理（y方向の速度(vy)を上向き（負の値）に設定する）\r\n    vy = -20; // 例として-15を設定\r\n  }\r\n\r\n  // 速くなりすぎないように制限\r\n  vx = constrain(vx, -vyMax, vyMax);\r\n  vy = constrain(vy, -vyMax, vyMax);\r\n\r\n  // 位置を更新\r\n  x += vx;\r\n  y += vy;\r\n\r\n\r\n\r\n  // 地面との衝突判定と位置の強制補正 (めり込み防止)\r\n  if (y > groundY - (size / 2)) {\r\n      y = groundY - (size / 2); // 位置を地面の境界に強制的に戻す\r\n      vy = 0; // 地面に接触したら速度をリセット\r\n  } \r\n\r\n  // 左右の画面端の制約 (キャラクターが画面端を突き抜けないように)\r\n  // 円の中心が画面端から半径分内側になるように制限\r\n  x = constrain(x, size / 2, width - size / 2); //xがsize / 2, widthより左に、width - size / 2より右になるように\r\n\r\n\r\n\r\n  // キャラクターを描く\r\n  fill(0);\r\n  // 注: 元のコードにあったellipse(x, y, 50)は削除し、サイズが可変のellipse(x, y, size, size)に統一\r\n  ellipse(x, y, size, size);\r\n}"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "11/11/2025, 11:18:37 AM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// 2D アニメーションゲームのようなインタラクション\r\nlet x, y;\r\nlet vx, vy; // x,y座標方向に進む速度\r\nconst g = 1; //重力\r\nconst vyMax = 20; //速度の最大値\r\n\r\nfunction setup(){\r\n  createCanvas(windowWidth, windowHeight);\r\n\r\n  // setup()内で地面の位置とキャラクターのサイズを計算し、初期位置を設定\r\n  const groundY = height * 0.8;\r\n  const charSize  = height * 0.1;\r\n  \r\n  x = width / 2;\r\n  //地面の位置（groundY）から半径分（charSize / 2）上に設定\r\n  y = groundY - (charSize / 2); // これで地面スタート\r\n  vx = 0;\r\n  vy = 0;\r\n}\r\n\r\nfunction windowResized(){\r\n  resizeCanvas(windowWidth, windowHeight);\r\n}\r\n\r\nfunction draw(){\r\n  background(160, 192, 255);\r\n  const size = height * 0.1; // キャラクターのサイズ\r\n  const groundY = height * 0.8; // 地面を描く前に定義\r\n\r\n  // 地面を描く\r\n  fill(64, 192, 64);\r\n  rect(0, groundY, width, height - groundY);\r\n\r\n  // BLANK[1] キャラクターの左右移動\r\n  ellipse(x, y, 50);\r\n  // キーの処理（else ifにすると同時押しできなくなってしまうので要注意）\r\n  if(keyIsDown(LEFT_ARROW)){ x -= 5; }\r\n  if(keyIsDown(RIGHT_ARROW)){ x += 5; }\r\n  //加速処理\r\n  if(keyIsDown(LEFT_ARROW)&&(keyIsDown(\"D\".charCodeAt(0)))){ x -= 10; }\r\n  if(keyIsDown(RIGHT_ARROW)&&(keyIsDown(\"D\".charCodeAt(0)))){ x += 10; }\r\n\r\n\r\n\r\n  // BLANK[2] 重力とジャンプ\r\n  // 重力適用\r\n  vy += g; //毎フレームごとにyの速度にgが加わる\r\n  \r\n  // BLANK ジャンプ処理 (空中ジャンプ不可)\r\n  \r\n\r\n  // スペースキーが押され、かつY座標が地面の位置(groundY - (size / 2))以上である場合にジャンプ\r\n  if(keyIsDown(\" \".charCodeAt(0))&&(y >= groundY - (size / 2))){\r\n    // ジャンプ処理（y方向の速度(vy)を上向き（負の値）に設定する）\r\n    vy = -30; // 例として-15を設定\r\n  }\r\n\r\n  // 速くなりすぎないように制限\r\n  vx = constrain(vx, -vyMax, vyMax);\r\n  vy = constrain(vy, -vyMax, vyMax);\r\n\r\n  // 位置を更新\r\n  x += vx;\r\n  y += vy;\r\n\r\n\r\n\r\n  // 地面との衝突判定と位置の強制補正 (めり込み防止)\r\n  if (y > groundY - (size / 2)) {\r\n      y = groundY - (size / 2); // 位置を地面の境界に強制的に戻す\r\n      vy = 0; // 地面に接触したら速度をリセット\r\n  } \r\n\r\n  // 左右の画面端の制約 (キャラクターが画面端を突き抜けないように)\r\n  // 円の中心が画面端から半径分内側になるように制限\r\n  x = constrain(x, size / 2, width - size / 2); //xがsize / 2, widthより左に、width - size / 2より右になるように\r\n\r\n\r\n\r\n  // キャラクターを描く\r\n  fill(0);\r\n  // 注: 元のコードにあったellipse(x, y, 50)は削除し、サイズが可変のellipse(x, y, size, size)に統一\r\n  ellipse(x, y, size, size);\r\n}"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "11/11/2025, 11:18:46 AM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// 2D アニメーションゲームのようなインタラクション\r\nlet x, y;\r\nlet vx, vy; // x,y座標方向に進む速度\r\nconst g = 1; //重力\r\nconst vyMax = 30; //速度の最大値\r\n\r\nfunction setup(){\r\n  createCanvas(windowWidth, windowHeight);\r\n\r\n  // setup()内で地面の位置とキャラクターのサイズを計算し、初期位置を設定\r\n  const groundY = height * 0.8;\r\n  const charSize  = height * 0.1;\r\n  \r\n  x = width / 2;\r\n  //地面の位置（groundY）から半径分（charSize / 2）上に設定\r\n  y = groundY - (charSize / 2); // これで地面スタート\r\n  vx = 0;\r\n  vy = 0;\r\n}\r\n\r\nfunction windowResized(){\r\n  resizeCanvas(windowWidth, windowHeight);\r\n}\r\n\r\nfunction draw(){\r\n  background(160, 192, 255);\r\n  const size = height * 0.1; // キャラクターのサイズ\r\n  const groundY = height * 0.8; // 地面を描く前に定義\r\n\r\n  // 地面を描く\r\n  fill(64, 192, 64);\r\n  rect(0, groundY, width, height - groundY);\r\n\r\n  // BLANK[1] キャラクターの左右移動\r\n  ellipse(x, y, 50);\r\n  // キーの処理（else ifにすると同時押しできなくなってしまうので要注意）\r\n  if(keyIsDown(LEFT_ARROW)){ x -= 5; }\r\n  if(keyIsDown(RIGHT_ARROW)){ x += 5; }\r\n  //加速処理\r\n  if(keyIsDown(LEFT_ARROW)&&(keyIsDown(\"D\".charCodeAt(0)))){ x -= 10; }\r\n  if(keyIsDown(RIGHT_ARROW)&&(keyIsDown(\"D\".charCodeAt(0)))){ x += 10; }\r\n\r\n\r\n\r\n  // BLANK[2] 重力とジャンプ\r\n  // 重力適用\r\n  vy += g; //毎フレームごとにyの速度にgが加わる\r\n  \r\n  // BLANK ジャンプ処理 (空中ジャンプ不可)\r\n  \r\n\r\n  // スペースキーが押され、かつY座標が地面の位置(groundY - (size / 2))以上である場合にジャンプ\r\n  if(keyIsDown(\" \".charCodeAt(0))&&(y >= groundY - (size / 2))){\r\n    // ジャンプ処理（y方向の速度(vy)を上向き（負の値）に設定する）\r\n    vy = -30; // 例として-15を設定\r\n  }\r\n\r\n  // 速くなりすぎないように制限\r\n  vx = constrain(vx, -vyMax, vyMax);\r\n  vy = constrain(vy, -vyMax, vyMax);\r\n\r\n  // 位置を更新\r\n  x += vx;\r\n  y += vy;\r\n\r\n\r\n\r\n  // 地面との衝突判定と位置の強制補正 (めり込み防止)\r\n  if (y > groundY - (size / 2)) {\r\n      y = groundY - (size / 2); // 位置を地面の境界に強制的に戻す\r\n      vy = 0; // 地面に接触したら速度をリセット\r\n  } \r\n\r\n  // 左右の画面端の制約 (キャラクターが画面端を突き抜けないように)\r\n  // 円の中心が画面端から半径分内側になるように制限\r\n  x = constrain(x, size / 2, width - size / 2); //xがsize / 2, widthより左に、width - size / 2より右になるように\r\n\r\n\r\n\r\n  // キャラクターを描く\r\n  fill(0);\r\n  // 注: 元のコードにあったellipse(x, y, 50)は削除し、サイズが可変のellipse(x, y, size, size)に統一\r\n  ellipse(x, y, size, size);\r\n}"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "11/11/2025, 11:20:13 AM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// 2D アニメーションゲームのようなインタラクション\r\nlet x, y;\r\nlet vx, vy; // x,y座標方向に進む速度\r\nconst g = 1; //重力\r\nconst vyMax = 40; //速度の最大値\r\n\r\nfunction setup(){\r\n  createCanvas(windowWidth, windowHeight);\r\n\r\n  // setup()内で地面の位置とキャラクターのサイズを計算し、初期位置を設定\r\n  const groundY = height * 0.8;\r\n  const charSize  = height * 0.1;\r\n  \r\n  x = width / 2;\r\n  //地面の位置（groundY）から半径分（charSize / 2）上に設定\r\n  y = groundY - (charSize / 2); // これで地面スタート\r\n  vx = 0;\r\n  vy = 0;\r\n}\r\n\r\nfunction windowResized(){\r\n  resizeCanvas(windowWidth, windowHeight);\r\n}\r\n\r\nfunction draw(){\r\n  background(160, 192, 255);\r\n  const size = height * 0.1; // キャラクターのサイズ\r\n  const groundY = height * 0.8; // 地面を描く前に定義\r\n\r\n  // 地面を描く\r\n  fill(64, 192, 64);\r\n  rect(0, groundY, width, height - groundY);\r\n\r\n  // BLANK[1] キャラクターの左右移動\r\n  ellipse(x, y, 50);\r\n  // キーの処理（else ifにすると同時押しできなくなってしまうので要注意）\r\n  if(keyIsDown(LEFT_ARROW)){ x -= 5; }\r\n  if(keyIsDown(RIGHT_ARROW)){ x += 5; }\r\n  //加速処理\r\n  if(keyIsDown(LEFT_ARROW)&&(keyIsDown(\"D\".charCodeAt(0)))){ x -= 10; }\r\n  if(keyIsDown(RIGHT_ARROW)&&(keyIsDown(\"D\".charCodeAt(0)))){ x += 10; }\r\n\r\n\r\n\r\n  // BLANK[2] 重力とジャンプ\r\n  // 重力適用\r\n  vy += g; //毎フレームごとにyの速度にgが加わる\r\n  \r\n  // BLANK ジャンプ処理 (空中ジャンプ不可)\r\n  \r\n\r\n  // スペースキーが押され、かつY座標が地面の位置(groundY - (size / 2))以上である場合にジャンプ\r\n  if(keyIsDown(\" \".charCodeAt(0))&&(y >= groundY - (size / 2))){\r\n    // ジャンプ処理（y方向の速度(vy)を上向き（負の値）に設定する）\r\n    vy = -30; // 例として-15を設定\r\n  }\r\n\r\n  // 速くなりすぎないように制限\r\n  vx = constrain(vx, -vyMax, vyMax);\r\n  vy = constrain(vy, -vyMax, vyMax);\r\n\r\n  // 位置を更新\r\n  x += vx;\r\n  y += vy;\r\n\r\n\r\n\r\n  // 地面との衝突判定と位置の強制補正 (めり込み防止)\r\n  if (y > groundY - (size / 2)) {\r\n      y = groundY - (size / 2); // 位置を地面の境界に強制的に戻す\r\n      vy = 0; // 地面に接触したら速度をリセット\r\n  } \r\n\r\n  // 左右の画面端の制約 (キャラクターが画面端を突き抜けないように)\r\n  // 円の中心が画面端から半径分内側になるように制限\r\n  x = constrain(x, size / 2, width - size / 2); //xがsize / 2, widthより左に、width - size / 2より右になるように\r\n\r\n\r\n\r\n  // キャラクターを描く\r\n  fill(0);\r\n  // 注: 元のコードにあったellipse(x, y, 50)は削除し、サイズが可変のellipse(x, y, size, size)に統一\r\n  ellipse(x, y, size, size);\r\n}"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "11/11/2025, 11:20:48 AM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// 2D アニメーションゲームのようなインタラクション\r\nlet x, y;\r\nlet vx, vy; // x,y座標方向に進む速度\r\nconst g = 1; //重力\r\nconst vyMax = 40; //速度の最大値\r\n\r\nfunction setup(){\r\n  createCanvas(windowWidth, windowHeight);\r\n\r\n  // setup()内で地面の位置とキャラクターのサイズを計算し、初期位置を設定\r\n  const groundY = height * 0.8;\r\n  const charSize  = height * 0.1;\r\n  \r\n  x = width / 2;\r\n  //地面の位置（groundY）から半径分（charSize / 2）上に設定\r\n  y = groundY - (charSize / 2); // これで地面スタート\r\n  vx = 0;\r\n  vy = 0;\r\n}\r\n\r\nfunction windowResized(){\r\n  resizeCanvas(windowWidth, windowHeight);\r\n}\r\n\r\nfunction draw(){\r\n  background(160, 192, 255);\r\n  const size = height * 0.1; // キャラクターのサイズ\r\n  const groundY = height * 0.8; // 地面を描く前に定義\r\n\r\n  // 地面を描く\r\n  fill(64, 192, 64);\r\n  rect(0, groundY, width, height - groundY);\r\n\r\n  // BLANK[1] キャラクターの左右移動\r\n  ellipse(x, y, 50);\r\n  // キーの処理（else ifにすると同時押しできなくなってしまうので要注意）\r\n  if(keyIsDown(LEFT_ARROW)){ x -= 5; }\r\n  if(keyIsDown(RIGHT_ARROW)){ x += 5; }\r\n  //加速処理\r\n  if(keyIsDown(LEFT_ARROW)&&(keyIsDown(\"D\".charCodeAt(0)))){ x -= 10; }\r\n  if(keyIsDown(RIGHT_ARROW)&&(keyIsDown(\"D\".charCodeAt(0)))){ x += 10; }\r\n\r\n\r\n\r\n  // BLANK[2] 重力とジャンプ\r\n  // 重力適用\r\n  vy += g; //毎フレームごとにyの速度にgが加わる\r\n  \r\n  // BLANK ジャンプ処理 (空中ジャンプ不可)\r\n  \r\n\r\n  // スペースキーが押され、かつY座標が地面の位置(groundY - (size / 2))以上である場合にジャンプ\r\n  if(keyIsDown(\" \".charCodeAt(0))&&(y >= groundY - (size / 2))){\r\n    // ジャンプ処理（y方向の速度(vy)を上向き（負の値）に設定する）\r\n    vy = -40; // 例として-15を設定\r\n  }\r\n\r\n  // 速くなりすぎないように制限\r\n  vx = constrain(vx, -vyMax, vyMax);\r\n  vy = constrain(vy, -vyMax, vyMax);\r\n\r\n  // 位置を更新\r\n  x += vx;\r\n  y += vy;\r\n\r\n\r\n\r\n  // 地面との衝突判定と位置の強制補正 (めり込み防止)\r\n  if (y > groundY - (size / 2)) {\r\n      y = groundY - (size / 2); // 位置を地面の境界に強制的に戻す\r\n      vy = 0; // 地面に接触したら速度をリセット\r\n  } \r\n\r\n  // 左右の画面端の制約 (キャラクターが画面端を突き抜けないように)\r\n  // 円の中心が画面端から半径分内側になるように制限\r\n  x = constrain(x, size / 2, width - size / 2); //xがsize / 2, widthより左に、width - size / 2より右になるように\r\n\r\n\r\n\r\n  // キャラクターを描く\r\n  fill(0);\r\n  // 注: 元のコードにあったellipse(x, y, 50)は削除し、サイズが可変のellipse(x, y, size, size)に統一\r\n  ellipse(x, y, size, size);\r\n}"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "11/11/2025, 11:22:59 AM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// 2D アニメーションゲームのようなインタラクション\r\nlet x, y;\r\nlet vx, vy; // x,y座標方向に進む速度\r\nconst g = 1; //重力\r\nconst vyMax = 20; //速度の最大値\r\n\r\nfunction setup(){\r\n  createCanvas(windowWidth, windowHeight);\r\n\r\n  // setup()内で地面の位置とキャラクターのサイズを計算し、初期位置を設定\r\n  const groundY = height * 0.8;\r\n  const charSize  = height * 0.1;\r\n  \r\n  x = width / 2;\r\n  //地面の位置（groundY）から半径分（charSize / 2）上に設定\r\n  y = groundY - (charSize / 2); // これで地面スタート\r\n  vx = 0;\r\n  vy = 0;\r\n}\r\n\r\nfunction windowResized(){\r\n  resizeCanvas(windowWidth, windowHeight);\r\n}\r\n\r\nfunction draw(){\r\n  background(160, 192, 255);\r\n  const size = height * 0.1; // キャラクターのサイズ\r\n  const groundY = height * 0.8; // 地面を描く前に定義\r\n\r\n  // 地面を描く\r\n  fill(64, 192, 64);\r\n  rect(0, groundY, width, height - groundY);\r\n\r\n  // BLANK[1] キャラクターの左右移動\r\n  ellipse(x, y, 50);\r\n  // キーの処理（else ifにすると同時押しできなくなってしまうので要注意）\r\n  if(keyIsDown(LEFT_ARROW)){ x -= 5; }\r\n  if(keyIsDown(RIGHT_ARROW)){ x += 5; }\r\n  //加速処理\r\n  if(keyIsDown(LEFT_ARROW)&&(keyIsDown(\"D\".charCodeAt(0)))){ x -= 10; }\r\n  if(keyIsDown(RIGHT_ARROW)&&(keyIsDown(\"D\".charCodeAt(0)))){ x += 10; }\r\n\r\n\r\n\r\n  // BLANK[2] 重力とジャンプ\r\n  // 重力適用\r\n  vy += g; //毎フレームごとにyの速度にgが加わる\r\n  \r\n  // BLANK ジャンプ処理 (空中ジャンプ不可)\r\n  \r\n\r\n  // スペースキーが押され、かつY座標が地面の位置(groundY - (size / 2))以上である場合にジャンプ\r\n  if(keyIsDown(\" \".charCodeAt(0))&&(y >= groundY - (size / 2))){\r\n    // ジャンプ処理（y方向の速度(vy)を上向き（負の値）に設定する）\r\n    vy = -40; // 例として-15を設定\r\n  }\r\n\r\n  // 速くなりすぎないように制限\r\n  vx = constrain(vx, -vyMax, vyMax);\r\n  vy = constrain(vy, -vyMax, vyMax);\r\n\r\n  // 位置を更新\r\n  x += vx;\r\n  y += vy;\r\n\r\n\r\n\r\n  // 地面との衝突判定と位置の強制補正 (めり込み防止)\r\n  if (y > groundY - (size / 2)) {\r\n      y = groundY - (size / 2); // 位置を地面の境界に強制的に戻す\r\n      vy = 0; // 地面に接触したら速度をリセット\r\n  } \r\n\r\n  // 左右の画面端の制約 (キャラクターが画面端を突き抜けないように)\r\n  // 円の中心が画面端から半径分内側になるように制限\r\n  x = constrain(x, size / 2, width - size / 2); //xがsize / 2, widthより左に、width - size / 2より右になるように\r\n\r\n\r\n\r\n  // キャラクターを描く\r\n  fill(0);\r\n  // 注: 元のコードにあったellipse(x, y, 50)は削除し、サイズが可変のellipse(x, y, size, size)に統一\r\n  ellipse(x, y, size, size);\r\n}"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "11/11/2025, 11:23:10 AM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// 2D アニメーションゲームのようなインタラクション\r\nlet x, y;\r\nlet vx, vy; // x,y座標方向に進む速度\r\nconst g = 1; //重力\r\nconst vyMax = 20; //速度の最大値\r\n\r\nfunction setup(){\r\n  createCanvas(windowWidth, windowHeight);\r\n\r\n  // setup()内で地面の位置とキャラクターのサイズを計算し、初期位置を設定\r\n  const groundY = height * 0.8;\r\n  const charSize  = height * 0.1;\r\n  \r\n  x = width / 2;\r\n  //地面の位置（groundY）から半径分（charSize / 2）上に設定\r\n  y = groundY - (charSize / 2); // これで地面スタート\r\n  vx = 0;\r\n  vy = 0;\r\n}\r\n\r\nfunction windowResized(){\r\n  resizeCanvas(windowWidth, windowHeight);\r\n}\r\n\r\nfunction draw(){\r\n  background(160, 192, 255);\r\n  const size = height * 0.1; // キャラクターのサイズ\r\n  const groundY = height * 0.8; // 地面を描く前に定義\r\n\r\n  // 地面を描く\r\n  fill(64, 192, 64);\r\n  rect(0, groundY, width, height - groundY);\r\n\r\n  // BLANK[1] キャラクターの左右移動\r\n  ellipse(x, y, 50);\r\n  // キーの処理（else ifにすると同時押しできなくなってしまうので要注意）\r\n  if(keyIsDown(LEFT_ARROW)){ x -= 5; }\r\n  if(keyIsDown(RIGHT_ARROW)){ x += 5; }\r\n  //加速処理\r\n  if(keyIsDown(LEFT_ARROW)&&(keyIsDown(\"D\".charCodeAt(0)))){ x -= 10; }\r\n  if(keyIsDown(RIGHT_ARROW)&&(keyIsDown(\"D\".charCodeAt(0)))){ x += 10; }\r\n\r\n\r\n\r\n  // BLANK[2] 重力とジャンプ\r\n  // 重力適用\r\n  vy += g; //毎フレームごとにyの速度にgが加わる\r\n  \r\n  // BLANK ジャンプ処理 (空中ジャンプ不可)\r\n  \r\n\r\n  // スペースキーが押され、かつY座標が地面の位置(groundY - (size / 2))以上である場合にジャンプ\r\n  if(keyIsDown(\" \".charCodeAt(0))&&(y >= groundY - (size / 2))){\r\n    // ジャンプ処理（y方向の速度(vy)を上向き（負の値）に設定する）\r\n    vy = -20; // 例として-15を設定\r\n  }\r\n\r\n  // 速くなりすぎないように制限\r\n  vx = constrain(vx, -vyMax, vyMax);\r\n  vy = constrain(vy, -vyMax, vyMax);\r\n\r\n  // 位置を更新\r\n  x += vx;\r\n  y += vy;\r\n\r\n\r\n\r\n  // 地面との衝突判定と位置の強制補正 (めり込み防止)\r\n  if (y > groundY - (size / 2)) {\r\n      y = groundY - (size / 2); // 位置を地面の境界に強制的に戻す\r\n      vy = 0; // 地面に接触したら速度をリセット\r\n  } \r\n\r\n  // 左右の画面端の制約 (キャラクターが画面端を突き抜けないように)\r\n  // 円の中心が画面端から半径分内側になるように制限\r\n  x = constrain(x, size / 2, width - size / 2); //xがsize / 2, widthより左に、width - size / 2より右になるように\r\n\r\n\r\n\r\n  // キャラクターを描く\r\n  fill(0);\r\n  // 注: 元のコードにあったellipse(x, y, 50)は削除し、サイズが可変のellipse(x, y, size, size)に統一\r\n  ellipse(x, y, size, size);\r\n}"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "11/11/2025, 11:23:16 AM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// 2D アニメーションゲームのようなインタラクション\r\nlet x, y;\r\nlet vx, vy; // x,y座標方向に進む速度\r\nconst g = 1; //重力\r\nconst vyMax = 20; //速度の最大値\r\n\r\nfunction setup(){\r\n  createCanvas(windowWidth, windowHeight);\r\n\r\n  // setup()内で地面の位置とキャラクターのサイズを計算し、初期位置を設定\r\n  const groundY = height * 0.8;\r\n  const charSize  = height * 0.1;\r\n  \r\n  x = width / 2;\r\n  //地面の位置（groundY）から半径分（charSize / 2）上に設定\r\n  y = groundY - (charSize / 2); // これで地面スタート\r\n  vx = 0;\r\n  vy = 0;\r\n}\r\n\r\nfunction windowResized(){\r\n  resizeCanvas(windowWidth, windowHeight);\r\n}\r\n\r\nfunction draw(){\r\n  background(160, 192, 255);\r\n  const size = height * 0.1; // キャラクターのサイズ\r\n  const groundY = height * 0.8; // 地面を描く前に定義\r\n\r\n  // 地面を描く\r\n  fill(64, 192, 64);\r\n  rect(0, groundY, width, height - groundY);\r\n\r\n  // BLANK[1] キャラクターの左右移動\r\n  ellipse(x, y, 50);\r\n  // キーの処理（else ifにすると同時押しできなくなってしまうので要注意）\r\n  if(keyIsDown(LEFT_ARROW)){ x -= 5; }\r\n  if(keyIsDown(RIGHT_ARROW)){ x += 5; }\r\n  //加速処理\r\n  if(keyIsDown(LEFT_ARROW)&&(keyIsDown(\"D\".charCodeAt(0)))){ x -= 10; }\r\n  if(keyIsDown(RIGHT_ARROW)&&(keyIsDown(\"D\".charCodeAt(0)))){ x += 10; }\r\n\r\n\r\n\r\n  // BLANK[2] 重力とジャンプ\r\n  // 重力適用\r\n  vy += g; //毎フレームごとにyの速度にgが加わる\r\n  \r\n  // BLANK ジャンプ処理 (空中ジャンプ不可)\r\n  \r\n\r\n  // スペースキーが押され、かつY座標が地面の位置(groundY - (size / 2))以上である場合にジャンプ\r\n  if(keyIsDown(\" \".charCodeAt(0))&&(y >= groundY - (size / 2))){\r\n    // ジャンプ処理（y方向の速度(vy)を上向き（負の値）に設定する）\r\n    vy = -20; // 例として-20を設定\r\n  }\r\n\r\n  // 速くなりすぎないように制限\r\n  vx = constrain(vx, -vyMax, vyMax);\r\n  vy = constrain(vy, -vyMax, vyMax);\r\n\r\n  // 位置を更新\r\n  x += vx;\r\n  y += vy;\r\n\r\n\r\n\r\n  // 地面との衝突判定と位置の強制補正 (めり込み防止)\r\n  if (y > groundY - (size / 2)) {\r\n      y = groundY - (size / 2); // 位置を地面の境界に強制的に戻す\r\n      vy = 0; // 地面に接触したら速度をリセット\r\n  } \r\n\r\n  // 左右の画面端の制約 (キャラクターが画面端を突き抜けないように)\r\n  // 円の中心が画面端から半径分内側になるように制限\r\n  x = constrain(x, size / 2, width - size / 2); //xがsize / 2, widthより左に、width - size / 2より右になるように\r\n\r\n\r\n\r\n  // キャラクターを描く\r\n  fill(0);\r\n  // 注: 元のコードにあったellipse(x, y, 50)は削除し、サイズが可変のellipse(x, y, size, size)に統一\r\n  ellipse(x, y, size, size);\r\n}"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "11/11/2025, 11:28:25 AM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// 2D アニメーションゲームのようなインタラクション\r\nlet x, y;\r\nlet vx, vy; // x,y座標方向に進む速度\r\nconst g = 1; //重力\r\nconst vyMax = 20; //速度の最大値\r\n\r\nfunction setup(){\r\n  createCanvas(windowWidth, windowHeight);\r\n\r\n  // setup()内で地面の位置とキャラクターのサイズを計算し、初期位置を設定\r\n  const groundY = height * 0.8;\r\n  const charSize  = height * 0.1;\r\n  \r\n  x = width / 2;\r\n  //地面の位置（groundY）から半径分（charSize / 2）上に設定\r\n  y = groundY - (charSize / 2); // これで地面スタート\r\n  vx = 0;\r\n  vy = 0;\r\n}\r\n\r\nfunction windowResized(){\r\n  resizeCanvas(windowWidth, windowHeight);\r\n}\r\n\r\nfunction draw(){\r\n  background(160, 192, 255);\r\n  const size = height * 0.1; // キャラクターのサイズ\r\n  const groundY = height * 0.8; // 地面を描く前に定義\r\n\r\n  // 地面を描く\r\n  fill(64, 192, 64);\r\n  rect(0, groundY, width, height - groundY);\r\n\r\n  // BLANK[1] キャラクターの左右移動\r\n  ellipse(x, y, 50);\r\n  // キーの処理（else ifにすると同時押しできなくなってしまうので要注意）\r\n  if(keyIsDown(LEFT_ARROW)){ x -= 5; }\r\n  if(keyIsDown(RIGHT_ARROW)){ x += 5; }\r\n  //加速処理\r\n  if(keyIsDown(LEFT_ARROW)&&(keyIsDown(\"D\".charCodeAt(0)))){ x -= 10; }\r\n  if(keyIsDown(RIGHT_ARROW)&&(keyIsDown(\"D\".charCodeAt(0)))){ x += 10; }\r\n\r\n\r\n\r\n  // BLANK[2] 重力とジャンプ\r\n  // 重力適用\r\n  vy += g; //毎フレームごとにyの速度にgが加わる\r\n  \r\n  // BLANK ジャンプ処理 (空中ジャンプ不可)\r\n  \r\n\r\n  // スペースキーが押され、かつY座標が地面の位置(groundY - (size / 2))以上である場合にジャンプ\r\n  if(keyIsDown(\" \".charCodeAt(0))&&(y >= groundY - (size / 2))){\r\n    // ジャンプ処理（y方向の速度(vy)を上向き（負の値）に設定する）\r\n    vy = -20; // 例として-20を設定\r\n  }\r\n\r\n  // 速くなりすぎないように制限\r\n  vx = constrain(vx, -vyMax, vyMax);\r\n  vy = constrain(vy, -vyMax, vyMax);\r\n\r\n  // 位置を更新\r\n  x += vx;\r\n  y += vy;\r\n\r\n\r\n\r\n  // 地面との衝突判定と位置の強制補正 (めり込み防止)\r\n  if (y > groundY - (size / 2)) {\r\n      y = groundY - (size / 2); // 位置を地面の境界に強制的に戻す\r\n      vy = 0; // 地面に接触したら速度をリセット\r\n  } \r\n\r\n  // 左右の画面端の制約 (キャラクターが画面端を突き抜けないように)\r\n  // 円の中心が画面端から半径分内側になるように制限\r\n  x = constrain(x, size / 2, width - size / 2); //xがsize / 2, widthより左に、width - size / 2より右になるように\r\n  y = constrain(y, 0, height);\r\n\r\n\r\n  // キャラクターを描く\r\n  fill(0);\r\n  // 注: 元のコードにあったellipse(x, y, 50)は削除し、サイズが可変のellipse(x, y, size, size)に統一\r\n  ellipse(x, y, size, size);\r\n}"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "11/11/2025, 11:28:53 AM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// 2D アニメーションゲームのようなインタラクション\r\nlet x, y;\r\nlet vx, vy; // x,y座標方向に進む速度\r\nconst g = 1; //重力\r\nconst vyMax = 20; //速度の最大値\r\n\r\nfunction setup(){\r\n  createCanvas(windowWidth, windowHeight);\r\n\r\n  // setup()内で地面の位置とキャラクターのサイズを計算し、初期位置を設定\r\n  const groundY = height * 0.8;\r\n  const charSize  = height * 0.1;\r\n  \r\n  x = width / 2;\r\n  //地面の位置（groundY）から半径分（charSize / 2）上に設定\r\n  y = groundY - (charSize / 2); // これで地面スタート\r\n  vx = 0;\r\n  vy = 0;\r\n}\r\n\r\nfunction windowResized(){\r\n  resizeCanvas(windowWidth, windowHeight);\r\n}\r\n\r\nfunction draw(){\r\n  background(160, 192, 255);\r\n  const size = height * 0.1; // キャラクターのサイズ\r\n  const groundY = height * 0.8; // 地面を描く前に定義\r\n\r\n  // 地面を描く\r\n  fill(64, 192, 64);\r\n  rect(0, groundY, width, height - groundY);\r\n\r\n  // BLANK[1] キャラクターの左右移動\r\n  ellipse(x, y, 50);\r\n  // キーの処理（else ifにすると同時押しできなくなってしまうので要注意）\r\n  if(keyIsDown(LEFT_ARROW)){ x -= 5; }\r\n  if(keyIsDown(RIGHT_ARROW)){ x += 5; }\r\n  //加速処理\r\n  if(keyIsDown(LEFT_ARROW)&&(keyIsDown(\"D\".charCodeAt(0)))){ x -= 10; }\r\n  if(keyIsDown(RIGHT_ARROW)&&(keyIsDown(\"D\".charCodeAt(0)))){ x += 10; }\r\n\r\n\r\n\r\n  // BLANK[2] 重力とジャンプ\r\n  // 重力適用\r\n  vy += g; //毎フレームごとにyの速度にgが加わる\r\n  \r\n  // BLANK ジャンプ処理 (空中ジャンプ不可)\r\n  \r\n\r\n  // スペースキーが押され、かつY座標が地面の位置(groundY - (size / 2))以上である場合にジャンプ\r\n  if(keyIsDown(\" \".charCodeAt(0))&&(y >= groundY - (size / 2))){\r\n    // ジャンプ処理（y方向の速度(vy)を上向き（負の値）に設定する）\r\n    vy = -20; // 例として-20を設定\r\n  }\r\n\r\n  // 速くなりすぎないように制限\r\n  vx = constrain(vx, -vyMax, vyMax);\r\n  vy = constrain(vy, -vyMax, vyMax);\r\n\r\n  // 位置を更新\r\n  x += vx;\r\n  y += vy;\r\n\r\n\r\n\r\n  // 地面との衝突判定と位置の強制補正 (めり込み防止)\r\n  if (y > groundY - (size / 2)) {\r\n      y = groundY - (size / 2); // 位置を地面の境界に強制的に戻す\r\n      vy = 0; // 地面に接触したら速度をリセット\r\n  } \r\n\r\n  // 左右の画面端の制約 (キャラクターが画面端を突き抜けないように)\r\n  // 円の中心が画面端から半径分内側になるように制限\r\n  x = constrain(x, 0, width); \r\n  y = constrain(y, 0, height);\r\n\r\n\r\n  // キャラクターを描く\r\n  fill(0);\r\n  // 注: 元のコードにあったellipse(x, y, 50)は削除し、サイズが可変のellipse(x, y, size, size)に統一\r\n  ellipse(x, y, size, size);\r\n}"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "11/11/2025, 11:30:53 AM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// 2D アニメーションゲームのようなインタラクション\r\nlet x, y;\r\nlet vx, vy; // x,y座標方向に進む速度\r\nconst g = 1; //重力\r\nconst vyMax = 20; //速度の最大値\r\n\r\nfunction setup(){\r\n  createCanvas(windowWidth, windowHeight);\r\n\r\n  // setup()内で地面の位置とキャラクターのサイズを計算し、初期位置を設定\r\n  const groundY = height * 0.8;\r\n  const charSize  = height * 0.1;\r\n  \r\n  x = width / 2;\r\n  //地面の位置（groundY）から半径分（charSize / 2）上に設定\r\n  y = groundY - (charSize / 2); // これで地面スタート\r\n  vx = 0;\r\n  vy = 0;\r\n}\r\n\r\nfunction windowResized(){\r\n  resizeCanvas(windowWidth, windowHeight);\r\n}\r\n\r\nfunction draw(){\r\n  background(160, 192, 255);\r\n  const size = height * 0.1; // キャラクターのサイズ\r\n  const groundY = height * 0.8; // 地面を描く前に定義\r\n\r\n  // 地面を描く\r\n  fill(64, 192, 64);\r\n  rect(0, groundY, width, height - groundY);\r\n\r\n  // BLANK[1] キャラクターの左右移動\r\n  ellipse(x, y, 50);\r\n  // キーの処理（else ifにすると同時押しできなくなってしまうので要注意）\r\n  if(keyIsDown(LEFT_ARROW)){ x -= 5; }\r\n  if(keyIsDown(RIGHT_ARROW)){ x += 5; }\r\n  //加速処理\r\n  if(keyIsDown(LEFT_ARROW)&&(keyIsDown(\"D\".charCodeAt(0)))){ x -= 10; }\r\n  if(keyIsDown(RIGHT_ARROW)&&(keyIsDown(\"D\".charCodeAt(0)))){ x += 10; }\r\n\r\n\r\n\r\n  // BLANK[2] 重力とジャンプ\r\n  // 重力適用\r\n  vy += g; //毎フレームごとにyの速度にgが加わる\r\n  \r\n  // BLANK ジャンプ処理 (空中ジャンプ不可)\r\n  \r\n\r\n  // スペースキーが押され、かつY座標が地面の位置(groundY - (size / 2))以上である場合にジャンプ\r\n  if(keyIsDown(\" \".charCodeAt(0))&&(y >= groundY - (size / 2))){\r\n    // ジャンプ処理（y方向の速度(vy)を上向き（負の値）に設定する）\r\n    vy = -20; // 例として-20を設定\r\n  }\r\n\r\n  // 速くなりすぎないように制限\r\n  //vx = constrain(vx, -vyMax, vyMax);\r\n  vy = constrain(vy, -vyMax, vyMax);\r\n\r\n  // 位置を更新\r\n  x += vx;\r\n  y += vy;\r\n\r\n\r\n\r\n  // 地面との衝突判定と位置の強制補正 (めり込み防止)\r\n  if (y > groundY - (size / 2)) {\r\n      y = groundY - (size / 2); // 位置を地面の境界に強制的に戻す\r\n      vy = 0; // 地面に接触したら速度をリセット\r\n  } \r\n\r\n  // 左右の画面端の制約 (キャラクターが画面端を突き抜けないように)\r\n  // 円の中心が画面端から半径分内側になるように制限\r\n  x = constrain(x, 0, width); \r\n  y = constrain(y, 0, height);\r\n\r\n\r\n  // キャラクターを描く\r\n  fill(0);\r\n  // 注: 元のコードにあったellipse(x, y, 50)は削除し、サイズが可変のellipse(x, y, size, size)に統一\r\n  ellipse(x, y, size, size);\r\n}"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "11/11/2025, 11:31:05 AM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// 2D アニメーションゲームのようなインタラクション\r\nlet x, y;\r\nlet vx, vy; // x,y座標方向に進む速度\r\nconst g = 1; //重力\r\nconst vyMax = 20; //速度の最大値\r\n\r\nfunction setup(){\r\n  createCanvas(windowWidth, windowHeight);\r\n\r\n  // setup()内で地面の位置とキャラクターのサイズを計算し、初期位置を設定\r\n  const groundY = height * 0.8;\r\n  const charSize  = height * 0.1;\r\n  \r\n  x = width / 2;\r\n  //地面の位置（groundY）から半径分（charSize / 2）上に設定\r\n  y = groundY - (charSize / 2); // これで地面スタート\r\n  vx = 0;\r\n  vy = 0;\r\n}\r\n\r\nfunction windowResized(){\r\n  resizeCanvas(windowWidth, windowHeight);\r\n}\r\n\r\nfunction draw(){\r\n  background(160, 192, 255);\r\n  const size = height * 0.1; // キャラクターのサイズ\r\n  const groundY = height * 0.8; // 地面を描く前に定義\r\n\r\n  // 地面を描く\r\n  fill(64, 192, 64);\r\n  rect(0, groundY, width, height - groundY);\r\n\r\n  // BLANK[1] キャラクターの左右移動\r\n  ellipse(x, y, 50);\r\n  // キーの処理（else ifにすると同時押しできなくなってしまうので要注意）\r\n  if(keyIsDown(LEFT_ARROW)){ x -= 5; }\r\n  if(keyIsDown(RIGHT_ARROW)){ x += 5; }\r\n  //加速処理\r\n  if(keyIsDown(LEFT_ARROW)&&(keyIsDown(\"D\".charCodeAt(0)))){ x -= 10; }\r\n  if(keyIsDown(RIGHT_ARROW)&&(keyIsDown(\"D\".charCodeAt(0)))){ x += 10; }\r\n\r\n\r\n\r\n  // BLANK[2] 重力とジャンプ\r\n  // 重力適用\r\n  vy += g; //毎フレームごとにyの速度にgが加わる\r\n  \r\n  // BLANK ジャンプ処理 (空中ジャンプ不可)\r\n  \r\n\r\n  // スペースキーが押され、かつY座標が地面の位置(groundY - (size / 2))以上である場合にジャンプ\r\n  if(keyIsDown(\" \".charCodeAt(0))&&(y >= groundY - (size / 2))){\r\n    // ジャンプ処理（y方向の速度(vy)を上向き（負の値）に設定する）\r\n    vy = -20; // 例として-20を設定\r\n  }\r\n\r\n  // 速くなりすぎないように制限\r\n  //vx = constrain(vx, -vyMax, vyMax);\r\n  vy = constrain(vy, -vyMax, vyMax);\r\n\r\n  // 位置を更新\r\n  x += vx;\r\n  y += vy;\r\n\r\n\r\n\r\n  // 地面との衝突判定と位置の強制補正 (めり込み防止)\r\n  if (y > groundY - (size / 2)) {\r\n      y = groundY - (size / 2); // 位置を地面の境界に強制的に戻す\r\n      vy = 0; // 地面に接触したら速度をリセット\r\n  } \r\n\r\n  // 左右の画面端の制約 (キャラクターが画面端を突き抜けないように)\r\n  // 円の中心が画面端から半径分内側になるように制限\r\n  x = constrain(x, 0, width); \r\n  y = constrain(y, 0, height);\r\n\r\n\r\n  // キャラクターを描く\r\n  fill(0);\r\n  // 注: 元のコードにあったellipse(x, y, 50)は削除し、サイズが可変のellipse(x, y, size, size)に統一\r\n  ellipse(x, y, size, size);\r\n}"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "11/18/2025, 11:53:17 AM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// 配列の平均・最大・最小を求め、棒グラフを描く\r\nfunction setup(){\r\n  createCanvas(400, 400);\r\n  background(240);\r\n\r\n  // 配列をランダムに初期化する\r\n  let scores = [];\r\n  for(let i = 0; i < 10; i++){\r\n    scores[i] = random(20, 100); // 20以上100未満のランダムな数を代入\r\n  }\r\n  console.log(scores);\r\n\r\n  // 合計を計算する\r\n  let sum = 0;\r\n  for(let i = 0; i < scores.length; i++){\r\n    sum += scores[i];//配列の値を足していく\r\n  }\r\n  console.log(sum);\r\n\r\n  const average = sum / scores.length; //length データ数\r\n  \r\n\r\n  // ここから平均・最大・最小を求めます\r\n  \r\n  // BLANK[1]　平均値（ヒント average = 合計 / 配列の長さ）\r\n\r\n  largest = 0; //在り得る最大の値、初期値\r\n  for(let i = 0; i < scores.length; i++){\r\n    if(scores[i]>largest){//1番目[今の値]がこれまでの最大値より大きい場合\r\n      largest = scores[1];\r\n    }\r\n    // BLANK[2]　ヒント：今までの最大値 largest と scores[i] を比較する\r\n  }\r\n\r\n  let smallest = 100;//ありうる最小の値\r\n  for(let i = 0; i < scores.length; i++){\r\n    if(scores[i]<smallest){\r\n      smallest = scores[i];\r\n    }\r\n    // BLANK[3]　ヒント：最小値とだいたい同じ\r\n  }\r\n\r\n  // ここから棒グラフを描いていきます。まずは背景に横線をn本引く\r\n  const n = 10;\r\n  for(let i = 0; i < n; i++){ line(0, height * i / n, width, height * i / n); }\r\n  //10回繰り返す\r\n  noStroke();\r\n\r\n  for(let i = 0; i < scores.length; i++){\r\n    const dx = width / scores.length;//棒1っ本分の横幅\r\n    const h = height * scores[i] / 100;\r\n    // BLANK[4] 最大値・最小値の色を変えましょう\r\n\r\n    if(scores[i] == largest){ fill(255, 0, 0); }\r\n    else if(scores[i] == smallest){ fill(0, 0, 255); }\r\n    else{ fill(128); }\r\n\r\n    rect(i * dx + 2, height - h, dx - 4, h);//すっきり\r\n    \r\n  }\r\n    const ay = height - height * average / 100;\r\n  stroke(0, 255, 0);\r\n  line(0, ay, width, ay);\r\n}\r\n  // BLANK[5] 平均点の線を引きます\r\n"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "11/18/2025, 12:10:52 PM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// 折れ線グラフ\r\nfunction setup(){\r\n  createCanvas(400, 400);\r\n  background(240);\r\n\r\n  // 配列をランダムに初期化する\r\n  let scores = [];\r\n  for(let i = 0; i < 10; i++){\r\n    scores[i] = random(20, 100); // 60以上100未満のランダムな数を代入\r\n  }\r\n\r\n  // 横線を引く\r\n  const n = 10;\r\n  for(let i = 0; i < n; i++){ line(0, height * i / n, width, height * i / n); }\r\n\r\n  // ここからが本番\r\n  fill(0);\r\n  const dx = width / scores.length;\r\n  let px, py; // 線を引くために一つ前の点を覚えておく変数\r\n  for(let i = 0; i < scores.length; i++){//棒グラフから折れ線グラフの値に変わっただけ\r\n    const dx = width / scores.length; //棒1本分の横幅を計算。\r\n    const h = height * scores[i] / 100;\r\n    const k = height * scores[i-1] / 100;\r\n    const m = dx /2 ;\r\n    const ex = dx *i + m;\r\n    const ey = height - h;\r\n\r\n    fill(0);\r\n    ellipse(ex, ey, dx/5, dx / 5)\r\n\r\n    if(i>0){px = (i-1) * dx + m; py  = height - k;}\r\n    line(px, py, ex, ey)\r\n  }\r\n}\r\n"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "11/18/2025, 12:22:25 PM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// 折れ線グラフ\r\nfunction setup(){\r\n  createCanvas(400, 400);\r\n  background(240);\r\n\r\n  // 配列をランダムに初期化する\r\n  let scores = [];\r\n  for(let i = 0; i < 10; i++){\r\n    scores[i] = random(20, 100); // 60以上100未満のランダムな数を代入\r\n  }\r\n\r\n  // 横線を引く\r\n  const n = 10;//10本\r\n  for(let i = 0; i < n; i++){ line(0, height * i / n, width, height * i / n); }\r\n\r\n  // ここからが本番\r\n  fill(0);\r\n  const dx = width / scores.length;//棒1本分の横幅を計算\r\n  let px, py; // 線を引くために一つ前の点を覚えておく変数\r\n  for(let i = 0; i < scores.length; i++){//棒グラフから折れ線グラフの値に変わっただけ\r\n    const h = height * scores[i] / 100;\r\n    const k = height * scores[i-1] / 100;\r\n    const m = dx /2 ;\r\n    const ex = dx *i + m;\r\n    const ey = height - h;\r\n\r\n    fill(0);\r\n    ellipse(ex, ey, dx/5, dx / 5)\r\n\r\n    if(i>0){px = dx * (i-1)  + m; py  = height - k;}\r\n    line(px, py, ex, ey)\r\n  }\r\n}\r\n"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "11/23/2025, 11:25:17 AM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// 最終課題を制作しよう\r\n\r\nfunction setup(){\r\n  createCanvas(windowWidth, windowHeight);\r\n}\r\n\r\nfunction draw(){\r\n  background(160, 192, 255);\r\n  ellipse(windowwidth/2, windowhight/2, windowWidth/2)\r\n}\r\n\r\nfunction windowResized(){\r\n  resizeCanvas(windowWidth, windowHeight);\r\n}\r\n"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "11/23/2025, 11:26:40 AM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// 最終課題を制作しよう\r\n\r\nfunction setup(){\r\n  createCanvas(windowWidth, windowHeight);\r\n}\r\n\r\nfunction draw(){\r\n  background(160, 192, 255);\r\n  Fill(100);\r\n  ellipse(windowwidth/2, windowhight/2, windowWidth/2)\r\n}\r\n\r\nfunction windowResized(){\r\n  resizeCanvas(windowWidth, windowHeight);\r\n}\r\n"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "11/23/2025, 11:26:46 AM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// 最終課題を制作しよう\r\n\r\nfunction setup(){\r\n  createCanvas(windowWidth, windowHeight);\r\n}\r\n\r\nfunction draw(){\r\n  background(160, 192, 255);\r\n  Fill(100);\r\n  ellipse(windowwidth/2, windowhight/2, windowWidth/2);\r\n}\r\n\r\nfunction windowResized(){\r\n  resizeCanvas(windowWidth, windowHeight);\r\n}\r\n"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "11/23/2025, 11:26:58 AM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// 最終課題を制作しよう\r\n\r\nfunction setup(){\r\n  createCanvas(windowWidth, windowHeight);\r\n}\r\n\r\nfunction draw(){\r\n  background(160, 192, 255);\r\n  Fill(100);\r\n  ellipse(windowwidth/2, windowhight/2, windowWidth/2);\r\n}\r\n\r\nfunction windowResized(){\r\n  resizeCanvas(windowWidth, windowHeight);\r\n}\r\n"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "11/23/2025, 11:28:55 AM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// 最終課題を制作しよう\r\n\r\nfunction setup(){\r\n  createCanvas(windowWidth, windowHeight);\r\n}\r\n\r\nfunction draw(){\r\n  background(160, 192, 255);\r\n  fill(100);\r\n  ellipse(windowwidth/2, windowhight/2, windowWidth/2);\r\n}\r\n\r\nfunction windowResized(){\r\n  resizeCanvas(windowWidth, windowHeight);\r\n}\r\n"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "11/23/2025, 11:50:10 AM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// 最終課題を制作しよう\r\n\r\nfunction setup(){\r\n  createCanvas(windowWidth, windowHeight);\r\n}\r\n\r\nfunction draw(){\r\n  background(160, 192, 255);\r\n  fill(12,123,234);\r\n  noStroke();\r\n  strokeWeight(5);\r\n  ellipse(windowwidth/2, windowhight/2, windowWidth/2, windowheight/2);\r\n}\r\n\r\nfunction windowResized(){\r\n  resizeCanvas(windowWidth, windowHeight);\r\n}\r\n"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "11/23/2025, 11:50:28 AM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// 最終課題を制作しよう\r\n\r\nfunction setup(){\r\n  createCanvas(windowWidth, windowHeight);\r\n}\r\n\r\nfunction draw(){\r\n  background(160, 192, 255);\r\n  fill(12,123,234);\r\n  noStroke();\r\n  strokeWeight(5);\r\n  ellipse(windowwidth/2, windowhight/2, windowWidth/2, windowheight/2);\r\n}\r\n\r\nfunction windowResized(){\r\n  resizeCanvas(windowWidth, windowHeight);\r\n}\r\n"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "11/23/2025, 11:52:46 AM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// 最終課題を制作しよう\r\n\r\nfunction setup(){\r\n  createCanvas(windowWidth, windowHeight);\r\n}\r\n\r\nfunction draw(){\r\n  background(160, 192, 255);\r\n  fill(12,123,234);\r\n  noStroke();\r\n  strokeWeight(5);\r\n  ellipse(windowwidth/2, windowheight/2, windowWidth/2, windowheeight/2);\r\n}\r\n\r\nfunction windowResized(){\r\n  resizeCanvas(windowWidth, windowHeight);\r\n}\r\n"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "11/23/2025, 11:52:50 AM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// 最終課題を制作しよう\r\n\r\nfunction setup(){\r\n  createCanvas(windowWidth, windowHeight);\r\n}\r\n\r\nfunction draw(){\r\n  background(160, 192, 255);\r\n  fill(12,123,234);\r\n  noStroke();\r\n  strokeWeight(5);\r\n  ellipse(windowwidth/2, windowheight/2, windowWidth/2, windowheeight/2);\r\n}\r\n\r\nfunction windowResized(){\r\n  resizeCanvas(windowWidth, windowHeight);\r\n}\r\n"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "11/23/2025, 11:53:38 AM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// 最終課題を制作しよう\r\n\r\nfunction setup(){\r\n  createCanvas(windowWidth, windowHeight);\r\n}\r\n\r\nfunction draw(){\r\n  background(160, 192, 255);\r\n  fill(12,123,234);\r\n  noStroke();\r\n  strokeWeight(5);\r\n  ellipse(windoWidth/2, windowHeight/2, windowWidth/2, windowHeight/2);\r\n}\r\n\r\nfunction windowResized(){\r\n  resizeCanvas(windowWidth, windowHeight);\r\n}\r\n"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "11/23/2025, 11:54:17 AM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// 最終課題を制作しよう\r\n\r\nfunction setup(){\r\n  createCanvas(windowWidth, windowHeight);\r\n}\r\n\r\nfunction draw(){\r\n  background(160, 192, 255);\r\n  fill(12,123,234);\r\n  noStroke();\r\n  strokeWeight(5);\r\n  ellipse(200, 200, 50, 50);\r\n}\r\n\r\nfunction windowResized(){\r\n  resizeCanvas(windowWidth, windowHeight);\r\n}\r\n"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "11/23/2025, 11:54:44 AM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// 最終課題を制作しよう\r\n\r\nfunction setup(){\r\n  createCanvas(windowWidth, windowHeight);\r\n}\r\n\r\nfunction draw(){\r\n  background(160, 192, 255);\r\n  fill(255);\r\n  noStroke();\r\n  strokeWeight(5);\r\n  ellipse(200, 200, 50, 50);\r\n}\r\n\r\nfunction windowResized(){\r\n  resizeCanvas(windowWidth, windowHeight);\r\n}\r\n"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "11/23/2025, 11:55:26 AM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// 最終課題を制作しよう\r\n\r\nfunction setup(){\r\n  createCanvas(windowWidth, windowHeight);\r\n}\r\n\r\nfunction draw(){\r\n  background(160, 192, 255);\r\n  fill(255);\r\n  noStroke();\r\n  strokeWeight(5);\r\n  ellipse(width/2, height/2, 50, 50);\r\n}\r\n\r\nfunction windowResized(){\r\n  resizeCanvas(windowWidth, windowHeight);\r\n}\r\n"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "11/23/2025, 11:57:31 AM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// 最終課題を制作しよう\r\n\r\nfunction setup(){\r\n  createCanvas(windowWidth, windowHeight);\r\n}\r\n\r\nfunction draw(){\r\n  background(160, 192, 255);\r\n  fill(255);\r\n  noStroke();\r\n  //strokeWeight(5);\r\n  ellipse(width/2, height/2, 50, 50);\r\n}\r\n\r\nfunction windowResized(){\r\n  resizeCanvas(windowWidth, windowHeight);\r\n}\r\n"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "11/23/2025, 12:06:37 PM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// 最終課題を制作しよう\r\n\r\nfunction setup(){\r\n  createCanvas(windowWidth, windowHeight);\r\n}\r\n\r\nfunction draw(){\r\n  background(160, 192, 255);\r\n  //二重ループで画面を10×10のマス目に分ける\r\n  for(let i = 0; i < 10; i++){ //横方向（i: x座標の計算に使う）\r\n    for(let j = 0 j < 10; j++){ //縦方向（j: y座標の計算に使う）\r\n      //座標計算\r\n      const x = i * (width / 10) + (width / 20); //x位置\r\n      const y = j * (height / 10) + (height / 20) //y位置\r\n\r\n      //図形の描画\r\n      fill(255);\r\n      ellipse(x, y, 10, 10)\r\n    }\r\n  }\r\n}\r\n\r\nfunction windowResized(){\r\n  resizeCanvas(windowWidth, windowHeight);\r\n}\r\n"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "11/23/2025, 12:07:29 PM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// 最終課題を制作しよう\r\n\r\nfunction setup(){\r\n  createCanvas(windowWidth, windowHeight);\r\n}\r\n\r\nfunction draw(){\r\n  background(160, 192, 255);\r\n  //二重ループで画面を10×10のマス目に分ける\r\n  for(let i = 0; i < 10; i++){ //横方向（i: x座標の計算に使う）\r\n    for(let j = 0; j < 10; j++){ //縦方向（j: y座標の計算に使う）\r\n      //座標計算\r\n      const x = i * (width / 10) + (width / 20); //x位置\r\n      const y = j * (height / 10) + (height / 20) //y位置\r\n\r\n      //図形の描画\r\n      fill(255);\r\n      ellipse(x, y, 10, 10)\r\n    }\r\n  }\r\n}\r\n\r\nfunction windowResized(){\r\n  resizeCanvas(windowWidth, windowHeight);\r\n}\r\n"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "11/23/2025, 12:13:22 PM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// 最終課題を制作しよう\r\n\r\nfunction setup(){\r\n  createCanvas(windowWidth, windowHeight);\r\n}\r\n\r\nfunction draw() {\r\n    background(220); // 前回の描画を消去\r\n    \r\n    // スタイル設定：白い円を描く\r\n    fill(255); // 白に塗りつぶす\r\n    noStroke(); // 線は描かない\r\n    \r\n    // 描画：キャンバスの中央 (width/2, height/2) に円を描く\r\n    ellipse(width / 2, height / 2, 50, 50); \r\n}\r\n\r\nfunction draw(){\r\n  background(160, 192, 255);\r\n  //二重ループで画面を10×10のマス目に分ける\r\n  for(let i = 0; i < 10; i++){ //横方向（i: x座標の計算に使う）\r\n    for(let j = 0; j < 10; j++){ //縦方向（j: y座標の計算に使う）\r\n      //座標計算\r\n      const x = i * (width / 10) + (width / 20); //x位置\r\n      const y = j * (height / 10) + (height / 20) //y位置\r\n\r\n      //図形の描画\r\n      fill(255);\r\n      ellipse(x, y, 10, 10)\r\n    }\r\n  }\r\n}\r\n\r\nfunction windowResized(){\r\n  resizeCanvas(windowWidth, windowHeight);\r\n}\r\n"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "11/23/2025, 5:00:43 PM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// 最終課題を制作しよう\r\n\r\nfunction setup(){\r\n  createCanvas(windowWidth, windowHeight);\r\n}\r\n\r\nfunction draw() {\r\n    background(220); // 前回の描画を消去\r\n    \r\n    // スタイル設定：白い円を描く\r\n    fill(255); // 白に塗りつぶす\r\n    noStroke(); // 線は描かない\r\n    \r\n    // 描画：キャンバスの中央 (width/2, height/2) に円を描く\r\n    ellipse(width / 2, height / 2, 50, 50); \r\n}\r\n\r\nfunction draw(){\r\n  background(0);\r\n  //二重ループで画面を10×10のマス目に分ける\r\n  for(let i = 0; i < 10; i++){ //横方向（i: x座標の計算に使う）\r\n    for(let j = 0; j < 10; j++){ //縦方向（j: y座標の計算に使う）\r\n      //座標計算\r\n      const x = i * (width / 10) + (width / 20); //x位置\r\n      const y = j * (height / 10) + (height / 20) //y位置\r\n\r\n      //図形の描画\r\n      fill(255);\r\n      ellipse(x, y, 10, 10)\r\n    }\r\n  }\r\n}\r\n\r\nfunction windowResized(){\r\n  resizeCanvas(windowWidth, windowHeight);\r\n}\r\n"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "11/23/2025, 5:02:13 PM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// 最終課題を制作しよう\r\n\r\nfunction setup(){\r\n  createCanvas(windowWidth, windowHeight);\r\n}\r\n\r\n\r\n\r\nfunction draw(){\r\n  background(0);\r\n  //二重ループで画面を10×10のマス目に分ける\r\n  for(let i = 0; i < 10; i++){ //横方向（i: x座標の計算に使う）\r\n    for(let j = 0; j < 10; j++){ //縦方向（j: y座標の計算に使う）\r\n      //座標計算\r\n      const x = i * (width / 10) + (width / 20); //x位置\r\n      const y = j * (height / 10) + (height / 20) //y位置\r\n\r\n      //図形の描画\r\n      fill(255);\r\n      ellipse(x, y, 10, 10)\r\n    }\r\n  }\r\n}\r\n\r\nfunction windowResized(){\r\n  resizeCanvas(windowWidth, windowHeight);\r\n}\r\n"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "11/24/2025, 12:32:16 PM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// 最終課題を制作しよう\r\n// プログラム全体で有効な配列として宣言 (関数の外)\r\nlet balls = []; \r\n\r\n// 描画スタイルを管理する定数（任意）\r\nconst BALL_SIZE = 20;\r\n2. セットアップ関数 (setup())\r\nキャンバスのサイズを設定します。ウィンドウサイズに追従するようにしておくと便利です。\r\nfunction setup() {\r\n    // キャンバスのサイズをウィンドウと同じにする\r\n    createCanvas(windowWidth, windowHeight);\r\n}\r\n3. 繰り返し描画関数 (draw())\r\nアニメーションの中核です。背景を再描画し、配列内のすべての物体を更新・描画します。\r\nfunction draw() {\r\n    // 背景を塗りつぶして前回の描画を消去する（アニメーションの基本）\r\n    // 例: background(160, 192, 255);\r\n    background(0, 50); // 透明度を低く設定し、動きの軌跡を残す演出も可能\r\n    \r\n    // 配列内の全てのボール（オブジェクト）に対して処理を繰り返す (for文) [12]\r\n    for (let i = 0; i < balls.length; i++) {\r\n        let b = balls[i]; // 現在のボールオブジェクトを参照\r\n        \r\n        // 速度の分だけ位置を移動させる（アニメーション）[13]\r\n        b.x += b.vx;\r\n        b.y += b.vy;\r\n        \r\n        // ボールを描画\r\n        fill(b.color); // ボールごとの色\r\n        noStroke();\r\n        ellipse(b.x, b.y, b.size);\r\n        \r\n        // ★ 作品を拡張する際のポイント：\r\n        // 画面外に出たボールを配列から削除する処理 (演習問題で触れられている)\r\n        if (b.x < -100 || b.x > width + 100 || b.y < -100 || b.y > height + 100) {\r\n            // 配列から削除する処理（popやshiftではない中間要素の削除が必要）\r\n            // このひな型ではシンプルにするため、画面外のボールを消す処理は割愛します\r\n        }\r\n    }\r\n}\r\n4. インタラクション関数（mouseDragged()）\r\nマウスをドラッグしたときに新しい物体を生成し、それをアニメーションさせるための初速（vx, vy）を与えます。\r\nfunction mouseDragged() {\r\n    // 少し前のマウスの位置 (pmouseX, pmouseY) を使って、ドラッグの方向と速度を計算 [14]\r\n    const dx = mouseX - pmouseX; \r\n    const dy = mouseY - pmouseY; \r\n    \r\n    // ドラッグ速度が一定以上の場合のみボールを生成（ノイズを防ぐ）[4]\r\n    // mag(x, y) はベクトルの長さ（動いた距離）を計算する関数\r\n    if (mag(dx, dy) > 5) { \r\n        // 新しいボールオブジェクトを作成\r\n        const newBall = {\r\n            x: mouseX, \r\n            y: mouseY, \r\n            size: random(10, 30), // サイズにランダム性を加える [15]\r\n            vx: dx * 0.5, // 速度を調整\r\n            vy: dy * 0.5,\r\n            color: color(random(100, 255), random(100, 255), random(100, 255), 180) // ランダムな色と透明度 [16]\r\n        };\r\n        \r\n        // 配列の末尾に新しいボールを追加\r\n        balls.push(newBall); [17]\r\n    }\r\n}"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "11/24/2025, 12:32:30 PM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// 最終課題を制作しよう\r\n// プログラム全体で有効な配列として宣言 (関数の外)\r\nlet balls = []; \r\n\r\n// 描画スタイルを管理する定数（任意）\r\nconst BALL_SIZE = 20;\r\n2. セットアップ関数 (setup())\r\nキャンバスのサイズを設定します。ウィンドウサイズに追従するようにしておくと便利です。\r\nfunction setup() {\r\n    // キャンバスのサイズをウィンドウと同じにする\r\n    createCanvas(windowWidth, windowHeight);\r\n}\r\n3. 繰り返し描画関数 (draw())\r\nアニメーションの中核です。背景を再描画し、配列内のすべての物体を更新・描画します。\r\nfunction draw() {\r\n    // 背景を塗りつぶして前回の描画を消去する（アニメーションの基本）\r\n    // 例: background(160, 192, 255);\r\n    background(0, 50); // 透明度を低く設定し、動きの軌跡を残す演出も可能\r\n    \r\n    // 配列内の全てのボール（オブジェクト）に対して処理を繰り返す (for文) [12]\r\n    for (let i = 0; i < balls.length; i++) {\r\n        let b = balls[i]; // 現在のボールオブジェクトを参照\r\n        \r\n        // 速度の分だけ位置を移動させる（アニメーション）[13]\r\n        b.x += b.vx;\r\n        b.y += b.vy;\r\n        \r\n        // ボールを描画\r\n        fill(b.color); // ボールごとの色\r\n        noStroke();\r\n        ellipse(b.x, b.y, b.size);\r\n        \r\n        // ★ 作品を拡張する際のポイント：\r\n        // 画面外に出たボールを配列から削除する処理 (演習問題で触れられている)\r\n        if (b.x < -100 || b.x > width + 100 || b.y < -100 || b.y > height + 100) {\r\n            // 配列から削除する処理（popやshiftではない中間要素の削除が必要）\r\n            // このひな型ではシンプルにするため、画面外のボールを消す処理は割愛します\r\n        }\r\n    }\r\n}\r\n4. インタラクション関数（mouseDragged()）\r\nマウスをドラッグしたときに新しい物体を生成し、それをアニメーションさせるための初速（vx, vy）を与えます。\r\nfunction mouseDragged() {\r\n    // 少し前のマウスの位置 (pmouseX, pmouseY) を使って、ドラッグの方向と速度を計算 [14]\r\n    const dx = mouseX - pmouseX; \r\n    const dy = mouseY - pmouseY; \r\n    \r\n    // ドラッグ速度が一定以上の場合のみボールを生成（ノイズを防ぐ）[4]\r\n    // mag(x, y) はベクトルの長さ（動いた距離）を計算する関数\r\n    if (mag(dx, dy) > 5) { \r\n        // 新しいボールオブジェクトを作成\r\n        const newBall = {\r\n            x: mouseX, \r\n            y: mouseY, \r\n            size: random(10, 30), // サイズにランダム性を加える [15]\r\n            vx: dx * 0.5, // 速度を調整\r\n            vy: dy * 0.5,\r\n            color: color(random(100, 255), random(100, 255), random(100, 255), 180) // ランダムな色と透明度 [16]\r\n        };\r\n        \r\n        // 配列の末尾に新しいボールを追加\r\n        balls.push(newBall); [17]\r\n    }\r\n}"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "11/24/2025, 12:33:14 PM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// 最終課題を制作しよう\r\n// プログラム全体で有効な配列として宣言 (関数の外)\r\nlet balls = []; \r\n\r\n// 描画スタイルを管理する定数（任意）\r\nconst BALL_SIZE = 20;\r\n//2. セットアップ関数 (setup())\r\n//キャンバスのサイズを設定します。ウィンドウサイズに追従するようにしておくと便利です。\r\nfunction setup() {\r\n    // キャンバスのサイズをウィンドウと同じにする\r\n    createCanvas(windowWidth, windowHeight);\r\n}\r\n//3. 繰り返し描画関数 (draw())\r\n//アニメーションの中核です。背景を再描画し、配列内のすべての物体を更新・描画します。\r\nfunction draw() {\r\n    // 背景を塗りつぶして前回の描画を消去する（アニメーションの基本）\r\n    // 例: background(160, 192, 255);\r\n    background(0, 50); // 透明度を低く設定し、動きの軌跡を残す演出も可能\r\n    \r\n    // 配列内の全てのボール（オブジェクト）に対して処理を繰り返す (for文) [12]\r\n    for (let i = 0; i < balls.length; i++) {\r\n        let b = balls[i]; // 現在のボールオブジェクトを参照\r\n        \r\n        // 速度の分だけ位置を移動させる（アニメーション）[13]\r\n        b.x += b.vx;\r\n        b.y += b.vy;\r\n        \r\n        // ボールを描画\r\n        fill(b.color); // ボールごとの色\r\n        noStroke();\r\n        ellipse(b.x, b.y, b.size);\r\n        \r\n        // ★ 作品を拡張する際のポイント：\r\n        // 画面外に出たボールを配列から削除する処理 (演習問題で触れられている)\r\n        if (b.x < -100 || b.x > width + 100 || b.y < -100 || b.y > height + 100) {\r\n            // 配列から削除する処理（popやshiftではない中間要素の削除が必要）\r\n            // このひな型ではシンプルにするため、画面外のボールを消す処理は割愛します\r\n        }\r\n    }\r\n}\r\n//4. インタラクション関数（mouseDragged()）\r\n//マウスをドラッグしたときに新しい物体を生成し、それをアニメーションさせるための初速（vx, vy）を与えます。\r\nfunction mouseDragged() {\r\n    // 少し前のマウスの位置 (pmouseX, pmouseY) を使って、ドラッグの方向と速度を計算 [14]\r\n    const dx = mouseX - pmouseX; \r\n    const dy = mouseY - pmouseY; \r\n    \r\n    // ドラッグ速度が一定以上の場合のみボールを生成（ノイズを防ぐ）[4]\r\n    // mag(x, y) はベクトルの長さ（動いた距離）を計算する関数\r\n    if (mag(dx, dy) > 5) { \r\n        // 新しいボールオブジェクトを作成\r\n        const newBall = {\r\n            x: mouseX, \r\n            y: mouseY, \r\n            size: random(10, 30), // サイズにランダム性を加える [15]\r\n            vx: dx * 0.5, // 速度を調整\r\n            vy: dy * 0.5,\r\n            color: color(random(100, 255), random(100, 255), random(100, 255), 180) // ランダムな色と透明度 [16]\r\n        };\r\n        \r\n        // 配列の末尾に新しいボールを追加\r\n        balls.push(newBall); [17]\r\n    }\r\n}"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "11/24/2025, 1:24:13 PM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// 最終課題を制作しよう\r\n// プログラム全体で有効な配列として宣言 (関数の外)\r\nlet balls = []; \r\n\r\n// 描画スタイルを管理する定数（任意）\r\nconst BALL_SIZE = 20;\r\n\r\n//キャンバスのサイズを設定。\r\nfunction setup() {\r\n    // キャンバスのサイズをウィンドウと同じにする\r\n    createCanvas(windowWidth, windowHeight);\r\n}\r\n//繰り返し描画関数 (draw())\r\n//背景を再描画し、配列内のすべての物体を更新・描画。\r\nfunction draw() {\r\n    // 背景を塗りつぶして前回の描画を消去する（アニメーションの基本）\r\n    // 例: background(160, 192, 255);\r\n    background(50, 50); // 透明度を低く設定し、動きの軌跡を残す演出も可能\r\n    \r\n    // 配列内の全てのボール（オブジェクト）に対して処理を繰り返す (for文) [12]\r\n    for (let i = 0; i < balls.length; i++) {\r\n        let b = balls[i]; // 現在のボールオブジェクトを参照\r\n        \r\n        // 速度の分だけ位置を移動させる（アニメーション）[13]\r\n        b.x += b.vx;\r\n        b.y += b.vy;\r\n        \r\n        // ボールを描画\r\n        fill(b.color); // ボールごとの色\r\n        noStroke();\r\n        ellipse(b.x, b.y, b.size);\r\n        \r\n        // ★ 作品を拡張する際のポイント：\r\n        // 画面外に出たボールを配列から削除する処理 (演習問題で触れられている)\r\n        if (b.x < -100 || b.x > width + 100 || b.y < -100 || b.y > height + 100) {\r\n            // 配列から削除する処理（popやshiftではない中間要素の削除が必要）\r\n            // このひな型ではシンプルにするため、画面外のボールを消す処理は割愛します\r\n        }\r\n    }\r\n}\r\n//4. インタラクション関数（mouseDragged()）\r\n//マウスをドラッグしたときに新しい物体を生成し、それをアニメーションさせるための初速（vx, vy）を与えます。\r\nfunction mouseDragged() {\r\n    // 少し前のマウスの位置 (pmouseX, pmouseY) を使って、ドラッグの方向と速度を計算 [14]\r\n    const dx = mouseX - pmouseX; \r\n    const dy = mouseY - pmouseY; \r\n    \r\n    // ドラッグ速度が一定以上の場合のみボールを生成（ノイズを防ぐ）[4]\r\n    // mag(x, y) はベクトルの長さ（動いた距離）を計算する関数\r\n    if (mag(dx, dy) > 5) { \r\n        // 新しいボールオブジェクトを作成\r\n        const newBall = {\r\n            x: mouseX, \r\n            y: mouseY, \r\n            size: random(10, 30), // サイズにランダム性を加える [15]\r\n            vx: dx * 0.5, // 速度を調整\r\n            vy: dy * 0.5,\r\n            color: color(random(100, 255), random(100, 255), random(100, 255), 180) // ランダムな色と透明度 [16]\r\n        };\r\n        \r\n        // 配列の末尾に新しいボールを追加\r\n        balls.push(newBall); [17]\r\n    }\r\n}"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "11/24/2025, 1:24:24 PM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// 最終課題を制作しよう\r\n// プログラム全体で有効な配列として宣言 (関数の外)\r\nlet balls = []; \r\n\r\n// 描画スタイルを管理する定数（任意）\r\nconst BALL_SIZE = 20;\r\n\r\n//キャンバスのサイズを設定。\r\nfunction setup() {\r\n    // キャンバスのサイズをウィンドウと同じにする\r\n    createCanvas(windowWidth, windowHeight);\r\n}\r\n//繰り返し描画関数 (draw())\r\n//背景を再描画し、配列内のすべての物体を更新・描画。\r\nfunction draw() {\r\n    // 背景を塗りつぶして前回の描画を消去する（アニメーションの基本）\r\n    // 例: background(160, 192, 255);\r\n    background(50, 100); // 透明度を低く設定し、動きの軌跡を残す演出も可能\r\n    \r\n    // 配列内の全てのボール（オブジェクト）に対して処理を繰り返す (for文) [12]\r\n    for (let i = 0; i < balls.length; i++) {\r\n        let b = balls[i]; // 現在のボールオブジェクトを参照\r\n        \r\n        // 速度の分だけ位置を移動させる（アニメーション）[13]\r\n        b.x += b.vx;\r\n        b.y += b.vy;\r\n        \r\n        // ボールを描画\r\n        fill(b.color); // ボールごとの色\r\n        noStroke();\r\n        ellipse(b.x, b.y, b.size);\r\n        \r\n        // ★ 作品を拡張する際のポイント：\r\n        // 画面外に出たボールを配列から削除する処理 (演習問題で触れられている)\r\n        if (b.x < -100 || b.x > width + 100 || b.y < -100 || b.y > height + 100) {\r\n            // 配列から削除する処理（popやshiftではない中間要素の削除が必要）\r\n            // このひな型ではシンプルにするため、画面外のボールを消す処理は割愛します\r\n        }\r\n    }\r\n}\r\n//4. インタラクション関数（mouseDragged()）\r\n//マウスをドラッグしたときに新しい物体を生成し、それをアニメーションさせるための初速（vx, vy）を与えます。\r\nfunction mouseDragged() {\r\n    // 少し前のマウスの位置 (pmouseX, pmouseY) を使って、ドラッグの方向と速度を計算 [14]\r\n    const dx = mouseX - pmouseX; \r\n    const dy = mouseY - pmouseY; \r\n    \r\n    // ドラッグ速度が一定以上の場合のみボールを生成（ノイズを防ぐ）[4]\r\n    // mag(x, y) はベクトルの長さ（動いた距離）を計算する関数\r\n    if (mag(dx, dy) > 5) { \r\n        // 新しいボールオブジェクトを作成\r\n        const newBall = {\r\n            x: mouseX, \r\n            y: mouseY, \r\n            size: random(10, 30), // サイズにランダム性を加える [15]\r\n            vx: dx * 0.5, // 速度を調整\r\n            vy: dy * 0.5,\r\n            color: color(random(100, 255), random(100, 255), random(100, 255), 180) // ランダムな色と透明度 [16]\r\n        };\r\n        \r\n        // 配列の末尾に新しいボールを追加\r\n        balls.push(newBall); [17]\r\n    }\r\n}"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "11/24/2025, 1:24:33 PM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// 最終課題を制作しよう\r\n// プログラム全体で有効な配列として宣言 (関数の外)\r\nlet balls = []; \r\n\r\n// 描画スタイルを管理する定数（任意）\r\nconst BALL_SIZE = 20;\r\n\r\n//キャンバスのサイズを設定。\r\nfunction setup() {\r\n    // キャンバスのサイズをウィンドウと同じにする\r\n    createCanvas(windowWidth, windowHeight);\r\n}\r\n//繰り返し描画関数 (draw())\r\n//背景を再描画し、配列内のすべての物体を更新・描画。\r\nfunction draw() {\r\n    // 背景を塗りつぶして前回の描画を消去する（アニメーションの基本）\r\n    // 例: background(160, 192, 255);\r\n    background(100, 100); // 透明度を低く設定し、動きの軌跡を残す演出も可能\r\n    \r\n    // 配列内の全てのボール（オブジェクト）に対して処理を繰り返す (for文) [12]\r\n    for (let i = 0; i < balls.length; i++) {\r\n        let b = balls[i]; // 現在のボールオブジェクトを参照\r\n        \r\n        // 速度の分だけ位置を移動させる（アニメーション）[13]\r\n        b.x += b.vx;\r\n        b.y += b.vy;\r\n        \r\n        // ボールを描画\r\n        fill(b.color); // ボールごとの色\r\n        noStroke();\r\n        ellipse(b.x, b.y, b.size);\r\n        \r\n        // ★ 作品を拡張する際のポイント：\r\n        // 画面外に出たボールを配列から削除する処理 (演習問題で触れられている)\r\n        if (b.x < -100 || b.x > width + 100 || b.y < -100 || b.y > height + 100) {\r\n            // 配列から削除する処理（popやshiftではない中間要素の削除が必要）\r\n            // このひな型ではシンプルにするため、画面外のボールを消す処理は割愛します\r\n        }\r\n    }\r\n}\r\n//4. インタラクション関数（mouseDragged()）\r\n//マウスをドラッグしたときに新しい物体を生成し、それをアニメーションさせるための初速（vx, vy）を与えます。\r\nfunction mouseDragged() {\r\n    // 少し前のマウスの位置 (pmouseX, pmouseY) を使って、ドラッグの方向と速度を計算 [14]\r\n    const dx = mouseX - pmouseX; \r\n    const dy = mouseY - pmouseY; \r\n    \r\n    // ドラッグ速度が一定以上の場合のみボールを生成（ノイズを防ぐ）[4]\r\n    // mag(x, y) はベクトルの長さ（動いた距離）を計算する関数\r\n    if (mag(dx, dy) > 5) { \r\n        // 新しいボールオブジェクトを作成\r\n        const newBall = {\r\n            x: mouseX, \r\n            y: mouseY, \r\n            size: random(10, 30), // サイズにランダム性を加える [15]\r\n            vx: dx * 0.5, // 速度を調整\r\n            vy: dy * 0.5,\r\n            color: color(random(100, 255), random(100, 255), random(100, 255), 180) // ランダムな色と透明度 [16]\r\n        };\r\n        \r\n        // 配列の末尾に新しいボールを追加\r\n        balls.push(newBall); [17]\r\n    }\r\n}"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "11/24/2025, 1:24:39 PM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// 最終課題を制作しよう\r\n// プログラム全体で有効な配列として宣言 (関数の外)\r\nlet balls = []; \r\n\r\n// 描画スタイルを管理する定数（任意）\r\nconst BALL_SIZE = 20;\r\n\r\n//キャンバスのサイズを設定。\r\nfunction setup() {\r\n    // キャンバスのサイズをウィンドウと同じにする\r\n    createCanvas(windowWidth, windowHeight);\r\n}\r\n//繰り返し描画関数 (draw())\r\n//背景を再描画し、配列内のすべての物体を更新・描画。\r\nfunction draw() {\r\n    // 背景を塗りつぶして前回の描画を消去する（アニメーションの基本）\r\n    // 例: background(160, 192, 255);\r\n    background(0, 100); // 透明度を低く設定し、動きの軌跡を残す演出も可能\r\n    \r\n    // 配列内の全てのボール（オブジェクト）に対して処理を繰り返す (for文) [12]\r\n    for (let i = 0; i < balls.length; i++) {\r\n        let b = balls[i]; // 現在のボールオブジェクトを参照\r\n        \r\n        // 速度の分だけ位置を移動させる（アニメーション）[13]\r\n        b.x += b.vx;\r\n        b.y += b.vy;\r\n        \r\n        // ボールを描画\r\n        fill(b.color); // ボールごとの色\r\n        noStroke();\r\n        ellipse(b.x, b.y, b.size);\r\n        \r\n        // ★ 作品を拡張する際のポイント：\r\n        // 画面外に出たボールを配列から削除する処理 (演習問題で触れられている)\r\n        if (b.x < -100 || b.x > width + 100 || b.y < -100 || b.y > height + 100) {\r\n            // 配列から削除する処理（popやshiftではない中間要素の削除が必要）\r\n            // このひな型ではシンプルにするため、画面外のボールを消す処理は割愛します\r\n        }\r\n    }\r\n}\r\n//4. インタラクション関数（mouseDragged()）\r\n//マウスをドラッグしたときに新しい物体を生成し、それをアニメーションさせるための初速（vx, vy）を与えます。\r\nfunction mouseDragged() {\r\n    // 少し前のマウスの位置 (pmouseX, pmouseY) を使って、ドラッグの方向と速度を計算 [14]\r\n    const dx = mouseX - pmouseX; \r\n    const dy = mouseY - pmouseY; \r\n    \r\n    // ドラッグ速度が一定以上の場合のみボールを生成（ノイズを防ぐ）[4]\r\n    // mag(x, y) はベクトルの長さ（動いた距離）を計算する関数\r\n    if (mag(dx, dy) > 5) { \r\n        // 新しいボールオブジェクトを作成\r\n        const newBall = {\r\n            x: mouseX, \r\n            y: mouseY, \r\n            size: random(10, 30), // サイズにランダム性を加える [15]\r\n            vx: dx * 0.5, // 速度を調整\r\n            vy: dy * 0.5,\r\n            color: color(random(100, 255), random(100, 255), random(100, 255), 180) // ランダムな色と透明度 [16]\r\n        };\r\n        \r\n        // 配列の末尾に新しいボールを追加\r\n        balls.push(newBall); [17]\r\n    }\r\n}"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "11/24/2025, 1:24:47 PM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// 最終課題を制作しよう\r\n// プログラム全体で有効な配列として宣言 (関数の外)\r\nlet balls = []; \r\n\r\n// 描画スタイルを管理する定数（任意）\r\nconst BALL_SIZE = 20;\r\n\r\n//キャンバスのサイズを設定。\r\nfunction setup() {\r\n    // キャンバスのサイズをウィンドウと同じにする\r\n    createCanvas(windowWidth, windowHeight);\r\n}\r\n//繰り返し描画関数 (draw())\r\n//背景を再描画し、配列内のすべての物体を更新・描画。\r\nfunction draw() {\r\n    // 背景を塗りつぶして前回の描画を消去する（アニメーションの基本）\r\n    // 例: background(160, 192, 255);\r\n    background(0, 500); // 透明度を低く設定し、動きの軌跡を残す演出も可能\r\n    \r\n    // 配列内の全てのボール（オブジェクト）に対して処理を繰り返す (for文) [12]\r\n    for (let i = 0; i < balls.length; i++) {\r\n        let b = balls[i]; // 現在のボールオブジェクトを参照\r\n        \r\n        // 速度の分だけ位置を移動させる（アニメーション）[13]\r\n        b.x += b.vx;\r\n        b.y += b.vy;\r\n        \r\n        // ボールを描画\r\n        fill(b.color); // ボールごとの色\r\n        noStroke();\r\n        ellipse(b.x, b.y, b.size);\r\n        \r\n        // ★ 作品を拡張する際のポイント：\r\n        // 画面外に出たボールを配列から削除する処理 (演習問題で触れられている)\r\n        if (b.x < -100 || b.x > width + 100 || b.y < -100 || b.y > height + 100) {\r\n            // 配列から削除する処理（popやshiftではない中間要素の削除が必要）\r\n            // このひな型ではシンプルにするため、画面外のボールを消す処理は割愛します\r\n        }\r\n    }\r\n}\r\n//4. インタラクション関数（mouseDragged()）\r\n//マウスをドラッグしたときに新しい物体を生成し、それをアニメーションさせるための初速（vx, vy）を与えます。\r\nfunction mouseDragged() {\r\n    // 少し前のマウスの位置 (pmouseX, pmouseY) を使って、ドラッグの方向と速度を計算 [14]\r\n    const dx = mouseX - pmouseX; \r\n    const dy = mouseY - pmouseY; \r\n    \r\n    // ドラッグ速度が一定以上の場合のみボールを生成（ノイズを防ぐ）[4]\r\n    // mag(x, y) はベクトルの長さ（動いた距離）を計算する関数\r\n    if (mag(dx, dy) > 5) { \r\n        // 新しいボールオブジェクトを作成\r\n        const newBall = {\r\n            x: mouseX, \r\n            y: mouseY, \r\n            size: random(10, 30), // サイズにランダム性を加える [15]\r\n            vx: dx * 0.5, // 速度を調整\r\n            vy: dy * 0.5,\r\n            color: color(random(100, 255), random(100, 255), random(100, 255), 180) // ランダムな色と透明度 [16]\r\n        };\r\n        \r\n        // 配列の末尾に新しいボールを追加\r\n        balls.push(newBall); [17]\r\n    }\r\n}"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "11/24/2025, 1:25:04 PM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// 最終課題を制作しよう\r\n// プログラム全体で有効な配列として宣言 (関数の外)\r\nlet balls = []; \r\n\r\n// 描画スタイルを管理する定数（任意）\r\nconst BALL_SIZE = 20;\r\n\r\n//キャンバスのサイズを設定。\r\nfunction setup() {\r\n    // キャンバスのサイズをウィンドウと同じにする\r\n    createCanvas(windowWidth, windowHeight);\r\n}\r\n//繰り返し描画関数 (draw())\r\n//背景を再描画し、配列内のすべての物体を更新・描画。\r\nfunction draw() {\r\n    // 背景を塗りつぶして前回の描画を消去する（アニメーションの基本）\r\n    // 例: background(160, 192, 255);\r\n    background(0, 10); // 透明度を低く設定し、動きの軌跡を残す演出も可能\r\n    \r\n    // 配列内の全てのボール（オブジェクト）に対して処理を繰り返す (for文) [12]\r\n    for (let i = 0; i < balls.length; i++) {\r\n        let b = balls[i]; // 現在のボールオブジェクトを参照\r\n        \r\n        // 速度の分だけ位置を移動させる（アニメーション）[13]\r\n        b.x += b.vx;\r\n        b.y += b.vy;\r\n        \r\n        // ボールを描画\r\n        fill(b.color); // ボールごとの色\r\n        noStroke();\r\n        ellipse(b.x, b.y, b.size);\r\n        \r\n        // ★ 作品を拡張する際のポイント：\r\n        // 画面外に出たボールを配列から削除する処理 (演習問題で触れられている)\r\n        if (b.x < -100 || b.x > width + 100 || b.y < -100 || b.y > height + 100) {\r\n            // 配列から削除する処理（popやshiftではない中間要素の削除が必要）\r\n            // このひな型ではシンプルにするため、画面外のボールを消す処理は割愛します\r\n        }\r\n    }\r\n}\r\n//4. インタラクション関数（mouseDragged()）\r\n//マウスをドラッグしたときに新しい物体を生成し、それをアニメーションさせるための初速（vx, vy）を与えます。\r\nfunction mouseDragged() {\r\n    // 少し前のマウスの位置 (pmouseX, pmouseY) を使って、ドラッグの方向と速度を計算 [14]\r\n    const dx = mouseX - pmouseX; \r\n    const dy = mouseY - pmouseY; \r\n    \r\n    // ドラッグ速度が一定以上の場合のみボールを生成（ノイズを防ぐ）[4]\r\n    // mag(x, y) はベクトルの長さ（動いた距離）を計算する関数\r\n    if (mag(dx, dy) > 5) { \r\n        // 新しいボールオブジェクトを作成\r\n        const newBall = {\r\n            x: mouseX, \r\n            y: mouseY, \r\n            size: random(10, 30), // サイズにランダム性を加える [15]\r\n            vx: dx * 0.5, // 速度を調整\r\n            vy: dy * 0.5,\r\n            color: color(random(100, 255), random(100, 255), random(100, 255), 180) // ランダムな色と透明度 [16]\r\n        };\r\n        \r\n        // 配列の末尾に新しいボールを追加\r\n        balls.push(newBall); [17]\r\n    }\r\n}"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "11/24/2025, 1:25:13 PM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// 最終課題を制作しよう\r\n// プログラム全体で有効な配列として宣言 (関数の外)\r\nlet balls = []; \r\n\r\n// 描画スタイルを管理する定数（任意）\r\nconst BALL_SIZE = 20;\r\n\r\n//キャンバスのサイズを設定。\r\nfunction setup() {\r\n    // キャンバスのサイズをウィンドウと同じにする\r\n    createCanvas(windowWidth, windowHeight);\r\n}\r\n//繰り返し描画関数 (draw())\r\n//背景を再描画し、配列内のすべての物体を更新・描画。\r\nfunction draw() {\r\n    // 背景を塗りつぶして前回の描画を消去する（アニメーションの基本）\r\n    // 例: background(160, 192, 255);\r\n    background(0, 50); // 透明度を低く設定し、動きの軌跡を残す演出も可能\r\n    \r\n    // 配列内の全てのボール（オブジェクト）に対して処理を繰り返す (for文) [12]\r\n    for (let i = 0; i < balls.length; i++) {\r\n        let b = balls[i]; // 現在のボールオブジェクトを参照\r\n        \r\n        // 速度の分だけ位置を移動させる（アニメーション）[13]\r\n        b.x += b.vx;\r\n        b.y += b.vy;\r\n        \r\n        // ボールを描画\r\n        fill(b.color); // ボールごとの色\r\n        noStroke();\r\n        ellipse(b.x, b.y, b.size);\r\n        \r\n        // ★ 作品を拡張する際のポイント：\r\n        // 画面外に出たボールを配列から削除する処理 (演習問題で触れられている)\r\n        if (b.x < -100 || b.x > width + 100 || b.y < -100 || b.y > height + 100) {\r\n            // 配列から削除する処理（popやshiftではない中間要素の削除が必要）\r\n            // このひな型ではシンプルにするため、画面外のボールを消す処理は割愛します\r\n        }\r\n    }\r\n}\r\n//4. インタラクション関数（mouseDragged()）\r\n//マウスをドラッグしたときに新しい物体を生成し、それをアニメーションさせるための初速（vx, vy）を与えます。\r\nfunction mouseDragged() {\r\n    // 少し前のマウスの位置 (pmouseX, pmouseY) を使って、ドラッグの方向と速度を計算 [14]\r\n    const dx = mouseX - pmouseX; \r\n    const dy = mouseY - pmouseY; \r\n    \r\n    // ドラッグ速度が一定以上の場合のみボールを生成（ノイズを防ぐ）[4]\r\n    // mag(x, y) はベクトルの長さ（動いた距離）を計算する関数\r\n    if (mag(dx, dy) > 5) { \r\n        // 新しいボールオブジェクトを作成\r\n        const newBall = {\r\n            x: mouseX, \r\n            y: mouseY, \r\n            size: random(10, 30), // サイズにランダム性を加える [15]\r\n            vx: dx * 0.5, // 速度を調整\r\n            vy: dy * 0.5,\r\n            color: color(random(100, 255), random(100, 255), random(100, 255), 180) // ランダムな色と透明度 [16]\r\n        };\r\n        \r\n        // 配列の末尾に新しいボールを追加\r\n        balls.push(newBall); [17]\r\n    }\r\n}"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "11/24/2025, 2:33:52 PM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// 最終課題を制作しよう\r\n// プログラム全体で有効な配列として宣言 (関数の外)\r\nlet balls = []; \r\n\r\n// 描画スタイルを管理する定数（任意）\r\nconst BALL_SIZE = 20;\r\n\r\n//キャンバスのサイズを設定。\r\nfunction setup() {\r\n    // キャンバスのサイズをウィンドウと同じにする\r\n    createCanvas(windowWidth, windowHeight);\r\n}\r\n//繰り返し描画関数 (draw())\r\n//背景を再描画し、配列内のすべての物体を更新・描画。\r\nfunction draw() {\r\n    // 背景を塗りつぶして前回の描画を消去する（アニメーションの基本）\r\n    // 例: background(160, 192, 255);\r\n    background(0, 50); // 透明度を低く設定し、動きの軌跡を残す演出も可能\r\n    \r\n    // 配列内の全てのボール（オブジェクト）に対して処理を繰り返す (for文) [12]\r\n    for (let i = 0; i < balls.length; i++) {\r\n        let b = balls[i]; // 現在のボールオブジェクトを参照\r\n        \r\n        // 速度の分だけ位置を移動させる（アニメーション）[13]\r\n        b.x += b.vx;\r\n        b.y += b.vy;\r\n        \r\n      // 画面外に出たボールを配列から削除する\r\n  const ballsInCanvas = []; // 画面内のボールを一時的に保持する配列\r\n  for(let i = 0; i < balls.length; i++){\r\n    let b = balls[i];\r\n    if(b.x > 0 && b.x < width && b.y > 0 && b.y < height){ // 画面内\r\n      ballsInCanvas.push(b);\r\n    }\r\n  }\r\n  balls = ballsInCanvas; // 画面内のボールだけを残す\r\n\r\n\r\n        // ボールを描画\r\n        fill(b.color); // ボールごとの色\r\n        noStroke();\r\n        ellipse(b.x, b.y, b.size);\r\n        \r\n        // ★ 作品を拡張する際のポイント：\r\n        // 画面外に出たボールを配列から削除する処理 (演習問題で触れられている)\r\n        if (b.x < -100 || b.x > width + 100 || b.y < -100 || b.y > height + 100) {\r\n            // 配列から削除する処理（popやshiftではない中間要素の削除が必要）\r\n            // このひな型ではシンプルにするため、画面外のボールを消す処理は割愛します\r\n        }\r\n    }\r\n}\r\n//4. インタラクション関数（mouseDragged()）\r\n//マウスをドラッグしたときに新しい物体を生成し、それをアニメーションさせるための初速（vx, vy）を与えます。\r\nfunction mouseDragged() {\r\n    // 少し前のマウスの位置 (pmouseX, pmouseY) を使って、ドラッグの方向と速度を計算 [14]\r\n    const dx = mouseX - pmouseX; \r\n    const dy = mouseY - pmouseY; \r\n    \r\n    // ドラッグ速度が一定以上の場合のみボールを生成（ノイズを防ぐ）[4]\r\n    // mag(x, y) はベクトルの長さ（動いた距離）を計算する関数\r\n    if (mag(dx, dy) > 5) { \r\n        // 新しいボールオブジェクトを作成\r\n        const newBall = {\r\n            x: mouseX, \r\n            y: mouseY, \r\n            size: random(10, 30), // サイズにランダム性を加える [15]\r\n            vx: dx * 0.5, // 速度を調整\r\n            vy: dy * 0.5,\r\n            color: color(random(100, 255), random(100, 255), random(100, 255), 180) // ランダムな色と透明度 [16]\r\n        };\r\n        \r\n        // 配列の末尾に新しいボールを追加\r\n        balls.push(newBall); [17]\r\n    }\r\n}"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "11/24/2025, 2:47:52 PM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// 最終課題を制作しよう\r\n// プログラム全体で有効な配列として宣言 (関数の外)\r\nlet balls = []; \r\n\r\n// 描画スタイルを管理する定数（任意）\r\nconst BALL_SIZE = 20;\r\n\r\n//キャンバスのサイズを設定。\r\nfunction setup() {\r\n    // キャンバスのサイズをウィンドウと同じにする\r\n    createCanvas(windowWidth, windowHeight);\r\n}\r\n//繰り返し描画関数 (draw())\r\n//背景を再描画し、配列内のすべての物体を更新・描画。\r\nfunction draw() {\r\n    // 背景を塗りつぶして前回の描画を消去する（アニメーションの基本）\r\n    // 例: background(160, 192, 255);\r\n    background(0, 50); // 透明度を低く設定し、動きの軌跡を残す演出も可能\r\n    \r\n    // 配列内の全てのボール（オブジェクト）に対して処理を繰り返す (for文) [12]\r\n    for (let i = 0; i < balls.length; i++) {\r\n        let b = balls[i]; // 現在のボールオブジェクトを参照\r\n        \r\n        // 速度の分だけ位置を移動させる（アニメーション）[13]\r\n        b.x += b.vx;\r\n        b.y += b.vy;\r\n        \r\n        // 物理法則 導入箇所\r\n  // 1. 重力を適用する（vyを重力分だけ変化させる）\r\n  b.vy += g; \r\n  // 必要に応じて速度に上限を設定し、大きくなりすぎないように調整する\r\n  b.vy = constrain(b.vy, -vyMax, vyMax); // constrainはソースに記載あり [3]\r\n  //b. 画面端での跳ね返り\r\n  //ボールがキャンバスの端に到達したら、速度の向きを反転（-1倍）させることで跳ね返りを表現します。\r\n  // 2. 画面端での跳ね返り処理\r\n  // X方向の跳ね返り\r\n  if (b.x < 0 || b.x > width) { \r\n      b.vx = -1 * b.vx; // 速度を反転させる\r\n  }\r\n  // Y方向の跳ね返り\r\n  if (b.y < 0 || b.y > height) { \r\n      b.vy = -1 * b.vy; // 速度を反転させる\r\n  }\r\n\r\n  // 画面内に位置を戻す処理（速度によっては画面外に出たままになるのを防ぐ）\r\n  b.x = constrain(b.x, 0, width); \r\n  b.y = constrain(b.y, 0, height);\r\n        \r\n      // 画面外に出たボールを配列から削除する\r\n  const ballsInCanvas = []; // 画面内のボールを一時的に保持する配列\r\n  for(let i = 0; i < balls.length; i++){\r\n    let b = balls[i];\r\n    if(b.x > 0 && b.x < width && b.y > 0 && b.y < height){ // 画面内\r\n      ballsInCanvas.push(b);\r\n    }\r\n  }\r\n  balls = ballsInCanvas; // 画面内のボールだけを残す\r\n\r\n\r\n        // ボールを描画\r\n        fill(b.color); // ボールごとの色\r\n        noStroke();\r\n        ellipse(b.x, b.y, b.size);\r\n        \r\n        // ★ 作品を拡張する際のポイント：\r\n        // 画面外に出たボールを配列から削除する処理 (演習問題で触れられている)\r\n        if (b.x < -100 || b.x > width + 100 || b.y < -100 || b.y > height + 100) {\r\n            // 配列から削除する処理（popやshiftではない中間要素の削除が必要）\r\n            // このひな型ではシンプルにするため、画面外のボールを消す処理は割愛します\r\n        }\r\n    }\r\n}\r\n//4. インタラクション関数（mouseDragged()）\r\n//マウスをドラッグしたときに新しい物体を生成し、それをアニメーションさせるための初速（vx, vy）を与えます。\r\nfunction mouseDragged() {\r\n    // 少し前のマウスの位置 (pmouseX, pmouseY) を使って、ドラッグの方向と速度を計算 [14]\r\n    const dx = mouseX - pmouseX; \r\n    const dy = mouseY - pmouseY; \r\n    \r\n    // ドラッグ速度が一定以上の場合のみボールを生成（ノイズを防ぐ）[4]\r\n    // mag(x, y) はベクトルの長さ（動いた距離）を計算する関数\r\n    if (mag(dx, dy) > 5) { \r\n        // 新しいボールオブジェクトを作成\r\n        const newBall = {\r\n            x: mouseX, \r\n            y: mouseY, \r\n            size: random(10, 30), // サイズにランダム性を加える [15]\r\n            vx: dx * 0.5, // 速度を調整\r\n            vy: dy * 0.5,\r\n            color: color(random(100, 255), random(100, 255), random(100, 255), 180) // ランダムな色と透明度 [16]\r\n        };\r\n        \r\n        // 配列の末尾に新しいボールを追加\r\n        balls.push(newBall); [17]\r\n    }\r\n}"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "11/24/2025, 3:06:26 PM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// 最終課題を制作しよう\r\n// プログラム全体で有効な配列として宣言 (関数の外)\r\nlet balls = []; \r\n\r\n// 描画スタイルを管理する定数（任意）\r\nconst BALL_SIZE = 20;\r\nlet g = 0.2;     // ← 重力の値を設定（必須）\r\nlet vyMax = 20;  // ← 最大落下速度（必須）\r\n\r\n//キャンバスのサイズを設定。\r\nfunction setup() {\r\n    // キャンバスのサイズをウィンドウと同じにする\r\n    createCanvas(windowWidth, windowHeight);\r\n}\r\n//繰り返し描画関数 (draw())\r\n//背景を再描画し、配列内のすべての物体を更新・描画。\r\nfunction draw() {\r\n    // 背景を塗りつぶして前回の描画を消去する（アニメーションの基本）\r\n    // 例: background(160, 192, 255);\r\n    background(0, 50); // 透明度を低く設定し、動きの軌跡を残す演出も可能\r\n    \r\n    // 画面内のボールだけ残す（ループの外で行う）\r\n    balls = balls.filter(b => b.x >= 0 && b.x <= width && b.y >= 0 && b.y <= height);\r\n\r\n    // ボールの更新 & 描画\r\n    for (let i = 0; i < balls.length; i++) {\r\n        let b = balls[i]; // 現在のボールオブジェクトを参照\r\n        \r\n        // 速度の分だけ位置を移動させる（アニメーション）位置の更新\r\n        b.x += b.vx;\r\n        b.y += b.vy;\r\n        \r\n        // 重力\r\n        b.vy += g;\r\n        b.vy = constrain(b.vy, -vyMax, vyMax);\r\n\r\n        // 反射 x方向\r\n        if (b.x < 0 || b.x > width) {\r\n            b.vx *= -1; //速度を反転\r\n        }\r\n        // 反射 y方向\r\n        if (b.y < 0 || b.y > height) {\r\n            b.vy *= -1; //速度を反転\r\n        }\r\n\r\n        // 画面内に位置を戻す処理（速度によっては画面外に出たままになるのを防ぐ）\r\n        b.x = constrain(b.x, 0, width); \r\n        b.y = constrain(b.y, 0, height);\r\n      \r\n        // ボールを描画\r\n        fill(b.color); // ボールごとの色\r\n        noStroke();\r\n        ellipse(b.x, b.y, b.size);\r\n        \r\n        // ★ 作品を拡張する際のポイント：\r\n        // 画面外に出たボールを配列から削除する処理 (演習問題で触れられている)\r\n        if (b.x < -100 || b.x > width + 100 || b.y < -100 || b.y > height + 100) {\r\n            // 配列から削除する処理（popやshiftではない中間要素の削除が必要）\r\n            // このひな型ではシンプルにするため、画面外のボールを消す処理は割愛します\r\n        }\r\n    }\r\n}\r\n//アニメーションさせるための初速（vx, vy）を与える。\r\nfunction mouseDragged() {\r\n    // 少し前のマウスの位置 (pmouseX, pmouseY) を使って、ドラッグの方向と速度を計算 [14]\r\n    const dx = mouseX - pmouseX; \r\n    const dy = mouseY - pmouseY; \r\n    \r\n    // ドラッグ速度が一定以上の場合のみボールを生成（ノイズを防ぐ）[4]\r\n    // mag(x, y) はベクトルの長さ（動いた距離）を計算する関数\r\n    if (mag(dx, dy) > 5) { \r\n        // 新しいボールオブジェクトを作成\r\n        const newBall = {\r\n            x: mouseX, \r\n            y: mouseY, \r\n            size: random(10, 30), // サイズにランダム性を加える [15]\r\n            vx: dx * 0.5, // 速度を調整\r\n            vy: dy * 0.5,\r\n            color: color(random(100, 255), random(100, 255), random(100, 255), 180) // ランダムな色と透明度 [16]\r\n        };\r\n        \r\n        // 配列の末尾に新しいボールを追加\r\n        balls.push(newBall); \r\n    }\r\n}"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "11/24/2025, 3:10:12 PM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// 最終課題を制作しよう\r\n// プログラム全体で有効な配列として宣言 (関数の外)\r\nlet balls = []; \r\n\r\n// 描画スタイルを管理する定数（任意）\r\nconst BALL_SIZE = 20;\r\nlet g = 0.2;     // ← 重力の値を設定（必須）\r\nlet vyMax = 20;  // ← 最大落下速度（必須）\r\nconst restitution = -0.8;   // 反発係数（絶対値を小さくするとすぐ止まる）\r\n\r\n//キャンバスのサイズを設定。\r\nfunction setup() {\r\n    // キャンバスのサイズをウィンドウと同じにする\r\n    createCanvas(windowWidth, windowHeight);\r\n}\r\n//繰り返し描画関数 (draw())\r\n//背景を再描画し、配列内のすべての物体を更新・描画。\r\nfunction draw() {\r\n    // 背景を塗りつぶして前回の描画を消去する（アニメーションの基本）\r\n    // 例: background(160, 192, 255);\r\n    background(0, 50); // 透明度を低く設定し、動きの軌跡を残す演出も可能\r\n    \r\n    // 画面内のボールだけ残す（ループの外で行う）\r\n    balls = balls.filter(b => b.x >= 0 && b.x <= width && b.y >= 0 && b.y <= height);\r\n\r\n    // ボールの更新 & 描画\r\n    for (let i = 0; i < balls.length; i++) {\r\n        let b = balls[i]; // 現在のボールオブジェクトを参照\r\n        \r\n        // 速度の分だけ位置を移動させる（アニメーション）位置の更新\r\n        b.x += b.vx;\r\n        b.y += b.vy;\r\n        \r\n        // 重力\r\n        b.vy += g;\r\n        b.vy = constrain(b.vy, -vyMax, vyMax);\r\n\r\n        // 減衰付きの反射 x方向\r\n        if (b.x < 0 || b.x > width) {\r\n            b.vx *= restitution; //速度を反転\r\n        }\r\n        // 減衰付きの反射 y方向\r\n        if (b.y < 0 || b.y > height) {\r\n            b.vy *= restitution; //速度を反転\r\n        }\r\n\r\n        // 画面内に位置を戻す処理（速度によっては画面外に出たままになるのを防ぐ）\r\n        b.x = constrain(b.x, 0, width); \r\n        b.y = constrain(b.y, 0, height);\r\n      \r\n        // ボールを描画\r\n        fill(b.color); // ボールごとの色\r\n        noStroke();\r\n        ellipse(b.x, b.y, b.size);\r\n        \r\n        // ★ 作品を拡張する際のポイント：\r\n        // 画面外に出たボールを配列から削除する処理 (演習問題で触れられている)\r\n        if (b.x < -100 || b.x > width + 100 || b.y < -100 || b.y > height + 100) {\r\n            // 配列から削除する処理（popやshiftではない中間要素の削除が必要）\r\n            // このひな型ではシンプルにするため、画面外のボールを消す処理は割愛します\r\n        }\r\n    }\r\n}\r\n//アニメーションさせるための初速（vx, vy）を与える。\r\nfunction mouseDragged() {\r\n    // 少し前のマウスの位置 (pmouseX, pmouseY) を使って、ドラッグの方向と速度を計算 [14]\r\n    const dx = mouseX - pmouseX; \r\n    const dy = mouseY - pmouseY; \r\n    \r\n    // ドラッグ速度が一定以上の場合のみボールを生成（ノイズを防ぐ）[4]\r\n    // mag(x, y) はベクトルの長さ（動いた距離）を計算する関数\r\n    if (mag(dx, dy) > 5) { \r\n        // 新しいボールオブジェクトを作成\r\n        const newBall = {\r\n            x: mouseX, \r\n            y: mouseY, \r\n            size: random(10, 30), // サイズにランダム性を加える [15]\r\n            vx: dx * 0.5, // 速度を調整\r\n            vy: dy * 0.5,\r\n            color: color(random(100, 255), random(100, 255), random(100, 255), 180) // ランダムな色と透明度 [16]\r\n        };\r\n        \r\n        // 配列の末尾に新しいボールを追加\r\n        balls.push(newBall); \r\n    }\r\n}"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "11/24/2025, 3:20:27 PM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// 最終課題を制作しよう\r\n// プログラム全体で有効な配列として宣言 (関数の外)\r\nlet balls = []; \r\n\r\n// 描画スタイルを管理する定数（任意）\r\nconst BALL_SIZE = 20;\r\nlet g = 0.2;     // 重力の値を設定（必須）\r\nlet vyMax = 20;  // 最大落下速度（必須）\r\nconst restitution = -0.8;   // 跳ね返るたびに減衰\r\n\r\n\r\n//キャンバスのサイズを設定。\r\nfunction setup() {\r\n    // キャンバスのサイズをウィンドウと同じにする\r\n    createCanvas(windowWidth, windowHeight);\r\n}\r\n//繰り返し描画関数 (draw())\r\n//背景を再描画し、配列内のすべての物体を更新・描画。\r\nfunction draw() {\r\n    // 背景を塗りつぶして前回の描画を消去する（アニメーションの基本）\r\n    // 例: background(160, 192, 255);\r\n    background(0, 50); // 透明度を低く設定し、動きの軌跡を残す演出も可能\r\n    \r\n    // 画面内のボールだけ残す（ループの外で行う）\r\n    balls = balls.filter(b => b.x >= 0 && b.x <= width && b.y >= 0 && b.y <= height);\r\n\r\n    // ボールの更新 & 描画\r\n    for (let i = 0; i < balls.length; i++) {\r\n        let b = balls[i]; // 現在のボールオブジェクトを参照\r\n        \r\n        // 速度の分だけ位置を移動させる（アニメーション）位置の更新\r\n        b.x += b.vx;\r\n        b.y += b.vy;\r\n        \r\n        // 重力\r\n        b.vy += g;\r\n        b.vy = constrain(b.vy, -vyMax, vyMax);\r\n\r\n        // 減衰付きの反射 x方向\r\n        if (b.x < 0 || b.x > width) {\r\n            b.vx *= restitution; //速度を反転\r\n        }\r\n        // 減衰付きの反射 y方向\r\n        if (b.y < 0 || b.y > height) {\r\n            b.vy *= restitution; //速度を反転\r\n        }\r\n\r\n        // 画面内に位置を戻す処理（速度によっては画面外に出たままになるのを防ぐ）\r\n        b.x = constrain(b.x, 0, width); \r\n        b.y = constrain(b.y, 0, height);\r\n      \r\n        // ボールを描画\r\n        fill(b.color); // ボールごとの色\r\n        noStroke();\r\n        ellipse(b.x, b.y, b.size);\r\n        \r\n        // ★ 作品を拡張する際のポイント：\r\n        // 画面外に出たボールを配列から削除する処理 (演習問題で触れられている)\r\n        if (b.x < -100 || b.x > width + 100 || b.y < -100 || b.y > height + 100) {\r\n            // 配列から削除する処理（popやshiftではない中間要素の削除が必要）\r\n            // このひな型ではシンプルにするため、画面外のボールを消す処理は割愛します\r\n        }\r\n    }\r\n}\r\n\r\nfunction createBall(x, y, vx, vy) {\r\n    return {\r\n        x: x,\r\n        y: y,\r\n        size: random(10, 30),\r\n        vx: vx,\r\n        vy: vy,\r\n        color: color(\r\n            random(100, 255),\r\n            random(100, 255),\r\n            random(100, 255),\r\n            180\r\n        )\r\n    };\r\n}\r\n//アニメーションさせるための初速（vx, vy）を与える。\r\nfunction mouseDragged() {\r\n    // 少し前のマウスの位置 (pmouseX, pmouseY) を使って、ドラッグの方向と速度を計算 [14]\r\n    const dx = mouseX - pmouseX; \r\n    const dy = mouseY - pmouseY; \r\n    \r\n    // ドラッグ速度が一定以上の場合のみボールを生成（ノイズを防ぐ）[4]\r\n    // mag(x, y) はベクトルの長さ（動いた距離）を計算する関数\r\n    if (mag(dx, dy) > 5) { \r\n        // 新しいボールオブジェクトを作成\r\n        let b = createBall(mouseX, mouseY, dx * 0.5, dy * 0.5);\r\n        \r\n        // 配列の末尾に新しいボールを追加\r\n        balls.push(newBall); \r\n    }\r\n}"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "11/24/2025, 3:35:05 PM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// 最終課題を制作しよう\r\n// プログラム全体で有効な配列として宣言 (関数の外)\r\nlet balls = []; \r\n\r\n// 描画スタイルを管理する定数（任意）\r\nconst BALL_SIZE = 20;\r\nlet g = 0.2;     // 重力の値を設定（必須）\r\nlet vyMax = 20;  // 最大落下速度（必須）\r\nconst restitution = -0.8;   // 跳ね返るたびに減衰\r\n\r\n\r\n//キャンバスのサイズを設定。\r\nfunction setup() {\r\n    // キャンバスのサイズをウィンドウと同じにする\r\n    createCanvas(windowWidth, windowHeight);\r\n}\r\n//繰り返し描画関数 (draw())\r\n//背景を再描画し、配列内のすべての物体を更新・描画。\r\nfunction draw() {\r\n    // 背景を塗りつぶして前回の描画を消去する（アニメーションの基本）\r\n    // 例: background(160, 192, 255);\r\n    background(0, 50); // 透明度を低く設定し、動きの軌跡を残す演出も可能\r\n    \r\n    // 画面内のボールだけ残す（ループの外で行う）\r\n    balls = balls.filter(b => b.x >= 0 && b.x <= width && b.y >= 0 && b.y <= height);\r\n\r\n    // ボールの更新 & 描画\r\n    for (let i = 0; i < balls.length; i++) {\r\n        let b = balls[i]; // 現在のボールオブジェクトを参照\r\n        \r\n        // 速度の分だけ位置を移動させる（アニメーション）位置の更新\r\n        b.x += b.vx;\r\n        b.y += b.vy;\r\n        \r\n        // 重力\r\n        b.vy += g;\r\n        b.vy = constrain(b.vy, -vyMax, vyMax);\r\n\r\n        // 減衰付きの反射 x方向\r\n        if (b.x < 0 || b.x > width) {\r\n            b.vx *= restitution; //速度を反転\r\n        }\r\n        // 減衰付きの反射 y方向\r\n        if (b.y < 0 || b.y > height) {\r\n            b.vy *= restitution; //速度を反転\r\n        }\r\n\r\n        // 画面内に位置を戻す処理（速度によっては画面外に出たままになるのを防ぐ）\r\n        b.x = constrain(b.x, 0, width); \r\n        b.y = constrain(b.y, 0, height);\r\n      \r\n        // ボールを描画\r\n        fill(b.color); // ボールごとの色\r\n        noStroke();\r\n        ellipse(b.x, b.y, b.size);\r\n        \r\n        // ★ 作品を拡張する際のポイント：\r\n        // 画面外に出たボールを配列から削除する処理 (演習問題で触れられている)\r\n        if (b.x < -100 || b.x > width + 100 || b.y < -100 || b.y > height + 100) {\r\n            // 配列から削除する処理（popやshiftではない中間要素の削除が必要）\r\n            // このひな型ではシンプルにするため、画面外のボールを消す処理は割愛します\r\n        }\r\n    }\r\n}\r\n\r\nfunction createBall(x, y, vx, vy) {\r\n    return {\r\n        x: x,\r\n        y: y,\r\n        size: random(10, 30),\r\n        vx: vx,\r\n        vy: vy,\r\n        color: color(\r\n            random(100, 255),\r\n            random(100, 255),\r\n            random(100, 255),\r\n            180\r\n        )\r\n    };\r\n}\r\n//アニメーションさせるための初速（vx, vy）を与える。\r\nfunction mouseDragged() {\r\n    // 少し前のマウスの位置 (pmouseX, pmouseY) を使って、ドラッグの方向と速度を計算 [14]\r\n    const dx = mouseX - pmouseX; \r\n    const dy = mouseY - pmouseY; \r\n    \r\n    // ドラッグ速度が一定以上の場合のみボールを生成（ノイズを防ぐ）[4]\r\n    // mag(x, y) はベクトルの長さ（動いた距離）を計算する関数\r\n    if (mag(dx, dy) > 5) { \r\n        // 新しいボールオブジェクトを作成\r\n        let newBall = createBall(mouseX, mouseY, dx * 0.5, dy * 0.5);\r\n        \r\n        // 配列の末尾に新しいボールを追加\r\n        balls.push(newBall); \r\n    }\r\n}"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "11/24/2025, 3:35:56 PM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// 最終課題を制作しよう\r\n// プログラム全体で有効な配列として宣言 (関数の外)\r\nlet balls = []; \r\n\r\n// 描画スタイルを管理する定数（任意）\r\nconst BALL_SIZE = 20;\r\nlet g = 0.2;     // 重力の値を設定（必須）\r\nlet vyMax = 20;  // 最大落下速度（必須）\r\nconst restitution = -0.8;   // 跳ね返るたびに減衰\r\n\r\n\r\n//キャンバスのサイズを設定。\r\nfunction setup() {\r\n    // キャンバスのサイズをウィンドウと同じにする\r\n    createCanvas(windowWidth, windowHeight);\r\n}\r\n//繰り返し描画関数 (draw())\r\n//背景を再描画し、配列内のすべての物体を更新・描画。\r\nfunction draw() {\r\n    // 背景を塗りつぶして前回の描画を消去する（アニメーションの基本）\r\n    // 例: background(160, 192, 255);\r\n    background(0, 50); // 透明度を低く設定し、動きの軌跡を残す演出も可能\r\n    \r\n    // 画面内のボールだけ残す（ループの外で行う）\r\n    balls = balls.filter(b => b.x >= 0 && b.x <= width && b.y >= 0 && b.y <= height);\r\n\r\n    // ボールの更新 & 描画\r\n    for (let i = 0; i < balls.length; i++) {\r\n        let b = balls[i]; // 現在のボールオブジェクトを参照\r\n        \r\n        // 速度の分だけ位置を移動させる（アニメーション）位置の更新\r\n        b.x += b.vx;\r\n        b.y += b.vy;\r\n        \r\n        // 重力\r\n        b.vy += g;\r\n        b.vy = constrain(b.vy, -vyMax, vyMax);\r\n\r\n        // 減衰付きの反射 x方向\r\n        if (b.x < 0 || b.x > width) {\r\n            b.vx *= restitution; //速度を反転\r\n        }\r\n        // 減衰付きの反射 y方向\r\n        if (b.y < 0 || b.y > height) {\r\n            b.vy *= restitution; //速度を反転\r\n        }\r\n\r\n        // 画面内に位置を戻す処理（速度によっては画面外に出たままになるのを防ぐ）\r\n        b.x = constrain(b.x, 0, width); \r\n        b.y = constrain(b.y, 0, height);\r\n      \r\n        // ボールを描画\r\n        fill(b.color); // ボールごとの色\r\n        noStroke();\r\n        ellipse(b.x, b.y, b.size);\r\n        \r\n        // ★ 作品を拡張する際のポイント：\r\n        // 画面外に出たボールを配列から削除する処理 (演習問題で触れられている)\r\n        if (b.x < -100 || b.x > width + 100 || b.y < -100 || b.y > height + 100) {\r\n            // 配列から削除する処理（popやshiftではない中間要素の削除が必要）\r\n            // このひな型ではシンプルにするため、画面外のボールを消す処理は割愛します\r\n        }\r\n    }\r\n}\r\n\r\nfunction createBall(x, y, vx, vy) {\r\n    return {\r\n        x: x,\r\n        y: y,\r\n        size: random(10, 30),\r\n        vx: vx,\r\n        vy: vy,\r\n        color: color(\r\n            random(100, 255),\r\n            random(100, 255),\r\n            random(100, 255),\r\n            180\r\n        )\r\n    };\r\n}\r\n//アニメーションさせるための初速（vx, vy）を与える。\r\nfunction mouseDragged() {\r\n    // 少し前のマウスの位置 (pmouseX, pmouseY) を使って、ドラッグの方向と速度を計算 [14]\r\n    const dx = mouseX - pmouseX; \r\n    const dy = mouseY - pmouseY; \r\n    \r\n    // ドラッグ速度が一定以上の場合のみボールを生成（ノイズを防ぐ）[4]\r\n    // mag(x, y) はベクトルの長さ（動いた距離）を計算する関数\r\n    if (mag(dx, dy) > 5) { \r\n        // 新しいボールオブジェクトを作成\r\n        let b = createBall(mouseX, mouseY, dx * 0.5, dy * 0.5);\r\n        \r\n        // 配列の末尾に新しいボールを追加\r\n        balls.push(b); \r\n    }\r\n}"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "11/24/2025, 3:39:31 PM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// 最終課題を制作しよう\r\n// プログラム全体で有効な配列として宣言 (関数の外)\r\nlet balls = []; \r\n\r\n// 描画スタイルを管理する定数（任意）\r\nconst BALL_SIZE = 20;\r\nlet g = 0.2;     // 重力の値を設定（必須）\r\nlet vyMax = 20;  // 最大落下速度（必須）\r\nconst restitution = -0.8;   // 跳ね返るたびに減衰\r\n\r\n\r\n//キャンバスのサイズを設定。\r\nfunction setup() {\r\n    // キャンバスのサイズをウィンドウと同じにする\r\n    createCanvas(windowWidth, windowHeight);\r\n}\r\n//繰り返し描画関数 (draw())\r\n//背景を再描画し、配列内のすべての物体を更新・描画。\r\nfunction draw() {\r\n    // 背景を塗りつぶして前回の描画を消去する（アニメーションの基本）\r\n    // 例: background(160, 192, 255);\r\n    background(0, 50); // 透明度を低く設定し、動きの軌跡を残す演出も可能\r\n    \r\n    // 画面内のボールだけ残す（ループの外で行う）\r\n    balls = balls.filter(b => b.x >= 0 && b.x <= width && b.y >= 0 && b.y <= height);\r\n\r\n    // ボールの更新 & 描画\r\n    for (let i = 0; i < balls.length; i++) {\r\n        let b = balls[i]; // 現在のボールオブジェクトを参照\r\n        \r\n        // 速度の分だけ位置を移動させる（アニメーション）位置の更新\r\n        b.x += b.vx;\r\n        b.y += b.vy;\r\n        \r\n        // 重力\r\n        b.vy += g;\r\n        b.vy = constrain(b.vy, -vyMax, vyMax);\r\n\r\n        // 減衰付きの反射 x方向\r\n        if (b.x < 0 || b.x > width) {\r\n            b.vx *= restitution; //速度を反転\r\n        }\r\n        // 減衰付きの反射 y方向\r\n        if (b.y < 0 || b.y > height) {\r\n            b.vy *= restitution; //速度を反転\r\n        }\r\n\r\n        // めり込み防止\r\n        b.x = constrain(b.x, 0, width); \r\n        b.y = constrain(b.y, 0, height);\r\n      \r\n        // ボールを描画\r\n        fill(b.color); // ボールごとの色\r\n        noStroke();\r\n        ellipse(b.x, b.y, b.size);\r\n        \r\n        // ★ 作品を拡張する際のポイント：\r\n        // 画面外に出たボールを配列から削除する処理 (演習問題で触れられている)\r\n        if (b.x < -100 || b.x > width + 100 || b.y < -100 || b.y > height + 100) {\r\n            // 配列から削除する処理（popやshiftではない中間要素の削除が必要）\r\n            // このひな型ではシンプルにするため、画面外のボールを消す処理は割愛します\r\n        }\r\n    }\r\n}\r\n\r\nfunction createBall(x, y, vx, vy) {\r\n    return {\r\n        x: x,\r\n        y: y,\r\n        size: random(10, 30),\r\n        vx: vx,\r\n        vy: vy,\r\n        color: color(\r\n            random(100, 255),\r\n            random(100, 255),\r\n            random(100, 255),\r\n            180\r\n        )\r\n    };\r\n}\r\n//アニメーションさせるための初速（vx, vy）を与える。\r\nfunction mouseDragged() {\r\n    // 少し前のマウスの位置 (pmouseX, pmouseY) を使って、ドラッグの方向と速度を計算 [14]\r\n    const dx = mouseX - pmouseX; \r\n    const dy = mouseY - pmouseY; \r\n    \r\n    // ドラッグ速度が一定以上の場合のみボールを生成（ノイズを防ぐ）[4]\r\n    // mag(x, y) はベクトルの長さ（動いた距離）を計算する関数\r\n    if (mag(dx, dy) > 5) { \r\n        // 新しいボールオブジェクトを作成\r\n        let b = createBall(mouseX, mouseY, dx * 0.5, dy * 0.5);\r\n        \r\n        // 配列の末尾に新しいボールを追加\r\n        balls.push(b); \r\n    }\r\n}"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "11/24/2025, 3:40:11 PM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// 最終課題を制作しよう\r\n// プログラム全体で有効な配列として宣言 (関数の外)\r\nlet balls = []; \r\n\r\n// 描画スタイルを管理する定数（任意）\r\nconst BALL_SIZE = 20;\r\nlet g = 0.2;     // 重力の値を設定（必須）\r\nlet vyMax = 20;  // 最大落下速度（必須）\r\nconst restitution = -0.8;   // 跳ね返るたびに減衰\r\n\r\n\r\n//キャンバスのサイズを設定。\r\nfunction setup() {\r\n    // キャンバスのサイズをウィンドウと同じにする\r\n    createCanvas(windowWidth, windowHeight);\r\n}\r\n//繰り返し描画関数 (draw())\r\n//背景を再描画し、配列内のすべての物体を更新・描画。\r\nfunction draw() {\r\n    // 背景を塗りつぶして前回の描画を消去する（アニメーションの基本）\r\n    // 例: background(160, 192, 255);\r\n    background(0, 50); // 透明度を低く設定し、動きの軌跡を残す演出も可能\r\n    \r\n    // 画面内のボールだけ残す（ループの外で行う）\r\n    balls = balls.filter(b => b.x >= 0 && b.x <= width && b.y >= 0 && b.y <= height);\r\n\r\n    // ボールの更新 & 描画\r\n    for (let i = 0; i < balls.length; i++) {\r\n        let b = balls[i]; // 現在のボールオブジェクトを参照\r\n        \r\n        // 速度の分だけ位置を移動させる（アニメーション）位置の更新\r\n        b.x += b.vx;\r\n        b.y += b.vy;\r\n        \r\n        // 重力\r\n        b.vy += g;\r\n        b.vy = constrain(b.vy, -vyMax, vyMax);\r\n\r\n        // 減衰付きの反射 x方向\r\n        if (b.x < 0 || b.x > width) {\r\n            b.vx *= restitution; //速度を反転\r\n        }\r\n        // 減衰付きの反射 y方向\r\n        if (b.y < 0 || b.y > height) {\r\n            b.vy *= restitution; //速度を反転\r\n        }\r\n\r\n        // めり込み防止\r\n        b.x = constrain(b.x, 0, width); \r\n        b.y = constrain(b.y, 0, height);\r\n      \r\n        // ボールを描画\r\n        fill(b.color); // ボールごとの色\r\n        noStroke();\r\n        ellipse(b.x, b.y, b.size);\r\n        \r\n        \r\n        }\r\n    }\r\n\r\nfunction createBall(x, y, vx, vy) {\r\n    return {\r\n        x: x,\r\n        y: y,\r\n        size: random(10, 30),\r\n        vx: vx,\r\n        vy: vy,\r\n        color: color(\r\n            random(100, 255),\r\n            random(100, 255),\r\n            random(100, 255),\r\n            180\r\n        )\r\n    };\r\n}\r\n//アニメーションさせるための初速（vx, vy）を与える。\r\nfunction mouseDragged() {\r\n    // 少し前のマウスの位置 (pmouseX, pmouseY) を使って、ドラッグの方向と速度を計算 [14]\r\n    const dx = mouseX - pmouseX; \r\n    const dy = mouseY - pmouseY; \r\n    \r\n    // ドラッグ速度が一定以上の場合のみボールを生成（ノイズを防ぐ）[4]\r\n    // mag(x, y) はベクトルの長さ（動いた距離）を計算する関数\r\n    if (mag(dx, dy) > 5) { \r\n        // 新しいボールオブジェクトを作成\r\n        let b = createBall(mouseX, mouseY, dx * 0.5, dy * 0.5);\r\n        \r\n        // 配列の末尾に新しいボールを追加\r\n        balls.push(b); \r\n    }\r\n}"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "11/24/2025, 3:43:25 PM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// 最終課題を制作しよう\r\n// プログラム全体で有効な配列として宣言 (関数の外)\r\nlet balls = []; \r\n\r\n// 描画スタイルを管理する定数（任意）\r\nconst BALL_SIZE = 20;\r\nlet g = 0.2;     // 重力の値を設定（必須）\r\nlet vyMax = 20;  // 最大落下速度（必須）\r\nconst restitution = -0.8;   // 跳ね返るたびに減衰\r\n\r\n\r\n//キャンバスのサイズを設定。\r\nfunction setup() {\r\n    // キャンバスのサイズをウィンドウと同じにする\r\n    createCanvas(windowWidth, windowHeight);\r\n}\r\n//繰り返し描画関数 (draw())\r\n//背景を再描画し、配列内のすべての物体を更新・描画。\r\nfunction draw() {\r\n    // 背景を塗りつぶして前回の描画を消去する（アニメーションの基本）\r\n    // 例: background(160, 192, 255);\r\n    background(0, 50); // 透明度を低く設定し、動きの軌跡を残す演出も可能\r\n    \r\n    // ★ ここで速度が小さくなったボールを消す\r\n    balls = balls.filter(b => {\r\n        const speed = sqrt(b.vx * b.vx + b.vy * b.vy);\r\n        return speed > 0.1;   // 速度が小さいボールを削除\r\n    });\r\n\r\n    // ボールの更新 & 描画\r\n    for (let i = 0; i < balls.length; i++) {\r\n        let b = balls[i]; // 現在のボールオブジェクトを参照\r\n        \r\n        // 速度の分だけ位置を移動させる（アニメーション）位置の更新\r\n        b.x += b.vx;\r\n        b.y += b.vy;\r\n        \r\n        // 重力\r\n        b.vy += g;\r\n        b.vy = constrain(b.vy, -vyMax, vyMax);\r\n\r\n        // 減衰付きの反射 x方向\r\n        if (b.x < 0 || b.x > width) {\r\n            b.vx *= restitution; //速度を反転\r\n        }\r\n        // 減衰付きの反射 y方向\r\n        if (b.y < 0 || b.y > height) {\r\n            b.vy *= restitution; //速度を反転\r\n        }\r\n\r\n        // めり込み防止\r\n        b.x = constrain(b.x, 0, width); \r\n        b.y = constrain(b.y, 0, height);\r\n      \r\n        // ボールを描画\r\n        fill(b.color); // ボールごとの色\r\n        noStroke();\r\n        ellipse(b.x, b.y, b.size);\r\n      \r\n        \r\n        }\r\n    }\r\n\r\nfunction createBall(x, y, vx, vy) {\r\n    return {\r\n        x: x,\r\n        y: y,\r\n        size: random(10, 30),\r\n        vx: vx,\r\n        vy: vy,\r\n        color: color(\r\n            random(100, 255),\r\n            random(100, 255),\r\n            random(100, 255),\r\n            180\r\n        )\r\n    };\r\n}\r\n//アニメーションさせるための初速（vx, vy）を与える。\r\nfunction mouseDragged() {\r\n    // 少し前のマウスの位置 (pmouseX, pmouseY) を使って、ドラッグの方向と速度を計算 [14]\r\n    const dx = mouseX - pmouseX; \r\n    const dy = mouseY - pmouseY; \r\n    \r\n    // ドラッグ速度が一定以上の場合のみボールを生成（ノイズを防ぐ）[4]\r\n    // mag(x, y) はベクトルの長さ（動いた距離）を計算する関数\r\n    if (mag(dx, dy) > 5) { \r\n        // 新しいボールオブジェクトを作成\r\n        let b = createBall(mouseX, mouseY, dx * 0.5, dy * 0.5);\r\n        \r\n        // 配列の末尾に新しいボールを追加\r\n        balls.push(b); \r\n    }\r\n}"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "11/24/2025, 3:45:33 PM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// 最終課題を制作しよう\r\n// プログラム全体で有効な配列として宣言 (関数の外)\r\nlet balls = []; \r\n\r\n// 描画スタイルを管理する定数（任意）\r\nconst BALL_SIZE = 20;\r\nlet g = 0.2;     // 重力の値を設定（必須）\r\nlet vyMax = 20;  // 最大落下速度（必須）\r\nconst restitution = -0.8;   // 跳ね返るたびに減衰\r\n\r\n\r\n//キャンバスのサイズを設定。\r\nfunction setup() {\r\n    // キャンバスのサイズをウィンドウと同じにする\r\n    createCanvas(windowWidth, windowHeight);\r\n}\r\n//繰り返し描画関数 (draw())\r\n//背景を再描画し、配列内のすべての物体を更新・描画。\r\nfunction draw() {\r\n    // 背景を塗りつぶして前回の描画を消去する（アニメーションの基本）\r\n    // 例: background(160, 192, 255);\r\n    background(0, 50); // 透明度を低く設定し、動きの軌跡を残す演出も可能\r\n    \r\n    // ★ ここで速度が小さくて\"床の上で止まった\"ボールだけを消す\r\n    balls = balls.filter(b => {\r\n        const speed = sqrt(b.vx * b.vx + b.vy * b.vy);\r\n        // speed が小さく & 地面で止まっている → 消す\r\n        if (speed < 0.1 && b.y >= height - 1) {\r\n            return false;\r\n        }\r\n\r\n        return true; // 残す\r\n    });\r\n    // ボールの更新 & 描画\r\n    for (let i = 0; i < balls.length; i++) {\r\n        let b = balls[i]; // 現在のボールオブジェクトを参照\r\n        \r\n        // 速度の分だけ位置を移動させる（アニメーション）位置の更新\r\n        b.x += b.vx;\r\n        b.y += b.vy;\r\n        \r\n        // 重力\r\n        b.vy += g;\r\n        b.vy = constrain(b.vy, -vyMax, vyMax);\r\n\r\n        // 減衰付きの反射 x方向\r\n        if (b.x < 0 || b.x > width) {\r\n            b.vx *= restitution; //速度を反転\r\n        }\r\n        // 減衰付きの反射 y方向\r\n        if (b.y < 0 || b.y > height) {\r\n            b.vy *= restitution; //速度を反転\r\n        }\r\n\r\n        // めり込み防止\r\n        b.x = constrain(b.x, 0, width); \r\n        b.y = constrain(b.y, 0, height);\r\n      \r\n        // ボールを描画\r\n        fill(b.color); // ボールごとの色\r\n        noStroke();\r\n        ellipse(b.x, b.y, b.size);\r\n      \r\n        \r\n        }\r\n    }\r\n\r\nfunction createBall(x, y, vx, vy) {\r\n    return {\r\n        x: x,\r\n        y: y,\r\n        size: random(10, 30),\r\n        vx: vx,\r\n        vy: vy,\r\n        color: color(\r\n            random(100, 255),\r\n            random(100, 255),\r\n            random(100, 255),\r\n            180\r\n        )\r\n    };\r\n}\r\n//アニメーションさせるための初速（vx, vy）を与える。\r\nfunction mouseDragged() {\r\n    // 少し前のマウスの位置 (pmouseX, pmouseY) を使って、ドラッグの方向と速度を計算 [14]\r\n    const dx = mouseX - pmouseX; \r\n    const dy = mouseY - pmouseY; \r\n    \r\n    // ドラッグ速度が一定以上の場合のみボールを生成（ノイズを防ぐ）[4]\r\n    // mag(x, y) はベクトルの長さ（動いた距離）を計算する関数\r\n    if (mag(dx, dy) > 5) { \r\n        // 新しいボールオブジェクトを作成\r\n        let b = createBall(mouseX, mouseY, dx * 0.5, dy * 0.5);\r\n        \r\n        // 配列の末尾に新しいボールを追加\r\n        balls.push(b); \r\n    }\r\n}"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "11/24/2025, 3:46:26 PM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// 最終課題を制作しよう\r\n// プログラム全体で有効な配列として宣言 (関数の外)\r\nlet balls = []; \r\n\r\n// 描画スタイルを管理する定数（任意）\r\nconst BALL_SIZE = 20;\r\nlet g = 0.2;     // 重力の値を設定（必須）\r\nlet vyMax = 20;  // 最大落下速度（必須）\r\nconst restitution = -0.8;   // 跳ね返るたびに減衰\r\n\r\n\r\n//キャンバスのサイズを設定。\r\nfunction setup() {\r\n    // キャンバスのサイズをウィンドウと同じにする\r\n    createCanvas(windowWidth, windowHeight);\r\n}\r\n//繰り返し描画関数 (draw())\r\n//背景を再描画し、配列内のすべての物体を更新・描画。\r\nfunction draw() {\r\n    // 背景を塗りつぶして前回の描画を消去する（アニメーションの基本）\r\n    // 例: background(160, 192, 255);\r\n    background(0, 50); // 透明度を低く設定し、動きの軌跡を残す演出も可能\r\n    \r\n    // ★ ここで速度が小さくて\"床の上で止まった\"ボールだけを消す\r\n    balls = balls.filter(b => {\r\n        const speed = sqrt(b.vx * b.vx + b.vy * b.vy);\r\n        // speed が小さく & 地面で止まっている → 消す\r\n        if (speed < 0.1 && b.y >= height - 1) {\r\n            return false;\r\n        }\r\n\r\n            return true; // 残す\r\n    });\r\n    // ボールの更新 & 描画\r\n    for (let i = 0; i < balls.length; i++) {\r\n        let b = balls[i]; // 現在のボールオブジェクトを参照\r\n        \r\n        // 速度の分だけ位置を移動させる（アニメーション）位置の更新\r\n        b.x += b.vx;\r\n        b.y += b.vy;\r\n        \r\n        // 重力\r\n        b.vy += g;\r\n        b.vy = constrain(b.vy, -vyMax, vyMax);\r\n\r\n        // 減衰付きの反射 x方向\r\n        if (b.x < 0 || b.x > width) {\r\n            b.vx *= restitution; //速度を反転\r\n        }\r\n        // 減衰付きの反射 y方向\r\n        if (b.y < 0 || b.y > height) {\r\n            b.vy *= restitution; //速度を反転\r\n        }\r\n\r\n        // めり込み防止\r\n        b.x = constrain(b.x, 0, width); \r\n        b.y = constrain(b.y, 0, height);\r\n      \r\n        // ボールを描画\r\n        fill(b.color); // ボールごとの色\r\n        noStroke();\r\n        ellipse(b.x, b.y, b.size);\r\n      \r\n        \r\n        }\r\n    }\r\n\r\nfunction createBall(x, y, vx, vy) {\r\n    return {\r\n        x: x,\r\n        y: y,\r\n        size: random(10, 30),\r\n        vx: vx,\r\n        vy: vy,\r\n        color: color(\r\n            random(100, 255),\r\n            random(100, 255),\r\n            random(100, 255),\r\n            180\r\n        )\r\n    };\r\n}\r\n//アニメーションさせるための初速（vx, vy）を与える。\r\nfunction mouseDragged() {\r\n    // 少し前のマウスの位置 (pmouseX, pmouseY) を使って、ドラッグの方向と速度を計算 [14]\r\n    const dx = mouseX - pmouseX; \r\n    const dy = mouseY - pmouseY; \r\n    \r\n    // ドラッグ速度が一定以上の場合のみボールを生成（ノイズを防ぐ）[4]\r\n    // mag(x, y) はベクトルの長さ（動いた距離）を計算する関数\r\n    if (mag(dx, dy) > 5) { \r\n        // 新しいボールオブジェクトを作成\r\n        let b = createBall(mouseX, mouseY, dx * 0.5, dy * 0.5);\r\n        \r\n        // 配列の末尾に新しいボールを追加\r\n        balls.push(b); \r\n    }\r\n}"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "11/24/2025, 3:49:17 PM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// 最終課題を制作しよう\r\n// プログラム全体で有効な配列として宣言 (関数の外)\r\nlet balls = []; \r\n\r\n// 描画スタイルを管理する定数（任意）\r\nconst BALL_SIZE = 20;\r\nlet g = 0.2;     // 重力の値を設定（必須）\r\nlet vyMax = 20;  // 最大落下速度（必須）\r\nconst restitution = -0.8;   // 跳ね返るたびに減衰\r\n\r\n\r\n//キャンバスのサイズを設定。\r\nfunction setup() {\r\n    // キャンバスのサイズをウィンドウと同じにする\r\n    createCanvas(windowWidth, windowHeight);\r\n}\r\n//繰り返し描画関数 (draw())\r\n//背景を再描画し、配列内のすべての物体を更新・描画。\r\nfunction draw() {\r\n    // 背景を塗りつぶして前回の描画を消去する（アニメーションの基本）\r\n    // 例: background(160, 192, 255);\r\n    background(0, 50); // 透明度を低く設定し、動きの軌跡を残す演出も可能\r\n    \r\n    // ★止まったボールを削除\r\n    balls = balls.filter(b => {\r\n        const speed = sqrt(b.vx * b.vx + b.vy * b.vy);\r\n        const r = b.size / 2;\r\n\r\n        // ゆっくりで床に触れている → 消す\r\n        if (speed < 0.1 && b.y + r >= height) {\r\n            return false;\r\n        }\r\n        return true;\r\n    });\r\n\r\n    for (let i = 0; i < balls.length; i++) {\r\n        let b = balls[i];\r\n        let r = b.size / 2;\r\n\r\n    // ボールの更新 & 描画\r\n    for (let i = 0; i < balls.length; i++) {\r\n        let b = balls[i]; // 現在のボールオブジェクトを参照\r\n        \r\n        // 速度の分だけ位置を移動させる（アニメーション）位置の更新\r\n        b.x += b.vx;\r\n        b.y += b.vy;\r\n        \r\n        // 重力\r\n        b.vy += g;\r\n        b.vy = constrain(b.vy, -vyMax, vyMax);\r\n\r\n        // ★跳ね返り（半径を考慮）\r\n        // 左\r\n        if (b.x - r < 0) {\r\n            b.x = r;\r\n            b.vx *= restitution;\r\n        }\r\n        // 右\r\n        if (b.x + r > width) {\r\n            b.x = width - r;\r\n            b.vx *= restitution;\r\n        }\r\n        // 上\r\n        if (b.y - r < 0) {\r\n            b.y = r;\r\n            b.vy *= restitution;\r\n        }\r\n        // 下\r\n        if (b.y + r > height) {\r\n            b.y = height - r;\r\n            b.vy *= restitution;\r\n        }\r\n      \r\n        // ボールを描画\r\n        fill(b.color); // ボールごとの色\r\n        noStroke();\r\n        ellipse(b.x, b.y, b.size);\r\n      \r\n        \r\n        }\r\n    }\r\n\r\nfunction createBall(x, y, vx, vy) {\r\n    return {\r\n        x: x,\r\n        y: y,\r\n        size: random(10, 30),\r\n        vx: vx,\r\n        vy: vy,\r\n        color: color(\r\n            random(100, 255),\r\n            random(100, 255),\r\n            random(100, 255),\r\n            180\r\n        )\r\n    };\r\n}\r\n//アニメーションさせるための初速（vx, vy）を与える。\r\nfunction mouseDragged() {\r\n    // 少し前のマウスの位置 (pmouseX, pmouseY) を使って、ドラッグの方向と速度を計算 [14]\r\n    const dx = mouseX - pmouseX; \r\n    const dy = mouseY - pmouseY; \r\n    \r\n    // ドラッグ速度が一定以上の場合のみボールを生成（ノイズを防ぐ）[4]\r\n    // mag(x, y) はベクトルの長さ（動いた距離）を計算する関数\r\n    if (mag(dx, dy) > 5) { \r\n        // 新しいボールオブジェクトを作成\r\n        let b = createBall(mouseX, mouseY, dx * 0.5, dy * 0.5);\r\n        \r\n        // 配列の末尾に新しいボールを追加\r\n        balls.push(b); \r\n    }\r\n}"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "11/24/2025, 3:49:33 PM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// 最終課題を制作しよう\r\n// プログラム全体で有効な配列として宣言 (関数の外)\r\nlet balls = []; \r\n\r\n// 描画スタイルを管理する定数（任意）\r\nconst BALL_SIZE = 20;\r\nlet g = 0.2;     // 重力の値を設定（必須）\r\nlet vyMax = 20;  // 最大落下速度（必須）\r\nconst restitution = -0.8;   // 跳ね返るたびに減衰\r\n\r\n\r\n//キャンバスのサイズを設定。\r\nfunction setup() {\r\n    // キャンバスのサイズをウィンドウと同じにする\r\n    createCanvas(windowWidth, windowHeight);\r\n}\r\n//繰り返し描画関数 (draw())\r\n//背景を再描画し、配列内のすべての物体を更新・描画。\r\nfunction draw() {\r\n    // 背景を塗りつぶして前回の描画を消去する（アニメーションの基本）\r\n    // 例: background(160, 192, 255);\r\n    background(0, 50); // 透明度を低く設定し、動きの軌跡を残す演出も可能\r\n    \r\n    // ★止まったボールを削除\r\n    balls = balls.filter(b => {\r\n        const speed = sqrt(b.vx * b.vx + b.vy * b.vy);\r\n        const r = b.size / 2;\r\n\r\n        // ゆっくりで床に触れている → 消す\r\n        if (speed < 0.1 && b.y + r >= height) {\r\n            return false;\r\n        }\r\n        return true;\r\n    });\r\n\r\n    for (let i = 0; i < balls.length; i++) {\r\n        let b = balls[i];\r\n        let r = b.size / 2;\r\n\r\n    // ボールの更新 & 描画\r\n    for (let i = 0; i < balls.length; i++) {\r\n        let b = balls[i]; // 現在のボールオブジェクトを参照\r\n        \r\n        // 速度の分だけ位置を移動させる（アニメーション）位置の更新\r\n        b.x += b.vx;\r\n        b.y += b.vy;\r\n        \r\n        // 重力\r\n        b.vy += g;\r\n        b.vy = constrain(b.vy, -vyMax, vyMax);\r\n\r\n        // ★跳ね返り（半径を考慮）\r\n        // 左\r\n        if (b.x - r < 0) {\r\n            b.x = r;\r\n            b.vx *= restitution;\r\n        }\r\n        // 右\r\n        if (b.x + r > width) {\r\n            b.x = width - r;\r\n            b.vx *= restitution;\r\n        }\r\n        // 上\r\n        if (b.y - r < 0) {\r\n            b.y = r;\r\n            b.vy *= restitution;\r\n        }\r\n        // 下\r\n        if (b.y + r > height) {\r\n            b.y = height - r;\r\n            b.vy *= restitution;\r\n        }\r\n      \r\n        // ボールを描画\r\n        fill(b.color); // ボールごとの色\r\n        noStroke();\r\n        ellipse(b.x, b.y, b.size);\r\n      \r\n        \r\n        }\r\n    }\r\n\r\nfunction createBall(x, y, vx, vy) {\r\n    return {\r\n        x: x,\r\n        y: y,\r\n        size: random(10, 30),\r\n        vx: vx,\r\n        vy: vy,\r\n        color: color(\r\n            random(100, 255),\r\n            random(100, 255),\r\n            random(100, 255),\r\n            180\r\n        )\r\n    };\r\n}\r\n//アニメーションさせるための初速（vx, vy）を与える。\r\nfunction mouseDragged() {\r\n    // 少し前のマウスの位置 (pmouseX, pmouseY) を使って、ドラッグの方向と速度を計算 [14]\r\n    const dx = mouseX - pmouseX; \r\n    const dy = mouseY - pmouseY; \r\n    \r\n    // ドラッグ速度が一定以上の場合のみボールを生成（ノイズを防ぐ）[4]\r\n    // mag(x, y) はベクトルの長さ（動いた距離）を計算する関数\r\n    if (mag(dx, dy) > 5) { \r\n        // 新しいボールオブジェクトを作成\r\n        let b = createBall(mouseX, mouseY, dx * 0.5, dy * 0.5);\r\n        \r\n        // 配列の末尾に新しいボールを追加\r\n        balls.push(b); \r\n    }\r\n}"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "11/24/2025, 3:49:59 PM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// 最終課題を制作しよう\r\n// プログラム全体で有効な配列として宣言 (関数の外)\r\nlet balls = []; \r\n\r\n// 描画スタイルを管理する定数（任意）\r\nconst BALL_SIZE = 20;\r\nlet g = 0.2;     // 重力の値を設定（必須）\r\nlet vyMax = 20;  // 最大落下速度（必須）\r\nconst restitution = -0.8;   // 跳ね返るたびに減衰\r\n\r\n\r\n//キャンバスのサイズを設定。\r\nfunction setup() {\r\n    // キャンバスのサイズをウィンドウと同じにする\r\n    createCanvas(windowWidth, windowHeight);\r\n}\r\n//繰り返し描画関数 (draw())\r\n//背景を再描画し、配列内のすべての物体を更新・描画。\r\nfunction draw() {\r\n    // 背景を塗りつぶして前回の描画を消去する（アニメーションの基本）\r\n    // 例: background(160, 192, 255);\r\n    background(0, 50); // 透明度を低く設定し、動きの軌跡を残す演出も可能\r\n    \r\n    // ★止まったボールを削除\r\n    balls = balls.filter(b => {\r\n        const speed = sqrt(b.vx * b.vx + b.vy * b.vy);\r\n        const r = b.size / 2;\r\n\r\n        // ゆっくりで床に触れている → 消す\r\n        if (speed < 0.1 && b.y + r >= height) {\r\n            return false;\r\n        }\r\n        return true;\r\n    });\r\n\r\n    for (let i = 0; i < balls.length; i++) {\r\n        let b = balls[i];\r\n        let r = b.size / 2;\r\n\r\n    // ボールの更新 & 描画\r\n    for (let i = 0; i < balls.length; i++) {\r\n        let b = balls[i]; // 現在のボールオブジェクトを参照\r\n        \r\n        // 速度の分だけ位置を移動させる（アニメーション）位置の更新\r\n        b.x += b.vx;\r\n        b.y += b.vy;\r\n        \r\n        // 重力\r\n        b.vy += g;\r\n        b.vy = constrain(b.vy, -vyMax, vyMax);\r\n\r\n        // ★跳ね返り（半径を考慮）\r\n        // 左\r\n        if (b.x - r < 0) {\r\n            b.x = r;\r\n            b.vx *= restitution;\r\n        }\r\n        // 右\r\n        if (b.x + r > width) {\r\n            b.x = width - r;\r\n            b.vx *= restitution;\r\n        }\r\n        // 上\r\n        if (b.y - r < 0) {\r\n            b.y = r;\r\n            b.vy *= restitution;\r\n        }\r\n        // 下\r\n        if (b.y + r > height) {\r\n            b.y = height - r;\r\n            b.vy *= restitution;\r\n        }\r\n      \r\n        // ボールを描画\r\n        fill(b.color); // ボールごとの色\r\n        noStroke();\r\n        ellipse(b.x, b.y, b.size);\r\n      \r\n      }\r\n        }\r\n    }\r\n\r\nfunction createBall(x, y, vx, vy) {\r\n    return {\r\n        x: x,\r\n        y: y,\r\n        size: random(10, 30),\r\n        vx: vx,\r\n        vy: vy,\r\n        color: color(\r\n            random(100, 255),\r\n            random(100, 255),\r\n            random(100, 255),\r\n            180\r\n        )\r\n    };\r\n}\r\n//アニメーションさせるための初速（vx, vy）を与える。\r\nfunction mouseDragged() {\r\n    // 少し前のマウスの位置 (pmouseX, pmouseY) を使って、ドラッグの方向と速度を計算 [14]\r\n    const dx = mouseX - pmouseX; \r\n    const dy = mouseY - pmouseY; \r\n    \r\n    // ドラッグ速度が一定以上の場合のみボールを生成（ノイズを防ぐ）[4]\r\n    // mag(x, y) はベクトルの長さ（動いた距離）を計算する関数\r\n    if (mag(dx, dy) > 5) { \r\n        // 新しいボールオブジェクトを作成\r\n        let b = createBall(mouseX, mouseY, dx * 0.5, dy * 0.5);\r\n        \r\n        // 配列の末尾に新しいボールを追加\r\n        balls.push(b); \r\n    }\r\n}"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "11/24/2025, 3:50:44 PM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// 最終課題を制作しよう\r\n// プログラム全体で有効な配列として宣言 (関数の外)\r\nlet balls = []; \r\n\r\n// 描画スタイルを管理する定数（任意）\r\nconst BALL_SIZE = 20;\r\nlet g = 0.2;     // 重力の値を設定（必須）\r\nlet vyMax = 20;  // 最大落下速度（必須）\r\nconst restitution = -0.8;   // 跳ね返るたびに減衰\r\n\r\n\r\n//キャンバスのサイズを設定。\r\nfunction setup() {\r\n    // キャンバスのサイズをウィンドウと同じにする\r\n    createCanvas(windowWidth, windowHeight);\r\n}\r\n//繰り返し描画関数 (draw())\r\n//背景を再描画し、配列内のすべての物体を更新・描画。\r\nfunction draw() {\r\n    // 背景を塗りつぶして前回の描画を消去する（アニメーションの基本）\r\n    // 例: background(160, 192, 255);\r\n    background(0, 50); // 透明度を低く設定し、動きの軌跡を残す演出も可能\r\n    \r\n    // ★止まったボールを削除\r\n    balls = balls.filter(b => {\r\n        const speed = sqrt(b.vx * b.vx + b.vy * b.vy);\r\n        const r = b.size / 2;\r\n\r\n        // ゆっくりで床に触れている → 消す\r\n        if (speed < 0.1 && b.y + r >= height) {\r\n            return false;\r\n        }\r\n        return true;\r\n})\r\n\r\n    for (let i = 0; i < balls.length; i++) {\r\n        let b = balls[i];\r\n        let r = b.size / 2;\r\n\r\n    // ボールの更新 & 描画\r\n    for (let i = 0; i < balls.length; i++) {\r\n        let b = balls[i]; // 現在のボールオブジェクトを参照\r\n        \r\n        // 速度の分だけ位置を移動させる（アニメーション）位置の更新\r\n        b.x += b.vx;\r\n        b.y += b.vy;\r\n        \r\n        // 重力\r\n        b.vy += g;\r\n        b.vy = constrain(b.vy, -vyMax, vyMax);\r\n\r\n        // ★跳ね返り（半径を考慮）\r\n        // 左\r\n        if (b.x - r < 0) {\r\n            b.x = r;\r\n            b.vx *= restitution;\r\n        }\r\n        // 右\r\n        if (b.x + r > width) {\r\n            b.x = width - r;\r\n            b.vx *= restitution;\r\n        }\r\n        // 上\r\n        if (b.y - r < 0) {\r\n            b.y = r;\r\n            b.vy *= restitution;\r\n        }\r\n        // 下\r\n        if (b.y + r > height) {\r\n            b.y = height - r;\r\n            b.vy *= restitution;\r\n        }\r\n      \r\n        // ボールを描画\r\n        fill(b.color); // ボールごとの色\r\n        noStroke();\r\n        ellipse(b.x, b.y, b.size);\r\n      \r\n      }\r\n        }\r\n    }\r\n\r\nfunction createBall(x, y, vx, vy) {\r\n    return {\r\n        x: x,\r\n        y: y,\r\n        size: random(10, 30),\r\n        vx: vx,\r\n        vy: vy,\r\n        color: color(\r\n            random(100, 255),\r\n            random(100, 255),\r\n            random(100, 255),\r\n            180\r\n        )\r\n    };\r\n}\r\n//アニメーションさせるための初速（vx, vy）を与える。\r\nfunction mouseDragged() {\r\n    // 少し前のマウスの位置 (pmouseX, pmouseY) を使って、ドラッグの方向と速度を計算 [14]\r\n    const dx = mouseX - pmouseX; \r\n    const dy = mouseY - pmouseY; \r\n    \r\n    // ドラッグ速度が一定以上の場合のみボールを生成（ノイズを防ぐ）[4]\r\n    // mag(x, y) はベクトルの長さ（動いた距離）を計算する関数\r\n    if (mag(dx, dy) > 5) { \r\n        // 新しいボールオブジェクトを作成\r\n        let b = createBall(mouseX, mouseY, dx * 0.5, dy * 0.5);\r\n        \r\n        // 配列の末尾に新しいボールを追加\r\n        balls.push(b); \r\n    }\r\n}"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "11/24/2025, 3:54:21 PM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// 最終課題を制作しよう\r\n// プログラム全体で有効な配列として宣言 (関数の外)\r\nlet balls = []; \r\n\r\n// 描画スタイルを管理する定数（任意）\r\nconst BALL_SIZE = 20;\r\nlet g = 0.2;     // 重力の値を設定（必須）\r\nlet vyMax = 20;  // 最大落下速度（必須）\r\nconst restitution = -0.8;   // 跳ね返るたびに減衰\r\n\r\n\r\n//キャンバスのサイズを設定。\r\nfunction setup() {\r\n    // キャンバスのサイズをウィンドウと同じにする\r\n    createCanvas(windowWidth, windowHeight);\r\n}\r\n//繰り返し描画関数 (draw())\r\n//背景を再描画し、配列内のすべての物体を更新・描画。\r\nfunction draw() {\r\n    // 背景を塗りつぶして前回の描画を消去する（アニメーションの基本）\r\n    // 例: background(160, 192, 255);\r\n    background(0, 50); // 透明度を低く設定し、動きの軌跡を残す演出も可能\r\n    \r\n    // ★止まったボールを削除\r\n    balls = balls.filter(b => {\r\n        const speed = sqrt(b.vx * b.vx + b.vy * b.vy);\r\n        const r = b.size / 2;\r\n\r\n        // ゆっくりで床に触れている → 消す\r\n        if (speed < 0.1 && b.y + r >= height) {\r\n            return false;\r\n        }\r\n        return true;\r\n});\r\n\r\n    \r\n    // ボールの更新 & 描画\r\n    for (let i = 0; i < balls.length; i++) {\r\n        let b = balls[i]; // 現在のボールオブジェクトを参照\r\n        let r = b.size / 2;\r\n\r\n        // 速度の分だけ位置を移動させる（アニメーション）位置の更新\r\n        b.x += b.vx;\r\n        b.y += b.vy;\r\n        \r\n        // 重力\r\n        b.vy += g;\r\n        b.vy = constrain(b.vy, -vyMax, vyMax);\r\n\r\n        // ★跳ね返り（半径を考慮）\r\n        // 左\r\n        if (b.x - r < 0) {\r\n            b.x = r;\r\n            b.vx *= restitution;\r\n        }\r\n        // 右\r\n        if (b.x + r > width) {\r\n            b.x = width - r;\r\n            b.vx *= restitution;\r\n        }\r\n        // 上\r\n        if (b.y - r < 0) {\r\n            b.y = r;\r\n            b.vy *= restitution;\r\n        }\r\n        // 下\r\n        if (b.y + r > height) {\r\n            b.y = height - r;\r\n            b.vy *= restitution;\r\n        }\r\n      \r\n        // ボールを描画\r\n        fill(b.color); // ボールごとの色\r\n        noStroke();\r\n        ellipse(b.x, b.y, b.size);\r\n      \r\n      \r\n        }\r\n    }\r\n\r\nfunction createBall(x, y, vx, vy) {\r\n    return {\r\n        x: x,\r\n        y: y,\r\n        size: random(10, 30),\r\n        vx: vx,\r\n        vy: vy,\r\n        color: color(\r\n            random(100, 255),\r\n            random(100, 255),\r\n            random(100, 255),\r\n            180\r\n        )\r\n    };\r\n}\r\n//アニメーションさせるための初速（vx, vy）を与える。\r\nfunction mouseDragged() {\r\n    // 少し前のマウスの位置 (pmouseX, pmouseY) を使って、ドラッグの方向と速度を計算 [14]\r\n    const dx = mouseX - pmouseX; \r\n    const dy = mouseY - pmouseY; \r\n    \r\n    // ドラッグ速度が一定以上の場合のみボールを生成（ノイズを防ぐ）[4]\r\n    // mag(x, y) はベクトルの長さ（動いた距離）を計算する関数\r\n    if (mag(dx, dy) > 5) { \r\n        // 新しいボールオブジェクトを作成\r\n        let b = createBall(mouseX, mouseY, dx * 0.5, dy * 0.5);\r\n        \r\n        // 配列の末尾に新しいボールを追加\r\n        balls.push(b); \r\n    }\r\n}"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "11/24/2025, 3:55:02 PM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// 最終課題を制作しよう\r\nlet balls = []; \r\n\r\nlet g = 0.2;\r\nlet vyMax = 20;\r\nconst restitution = -0.8;\r\n\r\nfunction setup() {\r\n    createCanvas(windowWidth, windowHeight);\r\n}\r\n\r\nfunction draw() {\r\n    background(0, 50);\r\n\r\n    // ★止まったボールを削除\r\n    balls = balls.filter(b => {\r\n        const speed = sqrt(b.vx * b.vx + b.vy * b.vy);\r\n        const r = b.size / 2;\r\n\r\n        // 速度が小さくて床に触れている → 消す\r\n        if (speed < 0.1 && b.y + r >= height) {\r\n            return false;\r\n        }\r\n        return true;\r\n    });\r\n\r\n    // ---------------------------\r\n    // ★ ボールの更新と描画\r\n    // ---------------------------\r\n    for (let i = 0; i < balls.length; i++) {\r\n        let b = balls[i];\r\n        let r = b.size / 2;\r\n\r\n        // 位置更新\r\n        b.x += b.vx;\r\n        b.y += b.vy;\r\n\r\n        // 重力\r\n        b.vy += g;\r\n        b.vy = constrain(b.vy, -vyMax, vyMax);\r\n\r\n        // ★跳ね返り（半径を考慮）\r\n        if (b.x - r < 0) {\r\n            b.x = r;\r\n            b.vx *= restitution;\r\n        }\r\n        if (b.x + r > width) {\r\n            b.x = width - r;\r\n            b.vx *= restitution;\r\n        }\r\n        if (b.y - r < 0) {\r\n            b.y = r;\r\n            b.vy *= restitution;\r\n        }\r\n        if (b.y + r > height) {\r\n            b.y = height - r;\r\n            b.vy *= restitution;\r\n        }\r\n\r\n        // 描画\r\n        fill(b.color);\r\n        noStroke();\r\n        ellipse(b.x, b.y, b.size);\r\n    }\r\n}\r\n\r\nfunction createBall(x, y, vx, vy) {\r\n    return {\r\n        x: x,\r\n        y: y,\r\n        size: random(10, 30),\r\n        vx: vx,\r\n        vy: vy,\r\n        color: color(\r\n            random(100, 255),\r\n            random(100, 255),\r\n            random(100, 255),\r\n            180\r\n        )\r\n    };\r\n}\r\n\r\nfunction mouseDragged() {\r\n    const dx = mouseX - pmouseX; \r\n    const dy = mouseY - pmouseY; \r\n    \r\n    if (mag(dx, dy) > 5) { \r\n        let b = createBall(mouseX, mouseY, dx * 0.5, dy * 0.5);\r\n        balls.push(b); \r\n    }\r\n}\r\n"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "11/24/2025, 3:55:12 PM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// 最終課題を制作しよう\r\n// プログラム全体で有効な配列として宣言 (関数の外)\r\nlet balls = []; \r\n\r\n// 描画スタイルを管理する定数（任意）\r\nconst BALL_SIZE = 20;\r\nlet g = 0.2;     // 重力の値を設定（必須）\r\nlet vyMax = 20;  // 最大落下速度（必須）\r\nconst restitution = -0.8;   // 跳ね返るたびに減衰\r\n\r\n\r\n//キャンバスのサイズを設定。\r\nfunction setup() {\r\n    // キャンバスのサイズをウィンドウと同じにする\r\n    createCanvas(windowWidth, windowHeight);\r\n}\r\n//繰り返し描画関数 (draw())\r\n//背景を再描画し、配列内のすべての物体を更新・描画。\r\nfunction draw() {\r\n    // 背景を塗りつぶして前回の描画を消去する（アニメーションの基本）\r\n    // 例: background(160, 192, 255);\r\n    background(0, 50); // 透明度を低く設定し、動きの軌跡を残す演出も可能\r\n    \r\n    // ★止まったボールを削除\r\n    balls = balls.filter(b => {\r\n        const speed = sqrt(b.vx * b.vx + b.vy * b.vy);\r\n        const r = b.size / 2;\r\n\r\n        // ゆっくりで床に触れている → 消す\r\n        if (speed < 0.1 && b.y + r >= height) {\r\n            return false;\r\n        }\r\n        return true;\r\n});\r\n\r\n    \r\n    // ボールの更新 & 描画\r\n    for (let i = 0; i < balls.length; i++) {\r\n        let b = balls[i]; // 現在のボールオブジェクトを参照\r\n        let r = b.size / 2;\r\n\r\n        // 速度の分だけ位置を移動させる（アニメーション）位置の更新\r\n        b.x += b.vx;\r\n        b.y += b.vy;\r\n        \r\n        // 重力\r\n        b.vy += g;\r\n        b.vy = constrain(b.vy, -vyMax, vyMax);\r\n\r\n        // ★跳ね返り（半径を考慮）\r\n        // 左\r\n        if (b.x - r < 0) {\r\n            b.x = r;\r\n            b.vx *= restitution;\r\n        }\r\n        // 右\r\n        if (b.x + r > width) {\r\n            b.x = width - r;\r\n            b.vx *= restitution;\r\n        }\r\n        // 上\r\n        if (b.y - r < 0) {\r\n            b.y = r;\r\n            b.vy *= restitution;\r\n        }\r\n        // 下\r\n        if (b.y + r > height) {\r\n            b.y = height - r;\r\n            b.vy *= restitution;\r\n        }\r\n      \r\n        // ボールを描画\r\n        fill(b.color); // ボールごとの色\r\n        noStroke();\r\n        ellipse(b.x, b.y, b.size);\r\n      \r\n      \r\n        }\r\n    }\r\n\r\nfunction createBall(x, y, vx, vy) {\r\n    return {\r\n        x: x,\r\n        y: y,\r\n        size: random(10, 30),\r\n        vx: vx,\r\n        vy: vy,\r\n        color: color(\r\n            random(100, 255),\r\n            random(100, 255),\r\n            random(100, 255),\r\n            180\r\n        )\r\n    };\r\n}\r\n//アニメーションさせるための初速（vx, vy）を与える。\r\nfunction mouseDragged() {\r\n    // 少し前のマウスの位置 (pmouseX, pmouseY) を使って、ドラッグの方向と速度を計算 [14]\r\n    const dx = mouseX - pmouseX; \r\n    const dy = mouseY - pmouseY; \r\n    \r\n    // ドラッグ速度が一定以上の場合のみボールを生成（ノイズを防ぐ）[4]\r\n    // mag(x, y) はベクトルの長さ（動いた距離）を計算する関数\r\n    if (mag(dx, dy) > 5) { \r\n        // 新しいボールオブジェクトを作成\r\n        let b = createBall(mouseX, mouseY, dx * 0.5, dy * 0.5);\r\n        \r\n        // 配列の末尾に新しいボールを追加\r\n        balls.push(b); \r\n    }\r\n}"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "11/24/2025, 3:56:32 PM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// 最終課題を制作しよう\r\n// プログラム全体で有効な配列として宣言 (関数の外)\r\nlet balls = []; \r\n\r\n// 描画スタイルを管理する定数（任意）\r\nconst BALL_SIZE = 20;\r\nlet g = 0.2;     // 重力の値を設定（必須）\r\nlet vyMax = 20;  // 最大落下速度（必須）\r\nconst restitution = 0.8;   // 跳ね返るたびに減衰\r\n\r\n\r\n//キャンバスのサイズを設定。\r\nfunction setup() {\r\n    // キャンバスのサイズをウィンドウと同じにする\r\n    createCanvas(windowWidth, windowHeight);\r\n}\r\n//繰り返し描画関数 (draw())\r\n//背景を再描画し、配列内のすべての物体を更新・描画。\r\nfunction draw() {\r\n    // 背景を塗りつぶして前回の描画を消去する（アニメーションの基本）\r\n    // 例: background(160, 192, 255);\r\n    background(0, 50); // 透明度を低く設定し、動きの軌跡を残す演出も可能\r\n    \r\n    // ★止まったボールを削除\r\n    balls = balls.filter(b => {\r\n        const speed = sqrt(b.vx * b.vx + b.vy * b.vy);\r\n        const r = b.size / 2;\r\n\r\n        // ゆっくりで床に触れている → 消す\r\n        if (speed < 0.1 && b.y + r >= height) {\r\n            return false;\r\n        }\r\n        return true;\r\n});\r\n\r\n    \r\n    // ボールの更新 & 描画\r\n    for (let i = 0; i < balls.length; i++) {\r\n        let b = balls[i]; // 現在のボールオブジェクトを参照\r\n        let r = b.size / 2;\r\n\r\n        // 速度の分だけ位置を移動させる（アニメーション）位置の更新\r\n        b.x += b.vx;\r\n        b.y += b.vy;\r\n        \r\n        // 重力\r\n        b.vy += g;\r\n        b.vy = constrain(b.vy, -vyMax, vyMax);\r\n\r\n        // ★跳ね返り（半径を考慮）\r\n        // 左\r\n        if (b.x - r < 0) {\r\n            b.x = r;\r\n            b.vx *= restitution;\r\n        }\r\n        // 右\r\n        if (b.x + r > width) {\r\n            b.x = width - r;\r\n            b.vx *= restitution;\r\n        }\r\n        // 上\r\n        if (b.y - r < 0) {\r\n            b.y = r;\r\n            b.vy *= restitution;\r\n        }\r\n        // 下\r\n        if (b.y + r > height) {\r\n            b.y = height - r;\r\n            b.vy *= restitution;\r\n        }\r\n      \r\n        // ボールを描画\r\n        fill(b.color); // ボールごとの色\r\n        noStroke();\r\n        ellipse(b.x, b.y, b.size);\r\n      \r\n      \r\n        }\r\n    }\r\n\r\nfunction createBall(x, y, vx, vy) {\r\n    return {\r\n        x: x,\r\n        y: y,\r\n        size: random(10, 30),\r\n        vx: vx,\r\n        vy: vy,\r\n        color: color(\r\n            random(100, 255),\r\n            random(100, 255),\r\n            random(100, 255),\r\n            180\r\n        )\r\n    };\r\n}\r\n//アニメーションさせるための初速（vx, vy）を与える。\r\nfunction mouseDragged() {\r\n    // 少し前のマウスの位置 (pmouseX, pmouseY) を使って、ドラッグの方向と速度を計算 [14]\r\n    const dx = mouseX - pmouseX; \r\n    const dy = mouseY - pmouseY; \r\n    \r\n    // ドラッグ速度が一定以上の場合のみボールを生成（ノイズを防ぐ）[4]\r\n    // mag(x, y) はベクトルの長さ（動いた距離）を計算する関数\r\n    if (mag(dx, dy) > 5) { \r\n        // 新しいボールオブジェクトを作成\r\n        let b = createBall(mouseX, mouseY, dx * 0.5, dy * 0.5);\r\n        \r\n        // 配列の末尾に新しいボールを追加\r\n        balls.push(b); \r\n    }\r\n}"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "11/24/2025, 3:56:34 PM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// 最終課題を制作しよう\r\n// プログラム全体で有効な配列として宣言 (関数の外)\r\nlet balls = []; \r\n\r\n// 描画スタイルを管理する定数（任意）\r\nconst BALL_SIZE = 20;\r\nlet g = 0.2;     // 重力の値を設定（必須）\r\nlet vyMax = 20;  // 最大落下速度（必須）\r\nconst restitution = 0.8;   // 跳ね返るたびに減衰\r\n\r\n\r\n//キャンバスのサイズを設定。\r\nfunction setup() {\r\n    // キャンバスのサイズをウィンドウと同じにする\r\n    createCanvas(windowWidth, windowHeight);\r\n}\r\n//繰り返し描画関数 (draw())\r\n//背景を再描画し、配列内のすべての物体を更新・描画。\r\nfunction draw() {\r\n    // 背景を塗りつぶして前回の描画を消去する（アニメーションの基本）\r\n    // 例: background(160, 192, 255);\r\n    background(0, 50); // 透明度を低く設定し、動きの軌跡を残す演出も可能\r\n    \r\n    // ★止まったボールを削除\r\n    balls = balls.filter(b => {\r\n        const speed = sqrt(b.vx * b.vx + b.vy * b.vy);\r\n        const r = b.size / 2;\r\n\r\n        // ゆっくりで床に触れている → 消す\r\n        if (speed < 0.1 && b.y + r >= height) {\r\n            return false;\r\n        }\r\n        return true;\r\n});\r\n\r\n    \r\n    // ボールの更新 & 描画\r\n    for (let i = 0; i < balls.length; i++) {\r\n        let b = balls[i]; // 現在のボールオブジェクトを参照\r\n        let r = b.size / 2;\r\n\r\n        // 速度の分だけ位置を移動させる（アニメーション）位置の更新\r\n        b.x += b.vx;\r\n        b.y += b.vy;\r\n        \r\n        // 重力\r\n        b.vy += g;\r\n        b.vy = constrain(b.vy, -vyMax, vyMax);\r\n\r\n        // ★跳ね返り（半径を考慮）\r\n        // 左\r\n        if (b.x - r < 0) {\r\n            b.x = r;\r\n            b.vx *= restitution;\r\n        }\r\n        // 右\r\n        if (b.x + r > width) {\r\n            b.x = width - r;\r\n            b.vx *= restitution;\r\n        }\r\n        // 上\r\n        if (b.y - r < 0) {\r\n            b.y = r;\r\n            b.vy *= restitution;\r\n        }\r\n        // 下\r\n        if (b.y + r > height) {\r\n            b.y = height - r;\r\n            b.vy *= restitution;\r\n        }\r\n      \r\n        // ボールを描画\r\n        fill(b.color); // ボールごとの色\r\n        noStroke();\r\n        ellipse(b.x, b.y, b.size);\r\n      \r\n      \r\n        }\r\n    }\r\n\r\nfunction createBall(x, y, vx, vy) {\r\n    return {\r\n        x: x,\r\n        y: y,\r\n        size: random(10, 30),\r\n        vx: vx,\r\n        vy: vy,\r\n        color: color(\r\n            random(100, 255),\r\n            random(100, 255),\r\n            random(100, 255),\r\n            180\r\n        )\r\n    };\r\n}\r\n//アニメーションさせるための初速（vx, vy）を与える。\r\nfunction mouseDragged() {\r\n    // 少し前のマウスの位置 (pmouseX, pmouseY) を使って、ドラッグの方向と速度を計算 [14]\r\n    const dx = mouseX - pmouseX; \r\n    const dy = mouseY - pmouseY; \r\n    \r\n    // ドラッグ速度が一定以上の場合のみボールを生成（ノイズを防ぐ）[4]\r\n    // mag(x, y) はベクトルの長さ（動いた距離）を計算する関数\r\n    if (mag(dx, dy) > 5) { \r\n        // 新しいボールオブジェクトを作成\r\n        let b = createBall(mouseX, mouseY, dx * 0.5, dy * 0.5);\r\n        \r\n        // 配列の末尾に新しいボールを追加\r\n        balls.push(b); \r\n    }\r\n}"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "11/24/2025, 3:57:23 PM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// 最終課題を制作しよう\r\n// プログラム全体で有効な配列として宣言 (関数の外)\r\nlet balls = []; \r\n\r\n// 描画スタイルを管理する定数（任意）\r\nconst BALL_SIZE = 20;\r\nlet g = 0.2;     // 重力の値を設定（必須）\r\nlet vyMax = 20;  // 最大落下速度（必須）\r\nconst restitution = 0.8;   // 跳ね返るたびに減衰\r\n\r\n\r\n//キャンバスのサイズを設定。\r\nfunction setup() {\r\n    // キャンバスのサイズをウィンドウと同じにする\r\n    createCanvas(windowWidth, windowHeight);\r\n}\r\n//繰り返し描画関数 (draw())\r\n//背景を再描画し、配列内のすべての物体を更新・描画。\r\nfunction draw() {\r\n    // 背景を塗りつぶして前回の描画を消去する（アニメーションの基本）\r\n    // 例: background(160, 192, 255);\r\n    background(0, 50); // 透明度を低く設定し、動きの軌跡を残す演出も可能\r\n    \r\n    // ★止まったボールを削除\r\n    balls = balls.filter(b => {\r\n        const speed = sqrt(b.vx * b.vx + b.vy * b.vy);\r\n        const r = b.size / 2;\r\n\r\n        // ゆっくりで床に触れている → 消す\r\n        if (speed < 0.1 && b.y + r >= height) {\r\n            return false;\r\n        }\r\n        return true;\r\n});\r\n\r\n    \r\n    // ボールの更新 & 描画\r\n    for (let i = 0; i < balls.length; i++) {\r\n        let b = balls[i]; // 現在のボールオブジェクトを参照\r\n        let r = b.size / 2;\r\n\r\n        // 速度の分だけ位置を移動させる（アニメーション）位置の更新\r\n        b.x += b.vx;\r\n        b.y += b.vy;\r\n        \r\n        // 重力\r\n        b.vy += g;\r\n        b.vy = constrain(b.vy, -vyMax, vyMax);\r\n\r\n        // ★跳ね返り（半径を考慮）\r\n        // 左\r\n        if (b.x - r < 0) {\r\n            b.x = r;\r\n            b.vx *= -restitution;\r\n        }\r\n        // 右\r\n        if (b.x + r > width) {\r\n            b.x = width - r;\r\n            b.vx *= -restitution;\r\n        }\r\n        // 上\r\n        if (b.y - r < 0) {\r\n            b.y = r;\r\n            b.vy *= -restitution;\r\n        }\r\n        // 下\r\n        if (b.y + r > height) {\r\n            b.y = height - r;\r\n            b.vy *= -restitution;\r\n        }\r\n      \r\n        // ボールを描画\r\n        fill(b.color); // ボールごとの色\r\n        noStroke();\r\n        ellipse(b.x, b.y, b.size);\r\n      \r\n      \r\n        }\r\n    }\r\n\r\nfunction createBall(x, y, vx, vy) {\r\n    return {\r\n        x: x,\r\n        y: y,\r\n        size: random(10, 30),\r\n        vx: vx,\r\n        vy: vy,\r\n        color: color(\r\n            random(100, 255),\r\n            random(100, 255),\r\n            random(100, 255),\r\n            180\r\n        )\r\n    };\r\n}\r\n//アニメーションさせるための初速（vx, vy）を与える。\r\nfunction mouseDragged() {\r\n    // 少し前のマウスの位置 (pmouseX, pmouseY) を使って、ドラッグの方向と速度を計算 [14]\r\n    const dx = mouseX - pmouseX; \r\n    const dy = mouseY - pmouseY; \r\n    \r\n    // ドラッグ速度が一定以上の場合のみボールを生成（ノイズを防ぐ）[4]\r\n    // mag(x, y) はベクトルの長さ（動いた距離）を計算する関数\r\n    if (mag(dx, dy) > 5) { \r\n        // 新しいボールオブジェクトを作成\r\n        let b = createBall(mouseX, mouseY, dx * 0.5, dy * 0.5);\r\n        \r\n        // 配列の末尾に新しいボールを追加\r\n        balls.push(b); \r\n    }\r\n}"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "11/24/2025, 3:59:18 PM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// 最終課題を制作しよう\r\n// プログラム全体で有効な配列として宣言 (関数の外)\r\nlet balls = []; \r\n\r\n// 描画スタイルを管理する定数（任意）\r\nconst BALL_SIZE = 20;\r\nlet g = 0.2;     // 重力の値を設定（必須）\r\nlet vyMax = 20;  // 最大落下速度（必須）\r\nconst restitution = 0.8;   // 跳ね返るたびに減衰\r\n\r\n\r\n//キャンバスのサイズを設定。\r\nfunction setup() {\r\n    // キャンバスのサイズをウィンドウと同じにする\r\n    createCanvas(windowWidth, windowHeight);\r\n    colorMode(RGB, 255);\r\n    background(0); // 最初に背景を黒で塗りつぶす\r\n}\r\n//繰り返し描画関数 (draw())\r\n//背景を再描画し、配列内のすべての物体を更新・描画。\r\nfunction draw() {\r\n    // 背景を塗りつぶして前回の描画を消去する（アニメーションの基本）\r\n    // 例: background(160, 192, 255);\r\n    background(0, 50); // 透明度を低く設定し、動きの軌跡を残す演出も可能\r\n    \r\n    // ★止まったボールを削除\r\n    balls = balls.filter(b => {\r\n        const speed = sqrt(b.vx * b.vx + b.vy * b.vy);\r\n        const r = b.size / 2;\r\n\r\n        // ゆっくりで床に触れている → 消す\r\n        if (speed < 0.1 && b.y + r >= height) {\r\n            return false;\r\n        }\r\n        return true;\r\n});\r\n\r\n    \r\n    // ボールの更新 & 描画\r\n    for (let i = 0; i < balls.length; i++) {\r\n        let b = balls[i]; // 現在のボールオブジェクトを参照\r\n        let r = b.size / 2;\r\n\r\n        // 速度の分だけ位置を移動させる（アニメーション）位置の更新\r\n        b.x += b.vx;\r\n        b.y += b.vy;\r\n        \r\n        // 重力\r\n        b.vy += g;\r\n        b.vy = constrain(b.vy, -vyMax, vyMax);\r\n\r\n        // ★跳ね返り（半径を考慮）\r\n        // 左\r\n        if (b.x - r < 0) {\r\n            b.x = r;\r\n            b.vx *= -restitution;\r\n        }\r\n        // 右\r\n        if (b.x + r > width) {\r\n            b.x = width - r;\r\n            b.vx *= -restitution;\r\n        }\r\n        // 上\r\n        if (b.y - r < 0) {\r\n            b.y = r;\r\n            b.vy *= -restitution;\r\n        }\r\n        // 下\r\n        if (b.y + r > height) {\r\n            b.y = height - r;\r\n            b.vy *= -restitution;\r\n        }\r\n      \r\n        // ボールを描画\r\n        fill(b.color); // ボールごとの色\r\n        noStroke();\r\n        ellipse(b.x, b.y, b.size);\r\n      \r\n      \r\n        }\r\n    }\r\n\r\nfunction createBall(x, y, vx, vy) {\r\n    return {\r\n        x: x,\r\n        y: y,\r\n        size: random(10, 30),\r\n        vx: vx,\r\n        vy: vy,\r\n        color: color(\r\n            random(100, 255),\r\n            random(100, 255),\r\n            random(100, 255),\r\n            180\r\n        )\r\n    };\r\n}\r\n//アニメーションさせるための初速（vx, vy）を与える。\r\nfunction mouseDragged() {\r\n    // 少し前のマウスの位置 (pmouseX, pmouseY) を使って、ドラッグの方向と速度を計算 [14]\r\n    const dx = mouseX - pmouseX; \r\n    const dy = mouseY - pmouseY; \r\n    \r\n    // ドラッグ速度が一定以上の場合のみボールを生成（ノイズを防ぐ）[4]\r\n    // mag(x, y) はベクトルの長さ（動いた距離）を計算する関数\r\n    if (mag(dx, dy) > 5) { \r\n        // 新しいボールオブジェクトを作成\r\n        let b = createBall(mouseX, mouseY, dx * 0.5, dy * 0.5);\r\n        \r\n        // 配列の末尾に新しいボールを追加\r\n        balls.push(b); \r\n    }\r\n}"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "11/24/2025, 4:01:07 PM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "let balls = []; \r\n\r\nlet g = 0.2;     \r\nlet vyMax = 20;  \r\nconst restitution = 0.8;  \r\n\r\nfunction setup() {\r\n    createCanvas(windowWidth, windowHeight);\r\n    colorMode(RGB, 255);\r\n    background(0); // 初期背景\r\n}\r\n\r\nfunction draw() {\r\n    background(0); // 半透明にせず、ボールをはっきり見せる\r\n\r\n    // 止まったボールを削除\r\n    balls = balls.filter(b => {\r\n        const speed = sqrt(b.vx * b.vx + b.vy * b.vy);\r\n        const r = b.size / 2;\r\n        return !(speed < 0.1 && b.y + r >= height);\r\n    });\r\n\r\n    // ボール更新 & 描画\r\n    for (let i = 0; i < balls.length; i++) {\r\n        let b = balls[i]; \r\n        let r = b.size / 2;\r\n\r\n        b.x += b.vx;\r\n        b.y += b.vy;\r\n\r\n        b.vy += g;\r\n        b.vy = constrain(b.vy, -vyMax, vyMax);\r\n\r\n        // 跳ね返り\r\n        if (b.x - r < 0) { b.x = r; b.vx *= -restitution; }\r\n        if (b.x + r > width) { b.x = width - r; b.vx *= -restitution; }\r\n        if (b.y - r < 0) { b.y = r; b.vy *= -restitution; }\r\n        if (b.y + r > height) { b.y = height - r; b.vy *= -restitution; }\r\n\r\n        fill(b.color);\r\n        noStroke();\r\n        ellipse(b.x, b.y, b.size);\r\n    }\r\n}\r\n\r\nfunction createBall(x, y, vx, vy) {\r\n    return {\r\n        x: x,\r\n        y: y,\r\n        size: random(20, 40), // 少し大きめにして見やすく\r\n        vx: vx,\r\n        vy: vy,\r\n        color: color(\r\n            random(100, 255),\r\n            random(100, 255),\r\n            random(100, 255),\r\n            255 // 透明度を最大に\r\n        )\r\n    };\r\n}\r\n\r\nfunction mouseDragged() {\r\n    const dx = mouseX - pmouseX; \r\n    const dy = mouseY - pmouseY; \r\n\r\n    // ドラッグ速度がある程度あればボール生成\r\n    if (mag(dx, dy) > 0) { \r\n        let b = createBall(mouseX, mouseY, dx * 0.5, dy * 0.5);\r\n        balls.push(b); \r\n    }\r\n}\r\n"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "11/24/2025, 4:01:29 PM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// 最終課題を制作しよう\r\n// プログラム全体で有効な配列として宣言 (関数の外)\r\nlet balls = []; \r\n\r\n// 描画スタイルを管理する定数（任意）\r\nconst BALL_SIZE = 20;\r\nlet g = 0.2;     // 重力の値を設定（必須）\r\nlet vyMax = 20;  // 最大落下速度（必須）\r\nconst restitution = 0.8;   // 跳ね返るたびに減衰\r\n\r\n\r\n//キャンバスのサイズを設定。\r\nfunction setup() {\r\n    // キャンバスのサイズをウィンドウと同じにする\r\n    createCanvas(windowWidth, windowHeight);\r\n    colorMode(RGB, 255);\r\n    background(0); // 最初に背景を黒で塗りつぶす\r\n}\r\n//繰り返し描画関数 (draw())\r\n//背景を再描画し、配列内のすべての物体を更新・描画。\r\nfunction draw() {\r\n    // 背景を塗りつぶして前回の描画を消去する（アニメーションの基本）\r\n    // 例: background(160, 192, 255);\r\n    background(0, 50); // 透明度を低く設定し、動きの軌跡を残す演出も可能\r\n    \r\n    // ★止まったボールを削除\r\n    balls = balls.filter(b => {\r\n        const speed = sqrt(b.vx * b.vx + b.vy * b.vy);\r\n        const r = b.size / 2;\r\n\r\n        // ゆっくりで床に触れている → 消す\r\n        if (speed < 0.1 && b.y + r >= height) {\r\n            return false;\r\n        }\r\n        return true;\r\n});\r\n\r\n    \r\n    // ボールの更新 & 描画\r\n    for (let i = 0; i < balls.length; i++) {\r\n        let b = balls[i]; // 現在のボールオブジェクトを参照\r\n        let r = b.size / 2;\r\n\r\n        // 速度の分だけ位置を移動させる（アニメーション）位置の更新\r\n        b.x += b.vx;\r\n        b.y += b.vy;\r\n        \r\n        // 重力\r\n        b.vy += g;\r\n        b.vy = constrain(b.vy, -vyMax, vyMax);\r\n\r\n        // ★跳ね返り（半径を考慮）\r\n        // 左\r\n        if (b.x - r < 0) {\r\n            b.x = r;\r\n            b.vx *= -restitution;\r\n        }\r\n        // 右\r\n        if (b.x + r > width) {\r\n            b.x = width - r;\r\n            b.vx *= -restitution;\r\n        }\r\n        // 上\r\n        if (b.y - r < 0) {\r\n            b.y = r;\r\n            b.vy *= -restitution;\r\n        }\r\n        // 下\r\n        if (b.y + r > height) {\r\n            b.y = height - r;\r\n            b.vy *= -restitution;\r\n        }\r\n      \r\n        // ボールを描画\r\n        fill(b.color); // ボールごとの色\r\n        noStroke();\r\n        ellipse(b.x, b.y, b.size);\r\n      \r\n      \r\n        }\r\n    }\r\n\r\nfunction createBall(x, y, vx, vy) {\r\n    return {\r\n        x: x,\r\n        y: y,\r\n        size: random(10, 30),\r\n        vx: vx,\r\n        vy: vy,\r\n        color: color(\r\n            random(100, 255),\r\n            random(100, 255),\r\n            random(100, 255),\r\n            180\r\n        )\r\n    };\r\n}\r\n//アニメーションさせるための初速（vx, vy）を与える。\r\nfunction mouseDragged() {\r\n    // 少し前のマウスの位置 (pmouseX, pmouseY) を使って、ドラッグの方向と速度を計算 [14]\r\n    const dx = mouseX - pmouseX; \r\n    const dy = mouseY - pmouseY; \r\n    \r\n    // ドラッグ速度が一定以上の場合のみボールを生成（ノイズを防ぐ）[4]\r\n    // mag(x, y) はベクトルの長さ（動いた距離）を計算する関数\r\n    if (mag(dx, dy) > 5) { \r\n        // 新しいボールオブジェクトを作成\r\n        let b = createBall(mouseX, mouseY, dx * 0.5, dy * 0.5);\r\n        \r\n        // 配列の末尾に新しいボールを追加\r\n        balls.push(b); \r\n    }\r\n}"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "11/24/2025, 4:03:00 PM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// 最終課題を制作しよう\r\nlet balls = []; \r\n\r\nlet g = 0.2;\r\nlet vyMax = 20;\r\nconst restitution = -0.8;\r\n\r\nfunction setup() {\r\n    createCanvas(windowWidth, windowHeight);\r\n}\r\n\r\nfunction draw() {\r\n    background(0, 50);\r\n\r\n    // ★止まったボールを削除\r\n    balls = balls.filter(b => {\r\n        const speed = sqrt(b.vx * b.vx + b.vy * b.vy);\r\n        const r = b.size / 2;\r\n\r\n        // 速度が小さくて床に触れている → 消す\r\n        if (speed < 0.1 && b.y + r >= height) {\r\n            return false;\r\n        }\r\n        return true;\r\n    });\r\n\r\n    // ---------------------------\r\n    // ★ ボールの更新と描画\r\n    // ---------------------------\r\n    for (let i = 0; i < balls.length; i++) {\r\n        let b = balls[i];\r\n        let r = b.size / 2;\r\n\r\n        // 位置更新\r\n        b.x += b.vx;\r\n        b.y += b.vy;\r\n\r\n        // 重力\r\n        b.vy += g;\r\n        b.vy = constrain(b.vy, -vyMax, vyMax);\r\n\r\n        // ★跳ね返り（半径を考慮）\r\n        if (b.x - r < 0) {\r\n            b.x = r;\r\n            b.vx *= restitution;\r\n        }\r\n        if (b.x + r > width) {\r\n            b.x = width - r;\r\n            b.vx *= restitution;\r\n        }\r\n        if (b.y - r < 0) {\r\n            b.y = r;\r\n            b.vy *= restitution;\r\n        }\r\n        if (b.y + r > height) {\r\n            b.y = height - r;\r\n            b.vy *= restitution;\r\n        }\r\n\r\n        // 描画\r\n        fill(b.color);\r\n        noStroke();\r\n        ellipse(b.x, b.y, b.size);\r\n    }\r\n}\r\n\r\nfunction createBall(x, y, vx, vy) {\r\n    return {\r\n        x: x,\r\n        y: y,\r\n        size: random(10, 30),\r\n        vx: vx,\r\n        vy: vy,\r\n        color: color(\r\n            random(100, 255),\r\n            random(100, 255),\r\n            random(100, 255),\r\n            180\r\n        )\r\n    };\r\n}\r\n\r\nfunction mouseDragged() {\r\n    const dx = mouseX - pmouseX; \r\n    const dy = mouseY - pmouseY; \r\n    \r\n    if (mag(dx, dy) > 5) { \r\n        let b = createBall(mouseX, mouseY, dx * 0.5, dy * 0.5);\r\n        balls.push(b); \r\n    }\r\n}\r\n"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "11/24/2025, 4:05:56 PM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// 最終課題を制作しよう\r\nlet balls = []; \r\n\r\nlet g = 0.2;\r\nlet vyMax = 20;\r\nconst restitution = -0.8;\r\n\r\nfunction setup() {\r\n    createCanvas(windowWidth, windowHeight);\r\n}\r\n\r\nfunction draw() {\r\n    background(0, 50);\r\n\r\n    // ★止まったボールを削除\r\n    balls = balls.filter(b => {\r\n        const speed = sqrt(b.vx * b.vx + b.vy * b.vy);\r\n        const r = b.size / 2;\r\n\r\n        // 速度が小さくて床に触れている → 消す\r\n        if (speed < 0.8 && b.y + r >= height) {\r\n            return false;\r\n        }\r\n        return true;\r\n    });\r\n\r\n    // ---------------------------\r\n    // ★ ボールの更新と描画\r\n    // ---------------------------\r\n    for (let i = 0; i < balls.length; i++) {\r\n        let b = balls[i];\r\n        let r = b.size / 2;\r\n\r\n        // 位置更新\r\n        b.x += b.vx;\r\n        b.y += b.vy;\r\n\r\n        // 重力\r\n        b.vy += g;\r\n        b.vy = constrain(b.vy, -vyMax, vyMax);\r\n\r\n        // ★跳ね返り（半径を考慮）\r\n        if (b.x - r < 0) {\r\n            b.x = r;\r\n            b.vx *= restitution;\r\n        }\r\n        if (b.x + r > width) {\r\n            b.x = width - r;\r\n            b.vx *= restitution;\r\n        }\r\n        if (b.y - r < 0) {\r\n            b.y = r;\r\n            b.vy *= restitution;\r\n        }\r\n        if (b.y + r > height) {\r\n            b.y = height - r;\r\n            b.vy *= restitution;\r\n        }\r\n\r\n        // 描画\r\n        fill(b.color);\r\n        noStroke();\r\n        ellipse(b.x, b.y, b.size);\r\n    }\r\n}\r\n\r\nfunction createBall(x, y, vx, vy) {\r\n    return {\r\n        x: x,\r\n        y: y,\r\n        size: random(10, 30),\r\n        vx: vx,\r\n        vy: vy,\r\n        color: color(\r\n            random(100, 255),\r\n            random(100, 255),\r\n            random(100, 255),\r\n            180\r\n        )\r\n    };\r\n}\r\n\r\nfunction mouseDragged() {\r\n    const dx = mouseX - pmouseX; \r\n    const dy = mouseY - pmouseY; \r\n    \r\n    if (mag(dx, dy) > 5) { \r\n        let b = createBall(mouseX, mouseY, dx * 0.5, dy * 0.5);\r\n        balls.push(b); \r\n    }\r\n}\r\n"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "11/24/2025, 4:07:53 PM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// 最終課題を制作しよう\r\nlet balls = []; \r\n\r\nlet g = 0.2;\r\nlet vyMax = 20;\r\nconst restitution = -0.8;\r\n\r\nfunction setup() {\r\n    createCanvas(windowWidth, windowHeight);\r\n}\r\n\r\nfunction draw() {\r\n    background(0, 50);\r\n\r\n    // ★止まったボールを削除\r\n    balls = balls.filter(b => {\r\n        const speed = sqrt(b.vx * b.vx + b.vy * b.vy);\r\n        const r = b.size / 2;\r\n\r\n        // 速度が小さくて床に触れている → 消す\r\n        if (speed < 1 && b.y + r >= height) {\r\n            return false;\r\n        }\r\n        return true;\r\n    });\r\n\r\n    // ---------------------------\r\n    // ★ ボールの更新と描画\r\n    // ---------------------------\r\n    for (let i = 0; i < balls.length; i++) {\r\n        let b = balls[i];\r\n        let r = b.size / 2;\r\n\r\n        // 位置更新\r\n        b.x += b.vx;\r\n        b.y += b.vy;\r\n\r\n        // 重力\r\n        b.vy += g;\r\n        b.vy = constrain(b.vy, -vyMax, vyMax);\r\n\r\n        // ★跳ね返り（半径を考慮）\r\n        if (b.x - r < 0) {\r\n            b.x = r;\r\n            b.vx *= restitution;\r\n        }\r\n        if (b.x + r > width) {\r\n            b.x = width - r;\r\n            b.vx *= restitution;\r\n        }\r\n        if (b.y - r < 0) {\r\n            b.y = r;\r\n            b.vy *= restitution;\r\n        }\r\n        if (b.y + r > height) {\r\n            b.y = height - r;\r\n            b.vy *= restitution;\r\n        }\r\n\r\n        // 描画\r\n        fill(b.color);\r\n        noStroke();\r\n        ellipse(b.x, b.y, b.size);\r\n    }\r\n}\r\n\r\nfunction createBall(x, y, vx, vy) {\r\n    return {\r\n        x: x,\r\n        y: y,\r\n        size: random(10, 30),\r\n        vx: vx,\r\n        vy: vy,\r\n        color: color(\r\n            random(100, 255),\r\n            random(100, 255),\r\n            random(100, 255),\r\n            180\r\n        )\r\n    };\r\n}\r\n\r\nfunction mouseDragged() {\r\n    const dx = mouseX - pmouseX; \r\n    const dy = mouseY - pmouseY; \r\n    \r\n    if (mag(dx, dy) > 5) { \r\n        let b = createBall(mouseX, mouseY, dx * 0.5, dy * 0.5);\r\n        balls.push(b); \r\n    }\r\n}\r\n"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "11/24/2025, 4:08:21 PM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// 最終課題を制作しよう\r\nlet balls = []; \r\n\r\nlet g = 0.2;\r\nlet vyMax = 20;\r\nconst restitution = -0.8;\r\n\r\nfunction setup() {\r\n    createCanvas(windowWidth, windowHeight);\r\n}\r\n\r\nfunction draw() {\r\n    background(0, 50);\r\n\r\n    // ★止まったボールを削除\r\n    balls = balls.filter(b => {\r\n        const speed = sqrt(b.vx * b.vx + b.vy * b.vy);\r\n        const r = b.size / 2;\r\n\r\n        // 速度が小さくて床に触れている → 消す\r\n        if (speed < 5 && b.y + r >= height) {\r\n            return false;\r\n        }\r\n        return true;\r\n    });\r\n\r\n    // ---------------------------\r\n    // ★ ボールの更新と描画\r\n    // ---------------------------\r\n    for (let i = 0; i < balls.length; i++) {\r\n        let b = balls[i];\r\n        let r = b.size / 2;\r\n\r\n        // 位置更新\r\n        b.x += b.vx;\r\n        b.y += b.vy;\r\n\r\n        // 重力\r\n        b.vy += g;\r\n        b.vy = constrain(b.vy, -vyMax, vyMax);\r\n\r\n        // ★跳ね返り（半径を考慮）\r\n        if (b.x - r < 0) {\r\n            b.x = r;\r\n            b.vx *= restitution;\r\n        }\r\n        if (b.x + r > width) {\r\n            b.x = width - r;\r\n            b.vx *= restitution;\r\n        }\r\n        if (b.y - r < 0) {\r\n            b.y = r;\r\n            b.vy *= restitution;\r\n        }\r\n        if (b.y + r > height) {\r\n            b.y = height - r;\r\n            b.vy *= restitution;\r\n        }\r\n\r\n        // 描画\r\n        fill(b.color);\r\n        noStroke();\r\n        ellipse(b.x, b.y, b.size);\r\n    }\r\n}\r\n\r\nfunction createBall(x, y, vx, vy) {\r\n    return {\r\n        x: x,\r\n        y: y,\r\n        size: random(10, 30),\r\n        vx: vx,\r\n        vy: vy,\r\n        color: color(\r\n            random(100, 255),\r\n            random(100, 255),\r\n            random(100, 255),\r\n            180\r\n        )\r\n    };\r\n}\r\n\r\nfunction mouseDragged() {\r\n    const dx = mouseX - pmouseX; \r\n    const dy = mouseY - pmouseY; \r\n    \r\n    if (mag(dx, dy) > 5) { \r\n        let b = createBall(mouseX, mouseY, dx * 0.5, dy * 0.5);\r\n        balls.push(b); \r\n    }\r\n}\r\n"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "11/24/2025, 4:13:27 PM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// 最終課題を制作しよう\r\nlet balls = []; \r\n\r\nlet g = 0.2;\r\nlet vyMax = 20;\r\nconst restitution = -0.8;\r\n\r\nfunction setup() {\r\n    createCanvas(windowWidth, windowHeight);\r\n\r\n    // サイン波オシレーターを作成\r\n    bounceSound = new p5.Oscillator('sine');\r\n    bounceSound.start();\r\n    bounceSound.amp(0); // 最初は音量0\r\n}\r\n\r\nfunction draw() {\r\n    background(0, 50);\r\n\r\n    // ★止まったボールを削除\r\n    balls = balls.filter(b => {\r\n        const speed = sqrt(b.vx * b.vx + b.vy * b.vy);\r\n        const r = b.size / 2;\r\n\r\n        // 速度が小さくて床に触れている → 消す\r\n        if (speed < 5 && b.y + r >= height) {\r\n            return false;\r\n        }\r\n        return true;\r\n    });\r\n\r\n    // ---------------------------\r\n    // ★ ボールの更新と描画\r\n    // ---------------------------\r\n    for (let i = 0; i < balls.length; i++) {\r\n        let b = balls[i];\r\n        let r = b.size / 2;\r\n\r\n        // 位置更新\r\n        b.x += b.vx;\r\n        b.y += b.vy;\r\n\r\n        // 重力\r\n        b.vy += g;\r\n        b.vy = constrain(b.vy, -vyMax, vyMax);\r\n\r\n        // ★跳ね返り（半径を考慮）\r\n        if (b.x - r < 0) {\r\n            b.x = r;\r\n            b.vx *= restitution;\r\n        }\r\n        if (b.x + r > width) {\r\n            b.x = width - r;\r\n            b.vx *= restitution;\r\n        }\r\n        if (b.y - r < 0) {\r\n            b.y = r;\r\n            b.vy *= restitution;\r\n        }\r\n        if (b.y + r > height) {\r\n            b.y = height - r;\r\n            b.vy *= restitution;\r\n        }\r\n\r\n        // 床に当たったとき\r\n        if (b.y + r > height){\r\n            b.y = height - r;\r\n            b.vy *= restitution;\r\n\r\n            // 音を鳴らす\r\n            // ボールの速度の大きさで音量を変化\r\n            let volume = constrain(abs(b.vy) / 20, 0, 0.5);\r\n            bounceSound.amp(volume, 0.05);\r\n\r\n            // ボールの大きさで周波数を変化（大きいほど低い音）\r\n            let freq = map(b.size, 10, 30, 600, 200);\r\n            bounceSound.freq(freq);\r\n\r\n            // 音を徐々に消す\r\n            bounceSound.amp(0, 0.3);\r\n        }\r\n\r\n        // 描画\r\n        fill(b.color);\r\n        noStroke();\r\n        ellipse(b.x, b.y, b.size);\r\n    }\r\n}\r\n\r\nfunction createBall(x, y, vx, vy) {\r\n    return {\r\n        x: x,\r\n        y: y,\r\n        size: random(10, 30),\r\n        vx: vx,\r\n        vy: vy,\r\n        color: color(\r\n            random(100, 255),\r\n            random(100, 255),\r\n            random(100, 255),\r\n            180\r\n        )\r\n    };\r\n}\r\n\r\nfunction mouseDragged() {\r\n    const dx = mouseX - pmouseX; \r\n    const dy = mouseY - pmouseY; \r\n    \r\n    if (mag(dx, dy) > 5) { \r\n        let b = createBall(mouseX, mouseY, dx * 0.5, dy * 0.5);\r\n        balls.push(b); \r\n    }\r\n}\r\n"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "11/24/2025, 4:13:55 PM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// 最終課題を制作しよう\r\nlet balls = []; \r\n\r\nlet g = 0.2;\r\nlet vyMax = 20;\r\nconst restitution = -0.8;\r\n\r\nfunction setup() {\r\n    createCanvas(windowWidth, windowHeight);\r\n}\r\n\r\nfunction draw() {\r\n    background(0, 50);\r\n\r\n    // ★止まったボールを削除\r\n    balls = balls.filter(b => {\r\n        const speed = sqrt(b.vx * b.vx + b.vy * b.vy);\r\n        const r = b.size / 2;\r\n\r\n        // 速度が小さくて床に触れている → 消す\r\n        if (speed < 5 && b.y + r >= height) {\r\n            return false;\r\n        }\r\n        return true;\r\n    });\r\n\r\n    // ---------------------------\r\n    // ★ ボールの更新と描画\r\n    // ---------------------------\r\n    for (let i = 0; i < balls.length; i++) {\r\n        let b = balls[i];\r\n        let r = b.size / 2;\r\n\r\n        // 位置更新\r\n        b.x += b.vx;\r\n        b.y += b.vy;\r\n\r\n        // 重力\r\n        b.vy += g;\r\n        b.vy = constrain(b.vy, -vyMax, vyMax);\r\n\r\n        // ★跳ね返り（半径を考慮）\r\n        if (b.x - r < 0) {\r\n            b.x = r;\r\n            b.vx *= restitution;\r\n        }\r\n        if (b.x + r > width) {\r\n            b.x = width - r;\r\n            b.vx *= restitution;\r\n        }\r\n        if (b.y - r < 0) {\r\n            b.y = r;\r\n            b.vy *= restitution;\r\n        }\r\n        if (b.y + r > height) {\r\n            b.y = height - r;\r\n            b.vy *= restitution;\r\n        }\r\n\r\n        // 描画\r\n        fill(b.color);\r\n        noStroke();\r\n        ellipse(b.x, b.y, b.size);\r\n    }\r\n}\r\n\r\nfunction createBall(x, y, vx, vy) {\r\n    return {\r\n        x: x,\r\n        y: y,\r\n        size: random(10, 30),\r\n        vx: vx,\r\n        vy: vy,\r\n        color: color(\r\n            random(100, 255),\r\n            random(100, 255),\r\n            random(100, 255),\r\n            180\r\n        )\r\n    };\r\n}\r\n\r\nfunction mouseDragged() {\r\n    const dx = mouseX - pmouseX; \r\n    const dy = mouseY - pmouseY; \r\n    \r\n    if (mag(dx, dy) > 5) { \r\n        let b = createBall(mouseX, mouseY, dx * 0.5, dy * 0.5);\r\n        balls.push(b); \r\n    }\r\n}\r\n"
            }
          ]
        }
      }
    },
    {
      "dataType": "javascript",
      "bodyData": {
        "document": {
          "savedAt": "11/24/2025, 11:57:07 PM",
          "sources": [
            {
              "fileExtension": "js",
              "filename": "sketch.js",
              "content": "// 最終課題を制作しよう\r\nlet balls = []; \r\n\r\nlet g = 0.2;\r\nlet vyMax = 20;\r\nconst restitution = -0.8;\r\n\r\nfunction setup() {\r\n    createCanvas(windowWidth, windowHeight);\r\n}\r\n\r\nfunction draw() {\r\n    background(0, 50);\r\n\r\n    // 止まったボールを削除\r\n    balls = balls.filter(b => {\r\n        const speed = sqrt(b.vx * b.vx + b.vy * b.vy);\r\n        const r = b.size / 2;\r\n\r\n        // 速度が小さくて床に触れている → 消す\r\n        if (speed < 5 && b.y + r >= height) {\r\n            return false;\r\n        }\r\n        return true;\r\n    });\r\n\r\n    // ボールの更新と描画\r\n    for (let i = 0; i < balls.length; i++) {\r\n        let b = balls[i];\r\n        let r = b.size / 2;\r\n\r\n        // 位置更新\r\n        b.x += b.vx;\r\n        b.y += b.vy;\r\n\r\n        // 重力\r\n        b.vy += g;\r\n        b.vy = constrain(b.vy, -vyMax, vyMax);\r\n\r\n        // 跳ね返り（半径を考慮）\r\n        if (b.x - r < 0) {\r\n            b.x = r;\r\n            b.vx *= restitution;\r\n        }\r\n        if (b.x + r > width) {\r\n            b.x = width - r;\r\n            b.vx *= restitution;\r\n        }\r\n        if (b.y - r < 0) {\r\n            b.y = r;\r\n            b.vy *= restitution;\r\n        }\r\n        if (b.y + r > height) {\r\n            b.y = height - r;\r\n            b.vy *= restitution;\r\n        }\r\n\r\n        // 描画\r\n        fill(b.color);\r\n        noStroke();\r\n        ellipse(b.x, b.y, b.size);\r\n    }\r\n}\r\n\r\nfunction createBall(x, y, vx, vy) {\r\n    return {\r\n        x: x,\r\n        y: y,\r\n        size: random(10, 30),\r\n        vx: vx,\r\n        vy: vy,\r\n        color: color(\r\n            random(100, 255),\r\n            random(100, 255),\r\n            random(100, 255),\r\n            180\r\n        )\r\n    };\r\n}\r\n\r\nfunction mouseDragged() {\r\n    const dx = mouseX - pmouseX; \r\n    const dy = mouseY - pmouseY; \r\n    \r\n    if (mag(dx, dy) > 5) { \r\n        let b = createBall(mouseX, mouseY, dx * 0.5, dy * 0.5);\r\n        balls.push(b); \r\n    }\r\n}\r\n"
            }
          ]
        }
      }
    }
  ]
}